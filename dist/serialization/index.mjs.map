{
  "version": 3,
  "sources": ["../../src/serialization/SoASerializer.ts", "../../src/serialization/SnapshotSerializer.ts", "../../src/serialization/ObserverSerializer.ts"],
  "sourcesContent": ["import { ComponentRef } from \"../core\"\n\n/**\n * Symbols representing different data types for serialization.\n */\nconst $u8 = Symbol('u8'), $i8 = Symbol('i8'), $u16 = Symbol('u16'), $i16 = Symbol('i16'),\n    $u32 = Symbol('u32'), $i32 = Symbol('i32'), $f32 = Symbol('f32'), $f64 = Symbol('f64')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = (number[] & { [key: symbol]: true }) | TypedArray\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: number[] = []): PrimitiveBrand => \n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64)\n\n/**\n * Object containing setter functions for each data type.\n */\nconst typeSetters = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; }\n}\n\n/**\n * Object containing getter functions for each data type.\n */\nconst typeGetters = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 })\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number) => {\n        let bytesWritten = 0\n        // Write index first\n        bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index)\n        for (let i = 0; i < props.length; i++) {\n            bytesWritten += setters[i](view, offset + bytesWritten, component[props[i]][index])\n        }\n        return bytesWritten\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        for (let i = 0; i < props.length; i++) {\n            const { value, size } = getters[i](view, offset + bytesRead)\n            component[props[i]][index] = value\n            bytesRead += size\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {ArrayBuffer} [buffer] - The buffer to use for serialization.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: ComponentRef[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const view = new DataView(buffer)\n    const componentSerializers = components.map(createComponentSerializer)\n    return (indices: number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index)\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: ComponentRef[]) => {\n    const componentDeserializers = components.map(createComponentDeserializer)\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            for (let i = 0; i < componentDeserializers.length; i++) {\n                offset += componentDeserializers[i](view, offset, entityIdMapping)\n            }\n        }\n    }\n}\n", "import { createSoASerializer, createSoADeserializer, PrimitiveBrand } from './SoASerializer'\nimport {\n    addComponent,\n    hasComponent,\n    World,\n    getAllEntities,\n    addEntity,\n} from '../core'\n\n/**\n * Creates a snapshot serializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the world state and returns a slice of the buffer.\n */\nexport const createSnapshotSerializer = (world: World, components: Record<string, PrimitiveBrand>[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n\n    /**\n     * Serializes entity-component relationships.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeEntityComponentRelationships = (entities: number[]) => {\n        const entityCount = entities.length\n        \n        // Write entity count\n        dataView.setUint32(offset, entityCount)\n        offset += 4\n\n        // Serialize entity-component relationships\n        for (let i = 0; i < entityCount; i++) {\n            const entityId = entities[i]\n            let componentCount = 0\n            \n            dataView.setUint32(offset, entityId)\n            offset += 4\n            \n            const componentCountOffset = offset\n            offset += 1\n            \n            for (let j = 0; j < components.length; j++) {\n                if (hasComponent(world, entityId, components[j])) {\n                    dataView.setUint8(offset, j)\n                    offset += 1\n                    componentCount++\n                }\n            }\n            \n            dataView.setUint8(componentCountOffset, componentCount)\n        }\n    }\n\n    /**\n     * Serializes component data for all entities.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeComponentData = (entities: number[]) => {\n        const soaSerializer = createSoASerializer(components, buffer.slice(offset))\n        const componentData = soaSerializer(entities)\n        new Uint8Array(buffer).set(new Uint8Array(componentData), offset)\n        offset += componentData.byteLength\n    }\n\n    return () => {\n        offset = 0\n        const entities = getAllEntities(world)\n        serializeEntityComponentRelationships(entities)\n        serializeComponentData(entities)\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a snapshot deserializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @returns {Function} A function that takes a serialized packet and deserializes it into the world, returning a map of packet entity IDs to world entity IDs.\n */\nexport const createSnapshotDeserializer = (world: World, components: Record<string, PrimitiveBrand>[]) => {\n    const soaDeserializer = createSoADeserializer(components)\n\n    return (packet: ArrayBuffer): Map<number, number> => {\n        const dataView = new DataView(packet)\n        let offset = 0\n        const entityIdMap = new Map<number, number>()\n\n        // Read entity count\n        const entityCount = dataView.getUint32(offset)\n        offset += 4\n\n        // Deserialize entity-component relationships\n        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n\n            const worldEntityId = addEntity(world)\n            entityIdMap.set(packetEntityId, worldEntityId)\n\n            const componentCount = dataView.getUint8(offset)\n            offset += 1\n\n            for (let i = 0; i < componentCount; i++) {\n                const componentIndex = dataView.getUint8(offset)\n                offset += 1\n                addComponent(world, worldEntityId, components[componentIndex])\n            }\n        }\n\n        // Deserialize component data\n        soaDeserializer(packet.slice(offset), entityIdMap)\n\n        return entityIdMap\n    }\n}\n", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n} from '../core'\nimport { EntityId } from '../core/Entity'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components to observe for changes.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the queued changes and returns a slice of the buffer.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number][] = []\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n    })\n\n    components.forEach((component, i) => {\n        observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n            queue.push([eid, OperationType.AddComponent, i])\n        })\n\n        observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n            queue.push([eid, OperationType.RemoveComponent, i])\n        })\n    })\n\n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            dataView.setUint8(offset, componentId)\n            offset += 1\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components that can be added or removed.\n * @returns {Function} A function that takes a serialized packet and an optional entity ID mapping, and applies the changes to the world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[]) => {\n    return (packet: ArrayBuffer, entityIdMapping: Map<number, number> = new Map()) => {\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            const componentId = dataView.getUint8(offset)\n            offset += 1\n\n            const component = components[componentId]\n\n            let worldEntityId = entityIdMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                entityIdMapping.set(packetEntityId, worldEntityId)\n            }\n            if (operationType === OperationType.AddEntity) {\n                addComponent(world, worldEntityId, networkedTag)\n            } else if (operationType === OperationType.RemoveEntity) {\n                removeEntity(world, worldEntityId)\n            } else if (operationType === OperationType.AddComponent) {\n                addComponent(world, worldEntityId, component)\n            } else if (operationType === OperationType.RemoveComponent) {\n                removeComponent(world, worldEntityId, component)\n            }\n        }\n\n        return entityIdMapping\n    }\n}\n"],
  "mappings": "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",
  "names": ["addComponent", "addEntity", "addEntity", "addComponent"]
}
