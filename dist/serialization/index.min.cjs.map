{
  "version": 3,
  "sources": ["../../src/serialization/index.ts", "../../src/serialization/SoASerializer.ts", "../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/Observer.ts", "../../src/core/Query.ts", "../../src/core/Relation.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/serialization/SnapshotSerializer.ts", "../../src/serialization/ObserverSerializer.ts"],
  "sourcesContent": ["\nexport {\n    createSoASerializer,\n    createSoADeserializer,\n    u8, i8, u16, i16, u32, i32, f32, f64,\n    type PrimitiveBrand\n} from './SoASerializer'\n\nexport {\n    createSnapshotSerializer,\n    createSnapshotDeserializer,\n} from './SnapshotSerializer'\n\nexport {\n    createObserverSerializer,\n    createObserverDeserializer\n} from './ObserverSerializer';", "import { ComponentRef } from \"bitecs\"\n\n/**\n * Symbols representing different data types for serialization.\n */\nexport const $u8 = Symbol.for('bitecs-u8'), $i8 = Symbol.for('bitecs-i8'), $u16 = Symbol.for('bitecs-u16'), $i16 = Symbol.for('bitecs-i16'),\n    $u32 = Symbol.for('bitecs-u32'), $i32 = Symbol.for('bitecs-i32'), $f32 = Symbol.for('bitecs-f32'), $f64 = Symbol.for('bitecs-f64')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = (number[] & { [key: symbol]: true }) | TypedArray\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: number[] = []): PrimitiveBrand => \n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64)\n\n/**\n * Object containing setter functions for each data type.\n */\nconst typeSetters = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; }\n}\n\n/**\n * Object containing getter functions for each data type.\n */\nconst typeGetters = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 })\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number) => {\n        let bytesWritten = 0\n        // Write index first\n        bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index)\n        for (let i = 0; i < props.length; i++) {\n            bytesWritten += setters[i](view, offset + bytesWritten, component[props[i]][index])\n        }\n        return bytesWritten\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        for (let i = 0; i < props.length; i++) {\n            const { value, size } = getters[i](view, offset + bytesRead)\n            component[props[i]][index] = value\n            bytesRead += size\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {ArrayBuffer} [buffer] - The buffer to use for serialization.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: ComponentRef[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const view = new DataView(buffer)\n    const componentSerializers = components.map(createComponentSerializer)\n    return (indices: number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index)\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: ComponentRef[]) => {\n    const componentDeserializers = components.map(createComponentDeserializer)\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            for (let i = 0; i < componentDeserializers.length; i++) {\n                offset += componentDeserializers[i](view, offset, entityIdMapping)\n            }\n        }\n    }\n}\n", "export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n    /** Flag indicating if versioning is enabled. */\n    versioning: boolean\n    /** Number of bits used for versioning. */\n    versionBits: number\n    /** Bit mask for entity ID. */\n    entityMask: number\n    /** Bit shift for version. */\n    versionShift: number\n    /** Bit mask for version. */\n    versionMask: number\n}\n\n/**\n * Extracts the entity ID from a versioned entity ID by stripping off the version.\n * @param {EntityIndex} index - The EntityIndex containing the masks.\n * @param {number} id - The versioned entity ID.\n * @returns {number} The entity ID without the version.\n */\nexport const getId = (index: EntityIndex, id: number): number => id & index.entityMask;\n\n/**\n * Extracts the version from an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The version.\n */\nexport const getVersion = (index: EntityIndex, id: number): number => \n    (id >>> index.versionShift) & ((1 << index.versionBits) - 1);\n\n/**\n * Increments the version of an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The new entity ID with incremented version.\n */\nexport const incrementVersion = (index: EntityIndex, id: number): number => {\n    const currentVersion = getVersion(index, id);\n    const newVersion = (currentVersion + 1) & ((1 << index.versionBits) - 1);\n    return (id & index.entityMask) | (newVersion << index.versionShift);\n}\n\n/**\n * Creates configuration options for entity ID recycling with versioning.\n * @param {number} [versionBits] - Optional number of bits to use for version numbers. Defaults to 8 if not specified.\n * @returns {object} Configuration object with versioning enabled and specified version bits.\n */\nexport const withVersioning = (versionBits?: number) => ({\n    versioning: true,\n    versionBits\n})\n\n/**\n * Creates and initializes a new EntityIndex.\n * @param {object|function} [options] - Optional configuration object from withVersioning() or withVersioning function.\n * @param {boolean} options.versioning - Flag to enable versioning for recycled IDs.\n * @param {number} options.versionBits - Number of bits to use for versioning (default: 8).\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (options?: ReturnType<typeof withVersioning> | typeof withVersioning): EntityIndex => {\n    const config = options \n        ? typeof options === 'function' \n            ? options()\n            : options\n        : { versioning: false, versionBits: 8 }\n\n    const versionBits = config.versionBits ?? 8\n    const versioning = config.versioning ?? false\n    \n    const entityBits = 32 - versionBits\n    const entityMask = (1 << entityBits) - 1\n    const versionShift = entityBits\n    const versionMask = ((1 << versionBits) - 1) << versionShift\n\n    return {\n        aliveCount: 0,\n        dense: [],\n        sparse: [],\n        maxId: 0,\n        versioning,\n        versionBits,\n        entityMask,\n        versionShift,\n        versionMask\n    }\n}\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount];\n        const entityId = recycledId;\n        index.sparse[entityId] = index.aliveCount;\n        index.aliveCount++;\n        return recycledId;\n    }\n\n    // Create new id\n    const id = ++index.maxId;\n    index.dense.push(id);\n    index.sparse[id] = index.aliveCount;\n    index.aliveCount++;\n\n    return id;\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const denseIndex = index.sparse[id];\n    if (denseIndex === undefined || denseIndex >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return;\n    }\n\n    const lastIndex = index.aliveCount - 1;\n    const lastId = index.dense[lastIndex];\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex;\n    index.dense[denseIndex] = lastId;\n\n    // Update the removed entity's record\n    index.sparse[id] = lastIndex; // Set to lastIndex instead of undefined\n    index.dense[lastIndex] = id; // Keep the original id, don't strip version\n\n    // Version the ID if enabled\n    if (index.versioning) {\n        const newId = incrementVersion(index, id);\n        index.dense[lastIndex] = newId;\n    }\n\n    index.aliveCount--;\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const entityId = getId(index, id);\n    const denseIndex = index.sparse[entityId];\n    return denseIndex !== undefined && denseIndex < index.aliveCount && index.dense[denseIndex] === id;\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query } from './Query'\nimport { EntityId } from './Entity'\n\nexport const $internal = Symbol.for('bitecs_internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<EntityId, Set<ComponentRef>>\n    bitflag: number\n    componentMap: Map<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n    entitiesWithRelations: Set<EntityId>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \n    defineHiddenProperty(context || {} as T, $internal, {\n        entityIndex: entityIndex || createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new Map(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n        entitiesWithRelations: new Set(),\n}) as World<T>\n\n/**\n * Creates a new world with various configurations.\n * @template T\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\n * @returns {World<T>} The created world.\n */\n\n// TODO: middleware\n\nexport function createWorld<T extends object = {}>(\n    ...args: Array<EntityIndex | T>\n): World<T> {\n    let entityIndex: EntityIndex | undefined\n    let context: T | undefined\n\n    args.forEach(arg => {\n        if (typeof arg === 'object' && 'add' in arg && 'remove' in arg) {\n            entityIndex = arg as EntityIndex\n        } else if (typeof arg === 'object') {\n            context = arg as T\n        }\n    })\n\n    return createBaseWorld<T>(context, entityIndex)\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    ctx.entitiesWithRelations = new Set()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World) => (world as InternalWorld)[$internal].entityIndex.dense.slice(0)\n", "import { EntityId } from \"../Entity\"\n\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: EntityId, ...args: any[])  => void | object\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n  const notify = (entity: EntityId, ...args: any[]) => {\n    return Array.from(observers).reduce((acc, listener) => {\n      const result = listener(entity, ...args)\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\n    }, {})\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { EntityId, Prefab } from './Entity'\n\n/**\n * @typedef {Uint32Array | readonly number[]} QueryResult\n * @description The result of a query, either as a Uint32Array or a readonly array of numbers.\n */\nexport type QueryResult = Uint32Array | readonly EntityId[]\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS.\n * @property {ComponentRef[]} allComponents - All components in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Object.<number, number>} masks - Bitmasks for each component generation.\n * @property {Object.<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Object.<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Object.<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: Record<number, number>\n\torMasks: Record<number, number>\n\tnotMasks: Record<number, number>\n\thasMasks: Record<number, number>\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n\tqueues: Record<any, any>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n/**\n * Symbol for query operator type.\n * @type {Symbol}\n */\nexport const $opType = Symbol.for('bitecs-opType')\n\n/**\n * Symbol for query operator terms.\n * @type {Symbol}\n */\nexport const $opTerms = Symbol.for('bitecs-opTerms')\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opTerms] - The components involved in the operation.\n */\nexport type OpReturnType = {\n\t[$opType]: string\n\t[$opTerms]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator} QueryTerm\n * @description A term in a query, either a component reference or a query operator.\n */\nexport type QueryTerm = ComponentRef | QueryOperator\n\n\n// Aliases\nexport type OrOp = QueryOperator\nexport type AndOp = QueryOperator\nexport type NotOp = QueryOperator\nexport type AnyOp = OrOp\nexport type AllOp = AndOp\nexport type NoneOp = NotOp\n\n/**\n * @function Or\n * @description Creates an 'Or' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Or' operator to.\n * @returns {OpReturnType} The 'Or' operator configuration.\n */\nexport const Or: OrOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Or',\n\t[$opTerms]: components\n})\n\n/**\n * @function And\n * @description Creates an 'And' query operator.\n * @param {...ComponentRef} components - The components to apply the 'And' operator to.\n * @returns {OpReturnType} The 'And' operator configuration.\n */\nexport const And: AndOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'And',\n\t[$opTerms]: components\n})\n\n/**\n * @function Not\n * @description Creates a 'Not' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Not' operator to.\n * @returns {OpReturnType} The 'Not' operator configuration.\n */\nexport const Not: NotOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Not',\n\t[$opTerms]: components\n})\n\nexport const Any: AnyOp = Or\nexport const All: AllOp = And\nexport const None: NoneOp = Not\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...QueryTerm} terms - The query terms to observe.\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\n */\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\n\t[$opTerms]: QueryTerm[]\n}\n\nexport type ObservableHook = ReturnType<ObservableHookDef>\n\n/**\n * @function onAdd\n * @description Creates an 'add' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for addition.\n * @returns {OpReturnType} The 'add' observable hook configuration.\n */\nexport const onAdd: ObservableHookDef = (...terms: QueryTerm[]) => ({\n\t[$opType]: 'add',\n\t[$opTerms]: terms\n})\n\n/**\n * @function onRemove\n * @description Creates a 'remove' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for removal.\n * @returns {OpReturnType} The 'remove' observable hook configuration.\n */\nexport const onRemove: ObservableHookDef = (...terms: QueryTerm[]) => ({\n\t[$opType]: 'remove',\n\t[$opTerms]: terms\n})\n\n/**\n * @function onSet\n * @description Creates a 'set' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for setting.\n * @returns {OpReturnType} The 'set' observable hook configuration.\n */\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({\n\t[$opType]: 'set',\n\t[$opTerms]: [component]\n})\n\n/**\n * @function onGet\n * @description Creates a 'get' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for getting.\n * @returns {OpReturnType} The 'get' observable hook configuration.\n */\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({\n\t[$opType]: 'get',\n\t[$opTerms]: [component]\n})\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ObservableHook} hook - The observable hook.\n * @param {function(number): any} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opTerms]: components } = hook\n\n\tif (type === 'add' || type === 'remove') {\n\t\tconst hash = queryHash(world, components)\n\t\tlet queryData = ctx.queriesHashMap.get(hash)!\n\n\t\tif (!queryData) {\n\t\t\tqueryData = registerQuery(world, components)\n\t\t}\n\n\t\tconst observableKey = type === 'add' ? 'addObservable' : 'removeObservable'\n\t\treturn queryData[observableKey].subscribe(callback)\n\t} else if (type === 'set' || type === 'get') {\n\t\tif (components.length !== 1) {\n\t\t\tthrow new Error('Set and Get hooks can only observe a single component')\n\t\t}\n\t\tconst component = components[0]\n\t\tlet componentData = ctx.componentMap.get(component)\n\t\tif (!componentData) {\n\t\t\tcomponentData = registerComponent(world, component)\n\t\t}\n\t\tconst observableKey = type === 'set' ? 'setObservable' : 'getObservable'\n\t\treturn componentData[observableKey].subscribe(callback)\n\t}\n\n\tthrow new Error(`Invalid hook type: ${type}`)\n}\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\n\tconst getComponentId = (component: ComponentRef): number => {\n\t\tif (!ctx.componentMap.has(component)) {\n\t\t\tregisterComponent(world, component)\n\t\t}\n\t\treturn ctx.componentMap.get(component)!.id\n\t}\n\tconst termToString = (term: QueryTerm): string => {\n\t\tif ($opType in term) {\n\t\t\tconst componentIds = term[$opTerms].map(getComponentId)\n\t\t\tconst sortedComponentIds = componentIds.sort((a, b) => a - b)\n\t\t\tconst sortedType = term[$opType].toLowerCase()\n\t\t\treturn `${sortedType}(${sortedComponentIds.join(',')})`\n\t\t} else {\n\t\t\treturn getComponentId(term).toString()\n\t\t}\n\t}\n\n\treturn terms\n\t\t.map(termToString)\n\t\t.sort()\n\t\t.join('-')\n}\n\n/**\n * @function registerQuery\n * @description Registers a new query in the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\t// if (ctx.queriesHashMap.has(hash)) {\n\t// \treturn ctx.queriesHashMap.get(hash)!\n\t// }\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst processComponents = (comps: ComponentRef[], targetArray: ComponentRef[]) => {\n\t\tcomps.forEach((comp: ComponentRef) => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\ttargetArray.push(comp)\n\t\t})\n\t}\n\n\tterms.forEach((term: QueryTerm) => {\n\t\tif ($opType in term) {\n\t\t\tif (term[$opType] === 'Not') {\n\t\t\t\tprocessComponents(term[$opTerms], notComponents)\n\t\t\t} else if (term[$opType] === 'Or') {\n\t\t\t\tprocessComponents(term[$opTerms], orComponents)\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst mapComponents = (c: ComponentRef) => ctx.componentMap.get(c)!\n\tconst allComponents = components.concat(notComponents.flat()).concat(orComponents.flat()).map(mapComponents)\n\n\tconst sparseSet = options.buffered ? createUint32SparseSet() : createSparseSet()\n\n\tconst toRemove = createSparseSet()\n\n\tconst generations = allComponents\n\t\t.map((c) => c.generationId)\n\t\t.reduce((a, v) => {\n\t\t\tif (a.includes(v)) return a\n\t\t\ta.push(v)\n\t\t\treturn a\n\t\t}, [] as number[])\n\n\tconst reduceBitflags = (a: { [key: number]: number }, c: ComponentData) => {\n\t\tif (!a[c.generationId]) a[c.generationId] = 0\n\t\ta[c.generationId] |= c.bitflag\n\t\treturn a\n\t}\n\n\tconst masks = components.map(mapComponents).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponents.reduce(reduceBitflags, {})\n\n\tconst addObservable = createObservable()\n\tconst removeObservable = createObservable()\n\n\tconst query = Object.assign(sparseSet, {\n\t\tcomponents,\n\t\tnotComponents,\n\t\torComponents,\n\t\tallComponents,\n\t\tmasks,\n\t\tnotMasks,\n\t\torMasks,\n\t\thasMasks,\n\t\tgenerations,\n\t\ttoRemove,\n\t\taddObservable,\n\t\tremoveObservable,\n\t\tqueues: {},\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponents.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, eid, Prefab)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n/**\n * @function innerQuery\n * @description Performs an internal query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function innerQuery(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\treturn queryData.dense\n}\n\n/**\n * @function query\n * @description Performs a query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {readonly EntityId[]} The result of the query as a readonly array of entity IDs.\n */\nexport function query(world: World, terms: QueryTerm[]): readonly EntityId[] {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms) as EntityId[]\n}\n\n/**\n * @function bufferQuery\n * @description Performs a buffered query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {Uint32Array} The result of the query as a Uint32Array.\n */\nexport function bufferQuery(world: World, terms: QueryTerm[]): Uint32Array {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms, { buffered: true }) as Uint32Array\n}\n\n/**\n * @function queryCheckEntity\n * @description Checks if an entity matches a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) === 0) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { getEntityComponents, World } from '.'\nimport { EntityId } from './Entity'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number} target - The target entity ID.\n */\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol.for('bitecs-relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol.for('bitecs-pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol.for('bitecs-isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol.for('bitecs-relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: () => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = data.initStore ? data.initStore() : {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: () => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n    return relation\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>): number[] => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard && !isRelation(c[$pairTarget])) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n\n/**\n * Symbol used to mark a relation as a wildcard relation\n */\nexport const $wildcard = Symbol.for('bitecs-wildcard')\n\n/**\n * Creates a wildcard relation that matches any target.\n * @template T\n * @returns {Relation<T>} The created wildcard relation.\n */\nexport function createWildcardRelation<T>(): Relation<T> {\n    const relation = createBaseRelation<T>()\n    Object.defineProperty(relation, $wildcard, {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: false\n    })\n    return relation\n}\n\n/**\n * Gets the singleton wildcard instance.\n * @returns {Relation<any>} The global wildcard relation instance.\n */\nexport function getWildcard(): Relation<any> {\n    const GLOBAL_WILDCARD = Symbol.for('bitecs-global-wildcard')\n    \n    if (!(globalThis as any)[GLOBAL_WILDCARD]) {\n        (globalThis as any)[GLOBAL_WILDCARD] = createWildcardRelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_WILDCARD]\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard = getWildcard()\n\n/**\n * Creates an IsA relation.\n * @template T\n * @returns {Relation<T>} The created IsA relation.\n */\nexport function createIsARelation<T>(): Relation<T> {\n    return createBaseRelation<T>()\n}\n\n/**\n * Gets the singleton IsA instance.\n * @returns {Relation<any>} The global IsA relation instance.\n */\nexport function getIsA(): Relation<any> {\n    const GLOBAL_ISA = Symbol.for('bitecs-global-isa')\n    \n    if (!(globalThis as any)[GLOBAL_ISA]) {\n        (globalThis as any)[GLOBAL_ISA] = createIsARelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_ISA]\n}\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA = getIsA()\n\n/**\n * Checks if a relation is a wildcard relation.\n * @param {any} relation - The relation to check.\n * @returns {boolean} True if the relation is a wildcard relation, false otherwise.\n */\nexport function isWildcard(relation: any): boolean {\n    if (!relation) return false\n    const symbols = Object.getOwnPropertySymbols(relation)\n    return symbols.includes($wildcard)\n}\n\n/**\n * Checks if a component is a relation.\n * @param {any} component - The component to check.\n * @returns {boolean} True if the component is a relation, false otherwise.\n */\nexport function isRelation(component: any): boolean {\n    if (!component) return false\n    const symbols = Object.getOwnPropertySymbols(component)\n    return symbols.includes($relationData)\n}\n", "import { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport {\n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World } from './World'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n\tgetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable(),\n\t\tgetObservable: createObservable(),\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to check for.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n/**\n * Retrieves the data associated with a component for a specific entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to retrieve data for.\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\n */\nexport const getComponentData = (world: World, eid: EntityId, component: ComponentRef): any => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\treturn undefined\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\treturn undefined\n\t}\n\n\t// Notify observers that this component is being accessed\n\treturn componentData.getObservable.notify(eid)\n}\n\n/**\n * Helper function to set component data.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\n */\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\n\tcomponent,\n\tdata\n})\n\n/**\n * Sets the data for a component on an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n */\nexport const setComponent = (world: World, eid: EntityId, component: ComponentRef, data: any): void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot set component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tif (!ctx.componentMap.has(component)) {\n\t\tregisterComponent(world, component)\n\t}\n\n\tconst componentData = ctx.componentMap.get(component)!\n\n\tif (!hasComponent(world, eid, component)) {\n\t\taddComponent(world, eid, component)\n\t}\n\n\tcomponentData.setObservable.notify(eid, data)\n}\n\n/**\n * Recursively inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n * @param {boolean} isFirstSuper - Whether this is the first super in the inheritance chain.\n */\nconst recursivelyInherit = (world: World, baseEid: EntityId, inheritedEid: EntityId, isFirstSuper: boolean = true): void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t\n\taddComponent(world, baseEid, IsA(inheritedEid))\n\n\tfor (const component of getEntityComponents(world, inheritedEid)) {\n\t\tif (component === Prefab) {\n\t\t\tcontinue\n\t\t}\n\t\taddComponent(world, baseEid, component)\n\t\tif (isFirstSuper) {\n\t\t\t// TODO: inherit reference vs copy\n\t\t\tconst componentData = ctx.componentMap.get(component)\n\t\t\tif (componentData?.setObservable) {\n\t\t\t\tconst data = getComponentData(world, inheritedEid, component)\n\t\t\t\tcomponentData.setObservable.notify(baseEid, data)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const inheritedEid2 of getRelationTargets(world, inheritedEid, IsA)) {\n\t\trecursivelyInherit(world, baseEid, inheritedEid2, false)\n\t}\n}\n\n/**\n * Represents a component with data to be set on an entity.\n */\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\n\n/**\n * Adds one or more components to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {...(ComponentRef | ComponentSetter)} components - Components to add or set.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void => {\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\n\t}\n\t\n\tconst ctx = (world as InternalWorld)[$internal]\n\t\n\tcomponents.forEach(componentOrSet => {\n\t\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\n\t\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\n\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\t\tconst componentData = ctx.componentMap.get(component)!\n\t\tif (data !== undefined) {\n\t\t\tcomponentData.setObservable.notify(eid, data)\n\t\t}\n\n\t\tif (hasComponent(world, eid, component)) return\n\n\t\tconst { generationId, bitflag, queries } = componentData\n\n\t\tctx.entityMasks[generationId][eid] |= bitflag\n\n\t\tif (!hasComponent(world, eid, Prefab)) {\n\t\t\tqueries.forEach((queryData: Query) => {\n\t\t\t\tqueryData.toRemove.remove(eid)\n\t\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t\t})\n\t\t}\n\t\tctx.entityComponents.get(eid)!.add(component)\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst relation = component[$relation]\n\t\t\tconst target = component[$pairTarget]\n\n\t\t\t// Add both Wildcard pairs for relation and target\n\t\t\taddComponent(world, eid, Pair(relation, Wildcard))\n\t\t\taddComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\t// For non-Wildcard targets, add Wildcard pair to track relation targets\n\t\t\tif (typeof target === 'number') {\n\t\t\t\t// Add Wildcard pair for target being a relation target\n\t\t\t\taddComponent(world, target, Pair(Wildcard, relation))\n\t\t\t\t\n\t\t\t\t// add target to a set to make autoRemoveSubject checks faster\n\t\t\t\tctx.entitiesWithRelations.add(target)\n\t\t\t}\n\n\t\t\t// add target to a set to make autoRemoveSubject checks faster\n\t\t\tctx.entitiesWithRelations.add(target)\n\n\t\t\tconst relationData = relation[$relationData]\n\t\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\n\t\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (relation === IsA) {\n\t\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\n\t\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\t\trecursivelyInherit(world, eid, inherited)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for addComponent.\n */\nexport const addComponents = addComponent\n\n/**\n * Removes one or more components from an entity.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(component => {\n\t\tif (!hasComponent(world, eid, component)) return\n\n\t\tconst componentNode = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentNode\n\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\n\t\tctx.entityComponents.get(eid)!.delete(component)\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst target = component[$pairTarget]\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\tconst relation = component[$relation]\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\n\t\t\tif (otherTargets.length === 0) {\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for removeComponent.\n */\nexport const removeComponents = removeComponent\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tinnerQuery,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport type EntityId = number\n\nexport const Prefab = {}\nexport const addPrefab = (world: World): EntityId => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, eid, Prefab)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): EntityId => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, child, ChildOf(parent))\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n\t\tif (ctx.entitiesWithRelations.has(currentEid)) {\n\t\t\tfor (const subject of innerQuery(world, [Wildcard(currentEid)])) {\n\t\t\t\tif (!entityExists(world, subject)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const component of ctx.entityComponents.get(subject)!) {\n\t\t\t\t\tif (!component[$isPairComponent]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst relation = component[$relation]\n\t\t\t\t\tconst relationData = relation[$relationData]\n\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\n\n\t\t\t\t\tif (component[$pairTarget] === currentEid) {\n\t\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, component))\n\t\t\t\t\t\tif (relationData.autoRemoveSubject) {\n\t\t\t\t\t\t\tremovalQueue.push(subject)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationData.onTargetRemoved) {\n\t\t\t\t\t\t\tcomponentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.entitiesWithRelations.delete(currentEid)\n\t\t}\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error(`getEntityComponents: entity id is undefined.`)\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error(`getEntityComponents: entity ${eid} does not exist in the world.`)\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "import { createSoASerializer, createSoADeserializer, PrimitiveBrand } from './SoASerializer'\nimport {\n    addComponent,\n    hasComponent,\n    World,\n    getAllEntities,\n    addEntity,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    Relation,\n    ComponentRef,\n    query\n} from '../core'\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32 } from './SoASerializer'\nquery\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            dataView.setFloat64(offset, value)\n            return offset + 8\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr) {\n                arr[eid] = dataView.getUint32(offset)\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Creates a snapshot serializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the world state and returns a slice of the buffer.\n */\nexport const createSnapshotSerializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n\n    /**\n     * Serializes entity-component relationships.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeEntityComponentRelationships = (entities: number[]) => {\n        const entityCount = entities.length\n        \n        // Write entity count\n        dataView.setUint32(offset, entityCount)\n        offset += 4\n\n        // Serialize entity-component relationships\n        for (let i = 0; i < entityCount; i++) {\n            const entityId = entities[i]\n            let componentCount = 0\n            \n            dataView.setUint32(offset, entityId)\n            offset += 4\n            \n            const componentCountOffset = offset\n            offset += 1\n            \n            for (let j = 0; j < components.length; j++) {\n                const component = components[j]\n                if (isRelation(component)) {\n                    const targets = getRelationTargets(world, entityId, component as Relation<any>)\n                    for (const target of targets) {\n                        dataView.setUint8(offset, j)\n                        offset += 1\n                        dataView.setUint32(offset, target)\n                        offset += 4\n                        const relationData = (component as any)(target)\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                        componentCount++\n                    }\n                } else if (hasComponent(world, entityId, component)) {\n                    dataView.setUint8(offset, j)\n                    offset += 1\n                    componentCount++\n                }\n            }\n            \n            dataView.setUint8(componentCountOffset, componentCount)\n        }\n    }\n\n    /**\n     * Serializes component data for all entities.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeComponentData = (entities: number[]) => {\n        const soaSerializer = createSoASerializer(components, buffer.slice(offset))\n        const componentData = soaSerializer(entities)\n        new Uint8Array(buffer).set(new Uint8Array(componentData), offset)\n        offset += componentData.byteLength\n    }\n\n    return () => {\n        offset = 0\n        const entities = getAllEntities(world)\n        serializeEntityComponentRelationships(entities)\n        serializeComponentData(entities)\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a snapshot deserializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @returns {Function} A function that takes a serialized packet and deserializes it into the world, returning a map of packet entity IDs to world entity IDs.\n */\nexport const createSnapshotDeserializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], constructorMapping?: Map<number, number>) => {\n    let entityIdMapping = constructorMapping || new Map<number, number>()\n    const soaDeserializer = createSoADeserializer(components)\n\n    return (packet: ArrayBuffer, overrideMapping?: Map<number, number>): Map<number, number> => {\n        const currentMapping = overrideMapping || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        // Read entity count\n        const entityCount = dataView.getUint32(offset)\n        offset += 4\n\n        // Deserialize entity-component relationships\n        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n\n            let worldEntityId = currentMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                currentMapping.set(packetEntityId, worldEntityId)\n            }\n\n            const componentCount = dataView.getUint8(offset)\n            offset += 1\n\n            for (let i = 0; i < componentCount; i++) {\n                const componentIndex = dataView.getUint8(offset)\n                offset += 1\n                const component = components[componentIndex]\n                \n                if (isRelation(component)) {\n                    const targetId = dataView.getUint32(offset)\n                    offset += 4\n                    let worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId === undefined) {\n                        worldTargetId = addEntity(world)\n                        currentMapping.set(targetId, worldTargetId)\n                    }\n                    const relationComponent = (component as (target: any) => any)(worldTargetId)\n                    addComponent(world, worldEntityId, relationComponent)\n                    offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset)\n                } else {\n                    addComponent(world, worldEntityId, component)\n                }\n            }\n        }\n\n        // Deserialize component data\n        soaDeserializer(packet.slice(offset), currentMapping)\n\n        return currentMapping\n    }\n}\n\n\nexport const test = (w:any) => {\n    return w === Wildcard\n}", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n    entityExists,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    EntityId\n} from 'bitecs'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3,\n    AddRelation = 4,\n    RemoveRelation = 5,\n}\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32 } from './SoASerializer'\n\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            dataView.setFloat64(offset, value)\n            return offset + 8\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr) {\n                arr[eid] = dataView.getUint32(offset)\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number, number?, any?][] = []\n    const relationTargets = new Map<number, Map<number, number>>()\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n        relationTargets.delete(eid)\n    })\n\n    components.forEach((component, i) => {\n        if (isRelation(component)) {\n            observe(world, onAdd(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targets = getRelationTargets(world, eid, component)\n                for (const target of targets) {\n                    if (!relationTargets.has(eid)) {\n                        relationTargets.set(eid, new Map())\n                    }\n                    relationTargets.get(eid).set(i, target)\n                    const relationData = component(target)\n                    queue.push([eid, OperationType.AddRelation, i, target, relationData])\n                }\n            })\n\n            observe(world, onRemove(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targetMap = relationTargets.get(eid)\n                if (targetMap) {\n                    const target = targetMap.get(i)\n                    if (target !== undefined) {\n                        queue.push([eid, OperationType.RemoveRelation, i, target])\n                        targetMap.delete(i)\n                        if (targetMap.size === 0) {\n                            relationTargets.delete(eid)\n                        }\n                    }\n                }\n            })\n        } else {\n            observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.AddComponent, i])\n            })\n\n            observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.RemoveComponent, i])\n            })\n        }\n    })\n    \n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId, targetId, relationData] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            if (type === OperationType.AddComponent || \n                type === OperationType.RemoveComponent || \n                type === OperationType.AddRelation ||\n                type === OperationType.RemoveRelation) {\n                dataView.setUint8(offset, componentId)\n                offset += 1\n                \n                if (type === OperationType.AddRelation || type === OperationType.RemoveRelation) {\n                    dataView.setUint32(offset, targetId)\n                    offset += 4\n                    \n                    if (type === OperationType.AddRelation && relationData) {\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                    }\n                }\n            }\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], constructorMapping?: Map<number, number>) => {\n    let entityIdMapping = constructorMapping || new Map<number, number>()\n    \n    return (packet: ArrayBuffer, overrideMapping?: Map<number, number>) => {\n        // Allow overriding the mapping for this call\n        const currentMapping = overrideMapping || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            let componentId = -1\n            let targetId = -1\n            \n            if (operationType === OperationType.AddComponent || \n                operationType === OperationType.RemoveComponent ||\n                operationType === OperationType.AddRelation ||\n                operationType === OperationType.RemoveRelation) {\n                componentId = dataView.getUint8(offset)\n                offset += 1\n                \n                if (operationType === OperationType.AddRelation || operationType === OperationType.RemoveRelation) {\n                    targetId = dataView.getUint32(offset)\n                    offset += 4\n                }\n            }\n\n            const component = components[componentId]\n            let worldEntityId = currentMapping.get(packetEntityId)\n\n            if (operationType === OperationType.AddEntity) {\n                if (worldEntityId === undefined) {\n                    worldEntityId = addEntity(world)\n                    currentMapping.set(packetEntityId, worldEntityId)\n                    addComponent(world, worldEntityId, networkedTag)\n                } else {\n                    throw new Error(`Entity with ID ${packetEntityId} already exists in the mapping.`)\n                }\n            } else if (worldEntityId !== undefined && entityExists(world, worldEntityId)) {\n                if (operationType === OperationType.RemoveEntity) {\n                    removeEntity(world, worldEntityId)\n                } else if (operationType === OperationType.AddComponent) {\n                    addComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.RemoveComponent) {\n                    removeComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.AddRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        const relationComponent = component(worldTargetId)\n                        addComponent(world, worldEntityId, relationComponent)\n                        offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset)\n                    }\n                } else if (operationType === OperationType.RemoveRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        removeComponent(world, worldEntityId, component(worldTargetId))\n                    }\n                }\n            }\n        }\n\n        return currentMapping\n    }\n}\n"],
  "mappings": "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",
  "names": ["serialization_exports", "__export", "createObserverDeserializer", "createObserverSerializer", "createSnapshotDeserializer", "createSnapshotSerializer", "createSoADeserializer", "createSoASerializer", "f32", "f64", "i16", "i32", "i8", "u16", "u32", "u8", "__toCommonJS", "$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "typeTagForSerialization", "symbol", "a", "u8", "i8", "u16", "i16", "u32", "i32", "f32", "f64", "typeSetters", "view", "offset", "value", "typeGetters", "createComponentSerializer", "component", "props", "setters", "prop", "arr", "type", "index", "bytesWritten", "i", "createComponentDeserializer", "getters", "entityIdMapping", "bytesRead", "originalIndex", "indexSize", "size", "createSoASerializer", "components", "buffer", "componentSerializers", "indices", "j", "createSoADeserializer", "componentDeserializers", "packet", "defineHiddenProperty", "obj", "key", "value", "getId", "index", "id", "addEntityId", "index", "recycledId", "entityId", "id", "isEntityIdAlive", "index", "id", "entityId", "getId", "denseIndex", "$internal", "getAllEntities", "world", "$internal", "createObservable", "observers", "observer", "entity", "args", "acc", "listener", "result", "$opType", "$opTerms", "queryCheckEntity", "world", "query", "eid", "ctx", "$internal", "masks", "notMasks", "orMasks", "generations", "i", "generationId", "qMask", "qNotMask", "qOrMask", "eMask", "queryAddEntity", "query", "eid", "queryRemoveEntity", "world", "query", "eid", "ctx", "$internal", "$relation", "$pairTarget", "$isPairComponent", "$relationData", "createBaseRelation", "data", "relation", "target", "normalizedTarget", "Wildcard", "component", "defineHiddenProperty", "Pair", "relation", "target", "getRelationTargets", "world", "eid", "components", "getEntityComponents", "targets", "c", "$relation", "$pairTarget", "Wildcard", "isRelation", "$wildcard", "createWildcardRelation", "relation", "createBaseRelation", "getWildcard", "GLOBAL_WILDCARD", "Wildcard", "createIsARelation", "getIsA", "GLOBAL_ISA", "IsA", "isRelation", "component", "$relationData", "registerComponent", "world", "component", "ctx", "$internal", "queries", "data", "createObservable", "hasComponent", "world", "eid", "component", "ctx", "$internal", "registeredComponent", "generationId", "bitflag", "getComponentData", "componentData", "recursivelyInherit", "world", "baseEid", "inheritedEid", "isFirstSuper", "ctx", "$internal", "addComponent", "IsA", "component", "getEntityComponents", "Prefab", "componentData", "data", "getComponentData", "inheritedEid2", "getRelationTargets", "eid", "components", "entityExists", "componentOrSet", "registerComponent", "hasComponent", "generationId", "bitflag", "queries", "queryData", "queryCheckEntity", "queryAddEntity", "queryRemoveEntity", "$isPairComponent", "relation", "$relation", "target", "$pairTarget", "Pair", "Wildcard", "$relationData", "oldTarget", "removeComponent", "inheritedTargets", "inherited", "removeComponent", "world", "eid", "components", "ctx", "$internal", "entityExists", "component", "hasComponent", "componentNode", "generationId", "bitflag", "queries", "queryData", "queryCheckEntity", "queryAddEntity", "queryRemoveEntity", "$isPairComponent", "target", "$pairTarget", "Pair", "Wildcard", "relation", "$relation", "getRelationTargets", "Prefab", "addEntity", "world", "ctx", "$internal", "eid", "addEntityId", "q", "queryCheckEntity", "queryAddEntity", "getEntityComponents", "world", "eid", "ctx", "$internal", "isEntityIdAlive", "entityExists", "serializeRelationData", "data", "eid", "dataView", "offset", "value", "keys", "key", "arr", "$i8", "$u8", "$i16", "$u16", "$i32", "$u32", "$f32", "deserializeRelationData", "createSnapshotSerializer", "world", "components", "buffer", "serializeEntityComponentRelationships", "entities", "entityCount", "i", "entityId", "componentCount", "componentCountOffset", "j", "component", "isRelation", "targets", "getRelationTargets", "target", "relationData", "hasComponent", "serializeComponentData", "componentData", "createSoASerializer", "getAllEntities", "createSnapshotDeserializer", "constructorMapping", "entityIdMapping", "soaDeserializer", "createSoADeserializer", "packet", "overrideMapping", "currentMapping", "entityIndex", "packetEntityId", "worldEntityId", "addEntity", "componentIndex", "targetId", "worldTargetId", "relationComponent", "addComponent", "import_bitecs", "serializeRelationData", "data", "eid", "dataView", "offset", "value", "keys", "key", "arr", "$i8", "$u8", "$i16", "$u16", "$i32", "$u32", "$f32", "deserializeRelationData", "createObserverSerializer", "world", "networkedTag", "components", "buffer", "queue", "relationTargets", "component", "i", "targets", "target", "relationData", "targetMap", "entityId", "type", "componentId", "targetId", "createObserverDeserializer", "constructorMapping", "entityIdMapping", "packet", "overrideMapping", "currentMapping", "packetEntityId", "operationType", "worldEntityId", "worldTargetId", "relationComponent"]
}
