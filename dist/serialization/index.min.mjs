var B=Symbol("u8"),N=Symbol("i8"),F=Symbol("u16"),K=Symbol("i16"),W=Symbol("u32"),G=Symbol("i32"),L=Symbol("f32"),A=Symbol("f64"),h=e=>(t=[])=>Object.defineProperty(t,e,{value:!0,enumerable:!1,writable:!1,configurable:!1}),Me=h(B),De=h(N),Qe=h(F),ke=h(K),$e=h(W),we=h(G),Ue=h(L),ze=h(A),le={[B]:(e,t,n)=>(e.setUint8(t,n),1),[N]:(e,t,n)=>(e.setInt8(t,n),1),[F]:(e,t,n)=>(e.setUint16(t,n),2),[K]:(e,t,n)=>(e.setInt16(t,n),2),[W]:(e,t,n)=>(e.setUint32(t,n),4),[G]:(e,t,n)=>(e.setInt32(t,n),4),[L]:(e,t,n)=>(e.setFloat32(t,n),4),[A]:(e,t,n)=>(e.setFloat64(t,n),8)},ye={[B]:(e,t)=>({value:e.getUint8(t),size:1}),[N]:(e,t)=>({value:e.getInt8(t),size:1}),[F]:(e,t)=>({value:e.getUint16(t),size:2}),[K]:(e,t)=>({value:e.getInt16(t),size:2}),[W]:(e,t)=>({value:e.getUint32(t),size:4}),[G]:(e,t)=>({value:e.getInt32(t),size:4}),[L]:(e,t)=>({value:e.getFloat32(t),size:4}),[A]:(e,t)=>({value:e.getFloat64(t),size:8})},Ve=e=>{let t=Object.keys(e),r=t.map(o=>{let s=e[o];for(let i of[B,N,F,K,W,G,L,A])if(i in s)return i;return A}).map(o=>le[o]||(()=>{throw new Error("Unsupported or unannotated type")}));return(o,s,i)=>{let a=0;a+=le[W](o,s+a,i);for(let p=0;p<t.length;p++)a+=r[p](o,s+a,e[t[p]][i]);return a}},je=e=>{let t=Object.keys(e),r=t.map(o=>{let s=e[o];for(let i of[B,N,F,K,W,G,L,A])if(i in s)return i;return A}).map(o=>ye[o]||(()=>{throw new Error("Unsupported or unannotated type")}));return(o,s,i)=>{let a=0,{value:p,size:m}=ye[W](o,s+a);a+=m;let c=i?i.get(p)??p:p;for(let u=0;u<t.length;u++){let{value:f,size:d}=r[u](o,s+a);e[t[u]][c]=f,a+=d}return a}},re=(e,t=new ArrayBuffer(1024*1024*100))=>{let n=new DataView(t),r=e.map(Ve);return o=>{let s=0;for(let i=0;i<o.length;i++){let a=o[i];for(let p=0;p<r.length;p++)s+=r[p](n,s,a)}return t.slice(0,s)}},se=e=>{let t=e.map(je);return(n,r)=>{let o=new DataView(n),s=0;for(;s<n.byteLength;)for(let i=0;i<t.length;i++)s+=t[i](o,s,r)}};var ae=()=>{let e=[],t=[],n=i=>e[t[i]]===i;return{add:i=>{n(i)||(t[i]=e.push(i)-1)},remove:i=>{if(!n(i))return;let a=t[i],p=e.pop();p!==i&&(e[a]=p,t[p]=a)},has:n,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0}}},fe=(e=1e3)=>{let t=[],n=0,r=new Uint32Array(e),o=p=>p<t.length&&t[p]<n&&r[t[p]]===p;return{add:p=>{if(!o(p)){if(n>=r.length){let m=new Uint32Array(r.length*2);m.set(r),r=m}r[n]=p,t[p]=n,n++}},remove:p=>{if(!o(p))return;n--;let m=t[p],c=r[n];r[m]=c,t[c]=m},has:o,sparse:t,get dense(){return new Uint32Array(r.buffer,0,n)},reset:()=>{n=0,t.length=0}}};var k=(e,t,n)=>Object.defineProperty(e,t,{value:n,enumerable:!1,writable:!0,configurable:!0});var de=(e,t)=>t&e.entityMask,be=(e,t)=>t>>>e.versionShift&(1<<e.versionBits)-1,Pe=(e,t)=>{let r=be(e,t)+1&(1<<e.versionBits)-1;return t&e.entityMask|r<<e.versionShift};var ve=e=>{if(e.aliveCount<e.dense.length){let n=e.dense[e.aliveCount],r=n;return e.sparse[r]=e.aliveCount,e.aliveCount++,n}let t=++e.maxId;return e.dense.push(t),e.sparse[t]=e.aliveCount,e.aliveCount++,t},xe=(e,t)=>{let n=e.sparse[t];if(n===void 0||n>=e.aliveCount)return;let r=e.aliveCount-1,o=e.dense[r];if(e.sparse[o]=n,e.dense[n]=o,e.sparse[t]=r,e.dense[r]=t,e.versioning){let s=Pe(e,t);e.dense[r]=s}e.aliveCount--},Y=(e,t)=>{let n=de(e,t),r=e.sparse[n];return r!==void 0&&r<e.aliveCount&&e.dense[r]===t};var y=Symbol.for("bitecs_internal");var $=()=>{let e=new Set;return{subscribe:r=>(e.add(r),()=>{e.delete(r)}),notify:(r,...o)=>Array.from(e).reduce((s,i)=>{let a=i(r,...o);return a&&typeof a=="object"?{...s,...a}:s},{})}};var I=Symbol("opType"),w=Symbol("opTerms"),ee=(...e)=>({[I]:"add",[w]:e}),te=(...e)=>({[I]:"remove",[w]:e});function U(e,t,n){let r=e[y],{[I]:o,[w]:s}=t;if(o==="add"||o==="remove"){let i=ie(e,s),a=r.queriesHashMap.get(i);return a||(a=Z(e,s)),a[o==="add"?"addObservable":"removeObservable"].subscribe(n)}else if(o==="set"||o==="get"){if(s.length!==1)throw new Error("Set and Get hooks can only observe a single component");let i=s[0],a=r.componentMap.get(i);return a||(a=M(e,i)),a[o==="set"?"setObservable":"getObservable"].subscribe(n)}throw new Error(`Invalid hook type: ${o}`)}var ie=(e,t)=>{let n=e[y],r=s=>(n.componentMap.has(s)||M(e,s),n.componentMap.get(s).id),o=s=>{if(I in s){let a=s[w].map(r).sort((m,c)=>m-c);return`${s[I].toLowerCase()}(${a.join(",")})`}else return r(s).toString()};return t.map(o).sort().join("-")},Z=(e,t,n={})=>{let r=e[y],o=ie(e,t),s=[],i=[],a=[],p=(l,b)=>{l.forEach(X=>{r.componentMap.has(X)||M(e,X),b.push(X)})};t.forEach(l=>{I in l?l[I]==="Not"?p(l[w],i):l[I]==="Or"&&p(l[w],a):(r.componentMap.has(l)||M(e,l),s.push(l))});let m=l=>r.componentMap.get(l),c=s.concat(i.flat()).concat(a.flat()).map(m),u=n.buffered?fe():ae(),f=ae(),d=c.map(l=>l.generationId).reduce((l,b)=>(l.includes(b)||l.push(b),l),[]),x=(l,b)=>(l[b.generationId]||(l[b.generationId]=0),l[b.generationId]|=b.bitflag,l),oe=s.map(m).reduce(x,{}),Ee=i.map(m).reduce(x,{}),Oe=a.map(m).reduce(x,{}),Se=c.reduce(x,{}),We=$(),Ae=$(),S=Object.assign(u,{components:s,notComponents:i,orComponents:a,allComponents:c,masks:oe,notMasks:Ee,orMasks:Oe,hasMasks:Se,generations:d,toRemove:f,addObservable:We,removeObservable:Ae,queues:{}});r.queries.add(S),r.queriesHashMap.set(o,S),c.forEach(l=>{l.queries.add(S)}),i.length&&r.notQueries.add(S);let ue=r.entityIndex;for(let l=0;l<ue.aliveCount;l++){let b=ue.dense[l];if(g(e,b,j))continue;z(e,S,b)&&V(S,b)}return S};function pe(e,t,n={}){let r=e[y],o=ie(e,t),s=r.queriesHashMap.get(o);return s?n.buffered&&!("buffer"in s.dense)&&(s=Z(e,t,{buffered:!0})):s=Z(e,t,n),s.dense}function z(e,t,n){let r=e[y],{masks:o,notMasks:s,orMasks:i,generations:a}=t;for(let p=0;p<a.length;p++){let m=a[p],c=o[m],u=s[m],f=i[m],d=r.entityMasks[m][n];if(u&&d&u||c&&(d&c)!==c||f&&!(d&f))return!1}return!0}var V=(e,t)=>{e.toRemove.remove(t),e.addObservable.notify(t),e.add(t)};var _=(e,t,n)=>{let r=e[y];!t.has(n)||t.toRemove.has(n)||(t.toRemove.add(n),r.dirtyQueries.add(t),t.removeObservable.notify(n))};var Q=Symbol("relation"),O=Symbol("pairTarget"),H=Symbol("isPairComponent"),T=Symbol("relationData"),he=()=>{let e={pairsMap:new Map,initStore:void 0,exclusiveRelation:!1,autoRemoveSubject:!1,onTargetRemoved:void 0},t=n=>{if(n===void 0)throw Error("Relation target is undefined");let r=n==="*"?v:n;if(!e.pairsMap.has(r)){let o=e.initStore?e.initStore():{};k(o,Q,t),k(o,O,r),k(o,H,!0),e.pairsMap.set(r,o)}return e.pairsMap.get(r)};return k(t,T,e),t},Re=e=>t=>{let n=t[T];return n.initStore=e,t},He=e=>{let t=e[T];return t.exclusiveRelation=!0,e},ge=e=>{let t=e[T];return t.autoRemoveSubject=!0,e},Ce=e=>t=>{let n=t[T];return n.onTargetRemoved=e,t};var E=(e,t)=>{if(e===void 0)throw Error("Relation is undefined");return e(t)},v=me(),P=me(),q=(e,t,n)=>{let r=J(e,t),o=[];for(let s of r)s[Q]===n&&s[O]!==v&&o.push(s[O]);return o};function me(...e){if(e.length===1&&typeof e[0]=="object"){let{store:t,exclusive:n,autoRemoveSubject:r,onTargetRemoved:o}=e[0];return[t&&Re(t),n&&He,r&&ge,o&&Ce(o)].filter(Boolean).reduce((i,a)=>a(i),he())}else return e.reduce((n,r)=>r(n),he())}var j={};var ce=e=>{let t=e[y],n=ve(t.entityIndex);return t.notQueries.forEach(r=>{z(e,r,n)&&V(r,n)}),t.entityComponents.set(n,new Set),n},ne=(e,t)=>{let n=e[y];if(!Y(n.entityIndex,t))return;let r=[t],o=new Set;for(;r.length>0;){let s=r.shift();if(o.has(s))continue;o.add(s);let i=[];for(let a of pe(e,[v(s)]))if(D(e,a))for(let p of n.entityComponents.get(a)){if(!p[H])continue;let c=p[Q][T];i.push(()=>C(e,a,E(v,s))),p[O]===s&&(i.push(()=>C(e,a,p)),c.autoRemoveSubject&&r.push(a),c.onTargetRemoved&&i.push(()=>c.onTargetRemoved(e,a,s)))}for(let a of i)a();for(let a of r)ne(e,a);for(let a of n.queries)_(e,a,s);xe(n.entityIndex,s),n.entityComponents.delete(s);for(let a=0;a<n.entityMasks.length;a++)n.entityMasks[a][s]=0}},J=(e,t)=>{let n=e[y];if(t===void 0)throw new Error("bitECS - entity is undefined.");if(!Y(n.entityIndex,t))throw new Error("bitECS - entity does not exist in the world.");return Array.from(n.entityComponents.get(t))},D=(e,t)=>Y(e[y].entityIndex,t);var M=(e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");let n=e[y],r=new Set,o={id:n.componentCount++,generationId:n.entityMasks.length-1,bitflag:n.bitflag,ref:t,queries:r,setObservable:$(),getObservable:$()};return n.componentMap.set(t,o),n.bitflag*=2,n.bitflag>=2**31&&(n.bitflag=1,n.entityMasks.push([])),o};var g=(e,t,n)=>{let r=e[y],o=r.componentMap.get(n);if(!o)return!1;let{generationId:s,bitflag:i}=o;return(r.entityMasks[s][t]&i)===i},Te=(e,t,n)=>{let o=e[y].componentMap.get(n);if(o&&g(e,t,n))return o.getObservable.notify(t)};var Ie=(e,t,n)=>{let r=e[y];R(e,t,P(n));let o=J(e,n);for(let i of o){if(i===j)continue;R(e,t,i);let a=r.componentMap.get(i);if(a&&a.setObservable){let p=Te(e,n,i);a.setObservable.notify(t,p)}}let s=q(e,n,P);for(let i of s)Ie(e,t,i)},R=(e,t,...n)=>{let r=e[y];if(!D(e,t))throw new Error(`Cannot add component - entity ${t} does not exist in the world.`);n.forEach(o=>{let s="component"in o?o.component:o,i="data"in o?o.data:void 0;if(r.componentMap.has(s)||M(e,s),g(e,t,s))return;let a=r.componentMap.get(s),{generationId:p,bitflag:m,queries:c}=a;if(r.entityMasks[p][t]|=m,g(e,t,j)||c.forEach(u=>{u.toRemove.remove(t),z(e,u,t)?V(u,t):_(e,u,t)}),r.entityComponents.get(t).add(s),i!==void 0&&a.setObservable.notify(t,i),s[H]){let u=s[Q];R(e,t,E(u,v));let f=s[O];if(R(e,t,E(v,f)),u[T].exclusiveRelation===!0&&f!==v){let x=q(e,t,u)[0];x!=null&&x!==f&&C(e,t,u(x))}if(u===P){let x=q(e,t,P);for(let oe of x)Ie(e,t,oe)}}})};var C=(e,t,...n)=>{let r=e[y];if(!D(e,t))throw new Error(`Cannot remove component - entity ${t} does not exist in the world.`);n.forEach(o=>{if(!g(e,t,o))return;let s=r.componentMap.get(o),{generationId:i,bitflag:a,queries:p}=s;if(r.entityMasks[i][t]&=~a,p.forEach(m=>{m.toRemove.remove(t),z(e,m,t)?V(m,t):_(e,m,t)}),r.entityComponents.get(t).delete(o),o[H]){let m=o[O];C(e,t,E(v,m));let c=o[Q];q(e,t,c).length===0&&C(e,t,E(c,v))}})};import{getAllEntities as Be,addEntity as Ne}from"../core";var Fe=(e,t,n=new ArrayBuffer(1024*1024*100))=>{let r=new DataView(n),o=0,s=a=>{let p=a.length;r.setUint32(o,p),o+=4;for(let m=0;m<p;m++){let c=a[m],u=0;r.setUint32(o,c),o+=4;let f=o;o+=1;for(let d=0;d<t.length;d++)g(e,c,t[d])&&(r.setUint8(o,d),o+=1,u++);r.setUint8(f,u)}},i=a=>{let m=re(t,n.slice(o))(a);new Uint8Array(n).set(new Uint8Array(m),o),o+=m.byteLength};return()=>{o=0;let a=Be(e);return s(a),i(a),n.slice(0,o)}},Ke=(e,t)=>{let n=se(t);return r=>{let o=new DataView(r),s=0,i=new Map,a=o.getUint32(s);s+=4;for(let p=0;p<a;p++){let m=o.getUint32(s);s+=4;let c=Ne(e);i.set(m,c);let u=o.getUint8(s);s+=1;for(let f=0;f<u;f++){let d=o.getUint8(s);s+=1,R(e,c,t[d])}}return n(r.slice(s),i),i}};var Ge=(e,t,n,r=new ArrayBuffer(1024*1024*100))=>{let o=new DataView(r),s=0,i=[];return U(e,ee(t),a=>{i.push([a,0,-1])}),U(e,te(t),a=>{i.push([a,1,-1])}),n.forEach((a,p)=>{U(e,ee(t,a),m=>{i.push([m,2,p])}),U(e,te(t,a),m=>{i.push([m,3,p])})}),()=>{s=0;for(let a=0;a<i.length;a++){let[p,m,c]=i[a];o.setUint32(s,p),s+=4,o.setUint8(s,m),s+=1,(m===2||m===3)&&(o.setUint8(s,c),s+=1)}return i.length=0,r.slice(0,s)}},Le=(e,t,n,r=new Map)=>o=>{let s=new DataView(o),i=0;for(;i<o.byteLength;){let a=s.getUint32(i);i+=4;let p=s.getUint8(i);i+=1;let m=-1;(p===2||p===3)&&(m=s.getUint8(i),i+=1);let c=n[m],u=r.get(a);if(p===0)if(u===void 0)u=ce(e),r.set(a,u),R(e,u,t);else throw new Error(`Entity with ID ${a} already exists in the mapping.`);else u!==void 0&&D(e,u)&&(p===1?ne(e,u):p===2?R(e,u,c):p===3&&C(e,u,c))}return r};export{Le as createObserverDeserializer,Ge as createObserverSerializer,Ke as createSnapshotDeserializer,Fe as createSnapshotSerializer,se as createSoADeserializer,re as createSoASerializer,Ue as f32,ze as f64,ke as i16,we as i32,De as i8,Qe as u16,$e as u32,Me as u8};
//# sourceMappingURL=index.min.mjs.map
