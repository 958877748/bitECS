{
  "version": 3,
  "sources": ["../../src/serialization/SoASerializer.ts", "../../src/serialization/SnapshotSerializer.ts", "../../src/serialization/ObserverSerializer.ts"],
  "sourcesContent": ["import { ComponentRef } from \"bitecs\"\n\n/**\n * Symbols representing different data types for serialization.\n */\nconst $u8 = Symbol('u8'), $i8 = Symbol('i8'), $u16 = Symbol('u16'), $i16 = Symbol('i16'),\n    $u32 = Symbol('u32'), $i32 = Symbol('i32'), $f32 = Symbol('f32'), $f64 = Symbol('f64')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = (number[] & { [key: symbol]: true }) | TypedArray\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: number[] = []): PrimitiveBrand => \n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64)\n\n/**\n * Object containing setter functions for each data type.\n */\nconst typeSetters = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; }\n}\n\n/**\n * Object containing getter functions for each data type.\n */\nconst typeGetters = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 })\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number) => {\n        let bytesWritten = 0\n        // Write index first\n        bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index)\n        for (let i = 0; i < props.length; i++) {\n            bytesWritten += setters[i](view, offset + bytesWritten, component[props[i]][index])\n        }\n        return bytesWritten\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        for (let i = 0; i < props.length; i++) {\n            const { value, size } = getters[i](view, offset + bytesRead)\n            component[props[i]][index] = value\n            bytesRead += size\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {ArrayBuffer} [buffer] - The buffer to use for serialization.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: ComponentRef[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const view = new DataView(buffer)\n    const componentSerializers = components.map(createComponentSerializer)\n    return (indices: number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index)\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: ComponentRef[]) => {\n    const componentDeserializers = components.map(createComponentDeserializer)\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            for (let i = 0; i < componentDeserializers.length; i++) {\n                offset += componentDeserializers[i](view, offset, entityIdMapping)\n            }\n        }\n    }\n}\n", "import { createSoASerializer, createSoADeserializer, PrimitiveBrand } from './SoASerializer'\nimport {\n    addComponent,\n    hasComponent,\n    World,\n    getAllEntities,\n    addEntity,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    Relation,\n    ComponentRef\n} from 'bitecs'\n\n/**\n * Creates a snapshot serializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the world state and returns a slice of the buffer.\n */\nexport const createSnapshotSerializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n\n    /**\n     * Serializes entity-component relationships.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeEntityComponentRelationships = (entities: number[]) => {\n        const entityCount = entities.length\n        \n        // Write entity count\n        dataView.setUint32(offset, entityCount)\n        offset += 4\n\n        // Serialize entity-component relationships\n        for (let i = 0; i < entityCount; i++) {\n            const entityId = entities[i]\n            let componentCount = 0\n            \n            dataView.setUint32(offset, entityId)\n            offset += 4\n            \n            const componentCountOffset = offset\n            offset += 1\n            \n            for (let j = 0; j < components.length; j++) {\n                const component = components[j]\n                if (isRelation(component)) {\n                    const targets = getRelationTargets(world, entityId, component as Relation<any>)\n                    for (const target of targets) {\n                        dataView.setUint8(offset, j)\n                        offset += 1\n                        dataView.setUint32(offset, target)\n                        offset += 4\n                        componentCount++\n                    }\n                } else if (hasComponent(world, entityId, component)) {\n                    dataView.setUint8(offset, j)\n                    offset += 1\n                    componentCount++\n                }\n            }\n            \n            dataView.setUint8(componentCountOffset, componentCount)\n        }\n    }\n\n    /**\n     * Serializes component data for all entities.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeComponentData = (entities: number[]) => {\n        const soaSerializer = createSoASerializer(components, buffer.slice(offset))\n        const componentData = soaSerializer(entities)\n        new Uint8Array(buffer).set(new Uint8Array(componentData), offset)\n        offset += componentData.byteLength\n    }\n\n    return () => {\n        offset = 0\n        const entities = getAllEntities(world)\n        serializeEntityComponentRelationships(entities)\n        serializeComponentData(entities)\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a snapshot deserializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @returns {Function} A function that takes a serialized packet and deserializes it into the world, returning a map of packet entity IDs to world entity IDs.\n */\nexport const createSnapshotDeserializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[]) => {\n    const soaDeserializer = createSoADeserializer(components)\n\n    return (packet: ArrayBuffer): Map<number, number> => {\n        const dataView = new DataView(packet)\n        let offset = 0\n        const entityIdMap = new Map<number, number>()\n\n        // Read entity count\n        const entityCount = dataView.getUint32(offset)\n        offset += 4\n\n        // Deserialize entity-component relationships\n        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n\n            const worldEntityId = addEntity(world)\n            entityIdMap.set(packetEntityId, worldEntityId)\n\n            const componentCount = dataView.getUint8(offset)\n            offset += 1\n\n            for (let i = 0; i < componentCount; i++) {\n                const componentIndex = dataView.getUint8(offset)\n                offset += 1\n                const component = components[componentIndex]\n                \n                if (isRelation(component)) {\n                    const targetId = dataView.getUint32(offset)\n                    offset += 4\n                    // We need to wait until all entities are created before adding relations\n                    // Store relation info to add later\n                    if (!entityIdMap.has(targetId)) {\n                        const worldTargetId = addEntity(world)\n                        entityIdMap.set(targetId, worldTargetId)\n                    }\n                    const worldTargetId = entityIdMap.get(targetId)\n                    addComponent(world, worldEntityId, (component as (target: any) => any)(worldTargetId))\n                } else {\n                    addComponent(world, worldEntityId, component)\n                }\n            }\n        }\n\n        // Deserialize component data\n        soaDeserializer(packet.slice(offset), entityIdMap)\n\n        return entityIdMap\n    }\n}\n", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n    entityExists,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    EntityId\n  } from 'bitecs'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3,\n    AddRelation = 4,\n    RemoveRelation = 5,\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components to observe for changes.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the queued changes and returns a slice of the buffer.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number, number?][] = []\n    const relationTargets = new Map<number, Map<number, number>>() // eid -> (componentId -> targetId)\n    \n    // Entity observers remain the same\n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n        relationTargets.delete(eid)\n    })\n\n    components.forEach((component, i) => {\n        if (isRelation(component)) {\n            observe(world, onAdd(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targets = getRelationTargets(world, eid, component)\n                for (const target of targets) {\n                    // Store the target when relation is added\n                    if (!relationTargets.has(eid)) {\n                        relationTargets.set(eid, new Map())\n                    }\n                    relationTargets.get(eid).set(i, target)\n                    queue.push([eid, OperationType.AddRelation, i, target])\n                }\n            })\n\n            observe(world, onRemove(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                // Get target from stored map since relation is already removed\n                const targetMap = relationTargets.get(eid)\n                if (targetMap) {\n                    const target = targetMap.get(i)\n                    if (target !== undefined) {\n                        queue.push([eid, OperationType.RemoveRelation, i, target])\n                        targetMap.delete(i)\n                        if (targetMap.size === 0) {\n                            relationTargets.delete(eid)\n                        }\n                    }\n                }\n            })\n        } else {\n            observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.AddComponent, i])\n            })\n\n            observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.RemoveComponent, i])\n            })\n        }\n    })\n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId, targetId] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            if (type === OperationType.AddComponent || \n                type === OperationType.RemoveComponent || \n                type === OperationType.AddRelation ||\n                type === OperationType.RemoveRelation) {\n                dataView.setUint8(offset, componentId)\n                offset += 1\n                \n                // Write target entity ID for relations\n                if (type === OperationType.AddRelation || type === OperationType.RemoveRelation) {\n                    dataView.setUint32(offset, targetId)\n                    offset += 4\n                }\n            }\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components that can be added or removed.\n * @returns {Function} A function that takes a serialized packet and an optional entity ID mapping, and applies the changes to the world.\n*/\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], entityIdMapping: Map<number, number> = new Map()) => {\n    return (packet: ArrayBuffer) => {\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            let componentId = -1\n            let targetId = -1\n            if (operationType === OperationType.AddComponent || \n                operationType === OperationType.RemoveComponent ||\n                operationType === OperationType.AddRelation ||\n                operationType === OperationType.RemoveRelation) {\n                componentId = dataView.getUint8(offset)\n                offset += 1\n                \n                if (operationType === OperationType.AddRelation || operationType === OperationType.RemoveRelation) {\n                    targetId = dataView.getUint32(offset)\n                    offset += 4\n                }\n            }\n\n            const component = components[componentId]\n            \n            let worldEntityId = entityIdMapping.get(packetEntityId)\n\n            if (operationType === OperationType.AddEntity) {\n                if (worldEntityId === undefined) {\n                    worldEntityId = addEntity(world)\n                    entityIdMapping.set(packetEntityId, worldEntityId)\n                    addComponent(world, worldEntityId, networkedTag)\n                } else {\n                    throw new Error(`Entity with ID ${packetEntityId} already exists in the mapping.`)\n                }\n            } else if (worldEntityId !== undefined && entityExists(world, worldEntityId)) {\n                if (operationType === OperationType.RemoveEntity) {\n                    removeEntity(world, worldEntityId)\n                } else if (operationType === OperationType.AddComponent) {\n                    addComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.RemoveComponent) {\n                    removeComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.AddRelation) {\n                    const worldTargetId = entityIdMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        addComponent(world, worldEntityId, component(worldTargetId))\n                    }\n                } else if (operationType === OperationType.RemoveRelation) {\n                    const worldTargetId = entityIdMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        removeComponent(world, worldEntityId, component(worldTargetId))\n                    }\n                }\n            }\n        }\n\n        return entityIdMapping\n    }\n}\n"],
  "mappings": "AAKA,IAAMA,EAAM,OAAO,IAAI,EAAGC,EAAM,OAAO,IAAI,EAAGC,EAAO,OAAO,KAAK,EAAGC,EAAO,OAAO,KAAK,EACnFC,EAAO,OAAO,KAAK,EAAGC,EAAO,OAAO,KAAK,EAAGC,EAAO,OAAO,KAAK,EAAGC,EAAO,OAAO,KAAK,EA8BnFC,EAA2BC,GAAuB,CAACC,EAAc,CAAC,IACpE,OAAO,eAAeA,EAAGD,EAAQ,CAAE,MAAO,GAAM,WAAY,GAAO,SAAU,GAAO,aAAc,EAAM,CAAC,EAKhGE,EAAKH,EAAwBR,CAAG,EAAOY,EAAKJ,EAAwBP,CAAG,EACxEY,EAAML,EAAwBN,CAAI,EAAMY,EAAMN,EAAwBL,CAAI,EAC1EY,EAAMP,EAAwBJ,CAAI,EAAMY,EAAMR,EAAwBH,CAAI,EAC1EY,EAAMT,EAAwBF,CAAI,EAAMY,EAAMV,EAAwBD,CAAI,EAKhFY,EAAc,CAChB,CAACnB,CAAG,EAAG,CAACoB,EAAgBC,EAAgBC,KAAoBF,EAAK,SAASC,EAAQC,CAAK,EAAU,GACjG,CAACrB,CAAG,EAAG,CAACmB,EAAgBC,EAAgBC,KAAoBF,EAAK,QAAQC,EAAQC,CAAK,EAAU,GAChG,CAACpB,CAAI,EAAG,CAACkB,EAAgBC,EAAgBC,KAAoBF,EAAK,UAAUC,EAAQC,CAAK,EAAU,GACnG,CAACnB,CAAI,EAAG,CAACiB,EAAgBC,EAAgBC,KAAoBF,EAAK,SAASC,EAAQC,CAAK,EAAU,GAClG,CAAClB,CAAI,EAAG,CAACgB,EAAgBC,EAAgBC,KAAoBF,EAAK,UAAUC,EAAQC,CAAK,EAAU,GACnG,CAACjB,CAAI,EAAG,CAACe,EAAgBC,EAAgBC,KAAoBF,EAAK,SAASC,EAAQC,CAAK,EAAU,GAClG,CAAChB,CAAI,EAAG,CAACc,EAAgBC,EAAgBC,KAAoBF,EAAK,WAAWC,EAAQC,CAAK,EAAU,GACpG,CAACf,CAAI,EAAG,CAACa,EAAgBC,EAAgBC,KAAoBF,EAAK,WAAWC,EAAQC,CAAK,EAAU,EACxG,EAKMC,EAAc,CAChB,CAACvB,CAAG,EAAG,CAACoB,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,SAASC,CAAM,EAAG,KAAM,CAAE,GACpF,CAACpB,CAAG,EAAG,CAACmB,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,QAAQC,CAAM,EAAG,KAAM,CAAE,GACnF,CAACnB,CAAI,EAAG,CAACkB,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,UAAUC,CAAM,EAAG,KAAM,CAAE,GACtF,CAAClB,CAAI,EAAG,CAACiB,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,SAASC,CAAM,EAAG,KAAM,CAAE,GACrF,CAACjB,CAAI,EAAG,CAACgB,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,UAAUC,CAAM,EAAG,KAAM,CAAE,GACtF,CAAChB,CAAI,EAAG,CAACe,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,SAASC,CAAM,EAAG,KAAM,CAAE,GACrF,CAACf,CAAI,EAAG,CAACc,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,WAAWC,CAAM,EAAG,KAAM,CAAE,GACvF,CAACd,CAAI,EAAG,CAACa,EAAgBC,KAAoB,CAAE,MAAOD,EAAK,WAAWC,CAAM,EAAG,KAAM,CAAE,EAC3F,EAOaG,EAA6BC,GAA4B,CAClE,IAAMC,EAAQ,OAAO,KAAKD,CAAS,EAQ7BE,EAPQD,EAAM,IAAIE,GAAQ,CAC5B,IAAMC,EAAMJ,EAAUG,CAAI,EAC1B,QAAWnB,IAAU,CAACT,EAAKC,EAAKC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,CAAI,EAC9D,GAAIE,KAAUoB,EAAK,OAAOpB,EAE9B,OAAOF,CACX,CAAC,EACqB,IAAIuB,GAAQX,EAAYW,CAAgC,IAAM,IAAM,CAAE,MAAM,IAAI,MAAM,iCAAiC,CAAG,EAAE,EAClJ,MAAO,CAACV,EAAgBC,EAAgBU,IAAkB,CACtD,IAAIC,EAAe,EAEnBA,GAAgBb,EAAYf,CAAI,EAAEgB,EAAMC,EAASW,EAAcD,CAAK,EACpE,QAASE,EAAI,EAAGA,EAAIP,EAAM,OAAQO,IAC9BD,GAAgBL,EAAQM,CAAC,EAAEb,EAAMC,EAASW,EAAcP,EAAUC,EAAMO,CAAC,CAAC,EAAEF,CAAK,CAAC,EAEtF,OAAOC,CACX,CACJ,EAOaE,EAA+BT,GAA4B,CACpE,IAAMC,EAAQ,OAAO,KAAKD,CAAS,EAQ7BU,EAPQT,EAAM,IAAIE,GAAQ,CAC5B,IAAMC,EAAMJ,EAAUG,CAAI,EAC1B,QAAWnB,IAAU,CAACT,EAAKC,EAAKC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,CAAI,EAC9D,GAAIE,KAAUoB,EAAK,OAAOpB,EAE9B,OAAOF,CACX,CAAC,EACqB,IAAIuB,GAAQP,EAAYO,CAAgC,IAAM,IAAM,CAAE,MAAM,IAAI,MAAM,iCAAiC,CAAG,EAAE,EAClJ,MAAO,CAACV,EAAgBC,EAAgBe,IAA0C,CAC9E,IAAIC,EAAY,EAEV,CAAE,MAAOC,EAAe,KAAMC,CAAU,EAAIhB,EAAYnB,CAAI,EAAEgB,EAAMC,EAASgB,CAAS,EAC5FA,GAAaE,EAEb,IAAMR,EAAQK,EAAkBA,EAAgB,IAAIE,CAAa,GAAKA,EAAgBA,EAEtF,QAASL,EAAI,EAAGA,EAAIP,EAAM,OAAQO,IAAK,CACnC,GAAM,CAAE,MAAAX,EAAO,KAAAkB,CAAK,EAAIL,EAAQF,CAAC,EAAEb,EAAMC,EAASgB,CAAS,EAC3DZ,EAAUC,EAAMO,CAAC,CAAC,EAAEF,CAAK,EAAIT,EAC7Be,GAAaG,CACjB,CACA,OAAOH,CACX,CACJ,EAQaI,EAAsB,CAACC,EAA4BC,EAAsB,IAAI,YAAY,KAAO,KAAO,GAAG,IAAM,CACzH,IAAMvB,EAAO,IAAI,SAASuB,CAAM,EAC1BC,EAAuBF,EAAW,IAAIlB,CAAyB,EACrE,OAAQqB,GAAmC,CACvC,IAAIxB,EAAS,EACb,QAASY,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACrC,IAAMF,EAAQc,EAAQZ,CAAC,EACvB,QAASa,EAAI,EAAGA,EAAIF,EAAqB,OAAQE,IAC7CzB,GAAUuB,EAAqBE,CAAC,EAAE1B,EAAMC,EAAQU,CAAK,CAE7D,CACA,OAAOY,EAAO,MAAM,EAAGtB,CAAM,CACjC,CACJ,EAOa0B,EAAyBL,GAA+B,CACjE,IAAMM,EAAyBN,EAAW,IAAIR,CAA2B,EACzE,MAAO,CAACe,EAAqBb,IAAgD,CACzE,IAAMhB,EAAO,IAAI,SAAS6B,CAAM,EAC5B5B,EAAS,EACb,KAAOA,EAAS4B,EAAO,YACnB,QAAShB,EAAI,EAAGA,EAAIe,EAAuB,OAAQf,IAC/CZ,GAAU2B,EAAuBf,CAAC,EAAEb,EAAMC,EAAQe,CAAe,CAG7E,CACJ,ECzKA,OACI,gBAAAc,EACA,gBAAAC,EAEA,kBAAAC,EACA,aAAAC,EACA,cAAAC,EACA,sBAAAC,MAIG,SASA,IAAMC,EAA2B,CAACC,EAAcC,EAA+DC,EAAsB,IAAI,YAAY,KAAO,KAAO,GAAG,IAAM,CAC/K,IAAMC,EAAW,IAAI,SAASD,CAAM,EAChCE,EAAS,EAMPC,EAAyCC,GAAuB,CAClE,IAAMC,EAAcD,EAAS,OAG7BH,EAAS,UAAUC,EAAQG,CAAW,EACtCH,GAAU,EAGV,QAASI,EAAI,EAAGA,EAAID,EAAaC,IAAK,CAClC,IAAMC,EAAWH,EAASE,CAAC,EACvBE,EAAiB,EAErBP,EAAS,UAAUC,EAAQK,CAAQ,EACnCL,GAAU,EAEV,IAAMO,EAAuBP,EAC7BA,GAAU,EAEV,QAASQ,EAAI,EAAGA,EAAIX,EAAW,OAAQW,IAAK,CACxC,IAAMC,EAAYZ,EAAWW,CAAC,EAC9B,GAAIf,EAAWgB,CAAS,EAAG,CACvB,IAAMC,EAAUhB,EAAmBE,EAAOS,EAAUI,CAA0B,EAC9E,QAAWE,KAAUD,EACjBX,EAAS,SAASC,EAAQQ,CAAC,EAC3BR,GAAU,EACVD,EAAS,UAAUC,EAAQW,CAAM,EACjCX,GAAU,EACVM,GAER,MAAWhB,EAAaM,EAAOS,EAAUI,CAAS,IAC9CV,EAAS,SAASC,EAAQQ,CAAC,EAC3BR,GAAU,EACVM,IAER,CAEAP,EAAS,SAASQ,EAAsBD,CAAc,CAC1D,CACJ,EAMMM,EAA0BV,GAAuB,CAEnD,IAAMW,EADgBC,EAAoBjB,EAAYC,EAAO,MAAME,CAAM,CAAC,EACtCE,CAAQ,EAC5C,IAAI,WAAWJ,CAAM,EAAE,IAAI,IAAI,WAAWe,CAAa,EAAGb,CAAM,EAChEA,GAAUa,EAAc,UAC5B,EAEA,MAAO,IAAM,CACTb,EAAS,EACT,IAAME,EAAWX,EAAeK,CAAK,EACrC,OAAAK,EAAsCC,CAAQ,EAC9CU,EAAuBV,CAAQ,EACxBJ,EAAO,MAAM,EAAGE,CAAM,CACjC,CACJ,EAQae,GAA6B,CAACnB,EAAcC,IAAkE,CACvH,IAAMmB,EAAkBC,EAAsBpB,CAAU,EAExD,OAAQqB,GAA6C,CACjD,IAAMnB,EAAW,IAAI,SAASmB,CAAM,EAChClB,EAAS,EACPmB,EAAc,IAAI,IAGlBhB,EAAcJ,EAAS,UAAUC,CAAM,EAC7CA,GAAU,EAGV,QAASoB,EAAc,EAAGA,EAAcjB,EAAaiB,IAAe,CAChE,IAAMC,EAAiBtB,EAAS,UAAUC,CAAM,EAChDA,GAAU,EAEV,IAAMsB,EAAgB9B,EAAUI,CAAK,EACrCuB,EAAY,IAAIE,EAAgBC,CAAa,EAE7C,IAAMhB,EAAiBP,EAAS,SAASC,CAAM,EAC/CA,GAAU,EAEV,QAASI,EAAI,EAAGA,EAAIE,EAAgBF,IAAK,CACrC,IAAMmB,EAAiBxB,EAAS,SAASC,CAAM,EAC/CA,GAAU,EACV,IAAMS,EAAYZ,EAAW0B,CAAc,EAE3C,GAAI9B,EAAWgB,CAAS,EAAG,CACvB,IAAMe,EAAWzB,EAAS,UAAUC,CAAM,EAI1C,GAHAA,GAAU,EAGN,CAACmB,EAAY,IAAIK,CAAQ,EAAG,CAC5B,IAAMC,EAAgBjC,EAAUI,CAAK,EACrCuB,EAAY,IAAIK,EAAUC,CAAa,CAC3C,CACA,IAAMA,EAAgBN,EAAY,IAAIK,CAAQ,EAC9CnC,EAAaO,EAAO0B,EAAgBb,EAAmCgB,CAAa,CAAC,CACzF,MACIpC,EAAaO,EAAO0B,EAAeb,CAAS,CAEpD,CACJ,CAGA,OAAAO,EAAgBE,EAAO,MAAMlB,CAAM,EAAGmB,CAAW,EAE1CA,CACX,CACJ,ECjJA,OACI,gBAAAO,EACA,mBAAAC,EACA,aAAAC,GACA,gBAAAC,GACA,WAAAC,EACA,SAAAC,EACA,YAAAC,EAGA,gBAAAC,GACA,cAAAC,GACA,sBAAAC,GACA,YAAAC,MAEK,SAmBF,IAAMC,GAA2B,CAACC,EAAcC,EAA4BC,EAA4BC,EAAS,IAAI,YAAY,KAAO,KAAO,GAAG,IAAM,CAC3J,IAAMC,EAAW,IAAI,SAASD,CAAM,EAChCE,EAAS,EACPC,EAAoD,CAAC,EACrDC,EAAkB,IAAI,IAG5B,OAAAC,EAAQR,EAAOS,EAAMR,CAAY,EAAIS,GAAkB,CACnDJ,EAAM,KAAK,CAACI,EAAK,EAAyB,EAAE,CAAC,CACjD,CAAC,EAEDF,EAAQR,EAAOW,EAASV,CAAY,EAAIS,GAAkB,CACtDJ,EAAM,KAAK,CAACI,EAAK,EAA4B,EAAE,CAAC,EAChDH,EAAgB,OAAOG,CAAG,CAC9B,CAAC,EAEDR,EAAW,QAAQ,CAACU,EAAWC,IAAM,CAC7BC,GAAWF,CAAS,GACpBJ,EAAQR,EAAOS,EAAMR,EAAcW,EAAUG,CAAQ,CAAC,EAAIL,GAAkB,CACxE,IAAMM,EAAUC,GAAmBjB,EAAOU,EAAKE,CAAS,EACxD,QAAWM,KAAUF,EAEZT,EAAgB,IAAIG,CAAG,GACxBH,EAAgB,IAAIG,EAAK,IAAI,GAAK,EAEtCH,EAAgB,IAAIG,CAAG,EAAE,IAAIG,EAAGK,CAAM,EACtCZ,EAAM,KAAK,CAACI,EAAK,EAA2BG,EAAGK,CAAM,CAAC,CAE9D,CAAC,EAEDV,EAAQR,EAAOW,EAASV,EAAcW,EAAUG,CAAQ,CAAC,EAAIL,GAAkB,CAE3E,IAAMS,EAAYZ,EAAgB,IAAIG,CAAG,EACzC,GAAIS,EAAW,CACX,IAAMD,EAASC,EAAU,IAAIN,CAAC,EAC1BK,IAAW,SACXZ,EAAM,KAAK,CAACI,EAAK,EAA8BG,EAAGK,CAAM,CAAC,EACzDC,EAAU,OAAON,CAAC,EACdM,EAAU,OAAS,GACnBZ,EAAgB,OAAOG,CAAG,EAGtC,CACJ,CAAC,IAEDF,EAAQR,EAAOS,EAAMR,EAAcW,CAAS,EAAIF,GAAkB,CAC9DJ,EAAM,KAAK,CAACI,EAAK,EAA4BG,CAAC,CAAC,CACnD,CAAC,EAEDL,EAAQR,EAAOW,EAASV,EAAcW,CAAS,EAAIF,GAAkB,CACjEJ,EAAM,KAAK,CAACI,EAAK,EAA+BG,CAAC,CAAC,CACtD,CAAC,EAET,CAAC,EACM,IAAM,CACTR,EAAS,EAET,QAASQ,EAAI,EAAGA,EAAIP,EAAM,OAAQO,IAAK,CACnC,GAAM,CAACO,EAAUC,EAAMC,EAAaC,CAAQ,EAAIjB,EAAMO,CAAC,EACvDT,EAAS,UAAUC,EAAQe,CAAQ,EACnCf,GAAU,EACVD,EAAS,SAASC,EAAQgB,CAAI,EAC9BhB,GAAU,GACNgB,IAAS,GACTA,IAAS,GACTA,IAAS,GACTA,IAAS,KACTjB,EAAS,SAASC,EAAQiB,CAAW,EACrCjB,GAAU,GAGNgB,IAAS,GAA6BA,IAAS,KAC/CjB,EAAS,UAAUC,EAAQkB,CAAQ,EACnClB,GAAU,GAGtB,CACA,OAAAC,EAAM,OAAS,EAERH,EAAO,MAAM,EAAGE,CAAM,CACjC,CACJ,EASamB,GAA6B,CAACxB,EAAcC,EAA4BC,EAA4BuB,EAAuC,IAAI,MAChJC,GAAwB,CAC5B,IAAMtB,EAAW,IAAI,SAASsB,CAAM,EAChCrB,EAAS,EAEb,KAAOA,EAASqB,EAAO,YAAY,CAC/B,IAAMC,EAAiBvB,EAAS,UAAUC,CAAM,EAChDA,GAAU,EACV,IAAMuB,EAAgBxB,EAAS,SAASC,CAAM,EAC9CA,GAAU,EACV,IAAIiB,EAAc,GACdC,EAAW,IACXK,IAAkB,GAClBA,IAAkB,GAClBA,IAAkB,GAClBA,IAAkB,KAClBN,EAAclB,EAAS,SAASC,CAAM,EACtCA,GAAU,GAENuB,IAAkB,GAA6BA,IAAkB,KACjEL,EAAWnB,EAAS,UAAUC,CAAM,EACpCA,GAAU,IAIlB,IAAMO,EAAYV,EAAWoB,CAAW,EAEpCO,EAAgBJ,EAAgB,IAAIE,CAAc,EAEtD,GAAIC,IAAkB,EAClB,GAAIC,IAAkB,OAClBA,EAAgBC,GAAU9B,CAAK,EAC/ByB,EAAgB,IAAIE,EAAgBE,CAAa,EACjDE,EAAa/B,EAAO6B,EAAe5B,CAAY,MAE/C,OAAM,IAAI,MAAM,kBAAkB0B,CAAc,iCAAiC,UAE9EE,IAAkB,QAAaG,GAAahC,EAAO6B,CAAa,GACvE,GAAID,IAAkB,EAClBK,GAAajC,EAAO6B,CAAa,UAC1BD,IAAkB,EACzBG,EAAa/B,EAAO6B,EAAejB,CAAS,UACrCgB,IAAkB,EACzBM,EAAgBlC,EAAO6B,EAAejB,CAAS,UACxCgB,IAAkB,EAA2B,CACpD,IAAMO,EAAgBV,EAAgB,IAAIF,CAAQ,EAC9CY,IAAkB,QAClBJ,EAAa/B,EAAO6B,EAAejB,EAAUuB,CAAa,CAAC,CAEnE,SAAWP,IAAkB,EAA8B,CACvD,IAAMO,EAAgBV,EAAgB,IAAIF,CAAQ,EAC9CY,IAAkB,QAClBD,EAAgBlC,EAAO6B,EAAejB,EAAUuB,CAAa,CAAC,CAEtE,EAER,CAEA,OAAOV,CACX",
  "names": ["$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "typeTagForSerialization", "symbol", "a", "u8", "i8", "u16", "i16", "u32", "i32", "f32", "f64", "typeSetters", "view", "offset", "value", "typeGetters", "createComponentSerializer", "component", "props", "setters", "prop", "arr", "type", "index", "bytesWritten", "i", "createComponentDeserializer", "getters", "entityIdMapping", "bytesRead", "originalIndex", "indexSize", "size", "createSoASerializer", "components", "buffer", "componentSerializers", "indices", "j", "createSoADeserializer", "componentDeserializers", "packet", "addComponent", "hasComponent", "getAllEntities", "addEntity", "isRelation", "getRelationTargets", "createSnapshotSerializer", "world", "components", "buffer", "dataView", "offset", "serializeEntityComponentRelationships", "entities", "entityCount", "i", "entityId", "componentCount", "componentCountOffset", "j", "component", "targets", "target", "serializeComponentData", "componentData", "createSoASerializer", "createSnapshotDeserializer", "soaDeserializer", "createSoADeserializer", "packet", "entityIdMap", "entityIndex", "packetEntityId", "worldEntityId", "componentIndex", "targetId", "worldTargetId", "addComponent", "removeComponent", "addEntity", "removeEntity", "observe", "onAdd", "onRemove", "entityExists", "isRelation", "getRelationTargets", "Wildcard", "createObserverSerializer", "world", "networkedTag", "components", "buffer", "dataView", "offset", "queue", "relationTargets", "observe", "onAdd", "eid", "onRemove", "component", "i", "isRelation", "Wildcard", "targets", "getRelationTargets", "target", "targetMap", "entityId", "type", "componentId", "targetId", "createObserverDeserializer", "entityIdMapping", "packet", "packetEntityId", "operationType", "worldEntityId", "addEntity", "addComponent", "entityExists", "removeEntity", "removeComponent", "worldTargetId"]
}
