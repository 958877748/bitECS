{
  "version": 3,
  "sources": ["../../src/serialization/SoASerializer.ts", "../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/SparseSet.ts", "../../src/core/utils/Observer.ts", "../../src/core/Query.ts", "../../src/core/Relation.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/serialization/SnapshotSerializer.ts", "../../src/serialization/ObserverSerializer.ts"],
  "sourcesContent": ["import { ComponentRef } from \"../core\"\n\n/**\n * Symbols representing different data types for serialization.\n */\nconst $u8 = Symbol('u8'), $i8 = Symbol('i8'), $u16 = Symbol('u16'), $i16 = Symbol('i16'),\n    $u32 = Symbol('u32'), $i32 = Symbol('i32'), $f32 = Symbol('f32'), $f64 = Symbol('f64')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = (number[] & { [key: symbol]: true }) | TypedArray\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: number[] = []): PrimitiveBrand => \n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64)\n\n/**\n * Object containing setter functions for each data type.\n */\nconst typeSetters = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; }\n}\n\n/**\n * Object containing getter functions for each data type.\n */\nconst typeGetters = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 })\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number) => {\n        let bytesWritten = 0\n        // Write index first\n        bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index)\n        for (let i = 0; i < props.length; i++) {\n            bytesWritten += setters[i](view, offset + bytesWritten, component[props[i]][index])\n        }\n        return bytesWritten\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        for (let i = 0; i < props.length; i++) {\n            const { value, size } = getters[i](view, offset + bytesRead)\n            component[props[i]][index] = value\n            bytesRead += size\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {ArrayBuffer} [buffer] - The buffer to use for serialization.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: ComponentRef[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const view = new DataView(buffer)\n    const componentSerializers = components.map(createComponentSerializer)\n    return (indices: number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index)\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: ComponentRef[]) => {\n    const componentDeserializers = components.map(createComponentDeserializer)\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            for (let i = 0; i < componentDeserializers.length; i++) {\n                offset += componentDeserializers[i](view, offset, entityIdMapping)\n            }\n        }\n    }\n}\n", "export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n}\n\n/**\n * Creates and initializes a new EntityIndex.\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (): EntityIndex => ({\n    aliveCount: 0,\n    dense: [],\n    sparse: [],\n    maxId: 0,\n})\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount]\n        index.sparse[recycledId] = index.aliveCount\n        index.aliveCount++\n        return recycledId\n    }\n\n    // Create new id\n    const id = ++index.maxId\n    index.dense.push(id)\n    index.sparse[id] = index.aliveCount\n    index.aliveCount++\n\n    return id\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const record = index.sparse[id]\n    if (record === undefined || record >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return\n    }\n\n    const denseIndex = record\n    const lastIndex = index.aliveCount - 1\n    const lastId = index.dense[lastIndex]\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex\n    index.dense[denseIndex] = lastId\n\n    // Update the removed entity's record\n    index.sparse[id] = index.dense.length\n    index.dense[lastIndex] = id\n\n    index.aliveCount--\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const record = index.sparse[id]\n    return record !== undefined && index.dense[record] === id\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query } from './Query'\n\nexport const $internal = Symbol('internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<number, Set<ComponentRef>>\n    bitflag: number\n    componentMap: WeakMap<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\n// type WorldMiddleware<T extends object, U extends object> = (world: World<T>) => World<U>;\n\nconst createBaseWorld = <T extends object>(context?: T): World<T> => {\n    const worldContext: WorldContext = {\n        entityIndex: createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new WeakMap(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n    }\n\n    const world = context || {}\n    defineHiddenProperty(world, $internal, worldContext)\n    return world as World<T>\n}\n\n/**\n * Higher-order function that returns a function to set a custom entity index for a world.\n * @param {EntityIndex} entityIndex - The custom entity index to be set.\n * @returns {function} A function that takes a world and returns the modified world.\n */\nexport const withEntityIndex = (entityIndex: EntityIndex) =>\n    <T extends object>(world: World<T>): World<T> => {\n        const ctx = world[$internal]\n        ctx.entityIndex = entityIndex\n        return world\n    }\n\n/**\n * Higher-order function that returns a function to merge a context object with a world.\n * @param {U} context - The context object to be merged with the world.\n * @returns {function} A function that takes a world and returns the modified world with the merged context.\n */\nexport const withContext = <T extends object>(context: T) => (world: World<T>): World<T> => {\n    const internalData = world[$internal];\n    Object.assign(context, world);\n    defineHiddenProperty(context, $internal, internalData);\n    return context as World<T>;\n}\n\n    /**\n * Creates a new world with modifiers.\n * @template T\n * @param {...Array<function(World<T>): World<T>>} modifiers - Modifier functions for the world.\n * @returns {World<T>} The created world.\n */\nexport function createWorld<T extends object>(...modifiers: Array<(world: World<T>) => World<T>>): World<T>\n\n/**\n * Creates a new world with options.\n * @template T\n * @param {Object} options - Options for creating the world.\n * @param {T} [options.context] - Optional context object to be merged with the world.\n * @param {EntityIndex} [options.entityIndex] - Optional custom entity index for the world.\n * @returns {World<T>} The created world.\n */\nexport function createWorld<T extends object>(options: {\n    context?: T\n    entityIndex?: EntityIndex\n}): World<T>\n\nexport function createWorld<T extends object>(\n    ...args: Array<(world: World<T>) => World<T>> | [{\n        context?: T\n        entityIndex?: EntityIndex\n    }]\n): World<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { context, entityIndex } = args[0]\n        const modifiers = [\n            context && withContext(context),\n            entityIndex && withEntityIndex(entityIndex)\n        ].filter(Boolean) as Array<(world: World<T>) => World<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseWorld<T>())\n    } else {\n        const modifiers = args as Array<(world: World<T>) => World<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseWorld<T>())\n    }\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World) => (world as InternalWorld)[$internal].entityIndex.dense.slice(0)\n", "export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n}\n\nexport const createSparseSet = () => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t}\n}\n\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(initialCapacity)\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(dense.length * 2)\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t}\n};", "export type Observer = (entity: number, ...args: any[]) => void\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: number, ...args: any[])  => void\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n\n  const notify = (entity: number, ...args: any[]) => {\n    observers.forEach((listener) => listener(entity, ...args))\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { Prefab } from './Entity'\n\n/**\n * @typedef {Uint32Array | readonly number[]} QueryResult\n * @description The result of a query, either as a Uint32Array or a readonly array of numbers.\n */\nexport type QueryResult = Uint32Array | readonly number[]\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS.\n * @property {ComponentRef[]} allComponents - All components in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Object.<number, number>} masks - Bitmasks for each component generation.\n * @property {Object.<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Object.<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Object.<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: { [key: number]: number }\n\torMasks: { [key: number]: number }\n\tnotMasks: { [key: number]: number }\n\thasMasks: { [key: number]: number }\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n/**\n * Symbols for query operator types and components\n */\nexport const $opType = Symbol('opType');\nexport const $opComponents = Symbol('opComponents');\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opComponents] - The components involved in the operation.\n */\nexport type OpReturnType = {\n    [$opType]: string\n    [$opComponents]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator} QueryTerm\n * @description A term in a query, either a component reference or a query operator.\n */\nexport type QueryTerm = ComponentRef | QueryOperator\n\n// Aliases\nexport type OrOp = QueryOperator\nexport type AndOp = QueryOperator\nexport type NotOp = QueryOperator\nexport type AnyOp = OrOp\nexport type AllOp = AndOp\nexport type NoneOp = NotOp\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...ComponentRef} components - The components to observe.\n * @returns {{type: 'add' | 'remove' | 'set', components: ComponentRef[]}} The observable hook configuration.\n */\nexport type ObservableHook = (...components: ComponentRef[]) => {\n\t[$opType]: 'add' | 'remove' | 'set'\n\t[$opComponents]: ComponentRef[]\n}\n\n/**\n * @function onAdd\n * @description Creates an 'add' observable hook.\n * @param {...ComponentRef} components - The components to observe for addition.\n * @returns {OpReturnType} The 'add' observable hook configuration.\n */\nexport const onAdd: ObservableHook = (...components: ComponentRef[]) => ({\n    [$opType]: 'add',\n    [$opComponents]: components\n})\n\n/**\n * @function onRemove\n * @description Creates a 'remove' observable hook.\n * @param {...ComponentRef} components - The components to observe for removal.\n * @returns {OpReturnType} The 'remove' observable hook configuration.\n */\nexport const onRemove: ObservableHook = (...components: ComponentRef[]) => ({\n    [$opType]: 'remove',\n    [$opComponents]: components\n})\n\n/**\n * @function onSet\n * @description Creates a 'set' observable hook.\n * @param {...ComponentRef} components - The components to observe for setting.\n * @returns {OpReturnType} The 'set' observable hook configuration.\n */\nexport const onSet: ObservableHook = (...components: ComponentRef[]) => ({\n    [$opType]: 'set',\n    [$opComponents]: components\n})\n\n/**\n * @function set\n * @description Sets a component for an entity.\n * @template T\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to set.\n * @param {T} params - The parameters for the component.\n * @returns {ComponentRef} The set component.\n * @throws {Error} If the entity does not have the component.\n */\nexport const set = <T>(world: World, eid: number, component: ComponentRef, params: T): void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tlet componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\tregisterComponent(world, component)\n\t\tcomponentData = ctx.componentMap.get(component)\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\tthrow new Error(`Entity ${eid} does not have component ${component.name}`)\n\t}\n\n\tcomponentData.setObservable.notify(eid, params)\n\n\treturn component\n}\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ReturnType<typeof onAdd | typeof onRemove | typeof onSet>} hook - The observable hook.\n * @param {function(number): void} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport const observe = (world: World, hook: ReturnType<typeof onAdd | typeof onRemove | typeof onSet>, callback: (eid: number) => void): () => void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opComponents]: components } = hook\n\tconst hash = queryHash(world, components)\n\tlet queryData = ctx.queriesHashMap.get(hash)!\n\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, components)\n\t}\n\n\tconst observableKey = type === 'add' ? 'addObservable' : type === 'remove' ? 'removeObservable' : 'setObservable'\n\n\tconst unsubscribe = queryData[observableKey].subscribe(callback)\n\n\treturn unsubscribe\n}\n\n/**\n * @function Or\n * @description Creates an 'Or' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Or' operator to.\n * @returns {OpReturnType} The 'Or' operator configuration.\n */\nexport const Or: OrOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Or',\n\t[$opComponents]: components\n})\n\n/**\n * @function And\n * @description Creates an 'And' query operator.\n * @param {...ComponentRef} components - The components to apply the 'And' operator to.\n * @returns {OpReturnType} The 'And' operator configuration.\n */\nexport const And: AndOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'And',\n\t[$opComponents]: components\n})\n\n/**\n * @function Not\n * @description Creates a 'Not' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Not' operator to.\n * @returns {OpReturnType} The 'Not' operator configuration.\n */\nexport const Not: NotOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Not',\n\t[$opComponents]: components\n})\n\nexport const Any: AnyOp = Or\nexport const All: AllOp = And\nexport const None: NoneOp = Not\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n    const ctx = (world as InternalWorld)[$internal]\n\n    const getComponentId = (component: ComponentRef): number => {\n        if (!ctx.componentMap.has(component)) {\n            registerComponent(world, component)\n        }\n        return ctx.componentMap.get(component)!.id\n    }\n    const termToString = (term: QueryTerm): string => {\n        if ($opType in term) {\n            const componentIds = term[$opComponents].map(getComponentId)\n            const sortedComponentIds = componentIds.sort((a, b) => a - b)\n            const sortedType = term[$opType].toLowerCase()\n            return `${sortedType}(${sortedComponentIds.join(',')})`\n        } else {\n            return getComponentId(term).toString()\n        }\n    }\n\n    return terms\n        .map(termToString)\n        .sort()\n        .join('-')\n}\n\n/**\n * @function registerQuery\n * @description Registers a new query in the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\t// if (ctx.queriesHashMap.has(hash)) {\n\t// \treturn ctx.queriesHashMap.get(hash)!\n\t// }\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst processComponents = (comps: ComponentRef[], targetArray: ComponentRef[]) => {\n\t\tcomps.forEach((comp: ComponentRef) => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\ttargetArray.push(comp)\n\t\t})\n\t}\n\n\tterms.forEach((term: QueryTerm) => {\n\t\tif ($opType in term) {\n\t\t\tif (term[$opType] === 'Not') {\n\t\t\t\tprocessComponents(term[$opComponents], notComponents)\n\t\t\t} else if (term[$opType] === 'Or') {\n\t\t\t\tprocessComponents(term[$opComponents], orComponents)\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst mapComponents = (c: ComponentRef) => ctx.componentMap.get(c)!\n\tconst allComponents = components.concat(notComponents).concat(orComponents.flat()).map(mapComponents)\n\n\tconst sparseSet = options.buffered ? createUint32SparseSet() : createSparseSet()\n\n\tconst toRemove = createSparseSet()\n\n\tconst generations = allComponents\n\t\t.map((c) => c.generationId)\n\t\t.reduce((a, v) => {\n\t\t\tif (a.includes(v)) return a\n\t\t\ta.push(v)\n\t\t\treturn a\n\t\t}, [] as number[])\n\n\tconst reduceBitflags = (a: { [key:number]: number }, c: ComponentData) => {\n\t\tif (!a[c.generationId]) a[c.generationId] = 0\n\t\ta[c.generationId] |= c.bitflag\n\t\treturn a\n\t}\n\n\tconst masks = components.map(mapComponents).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponents.reduce(reduceBitflags, {})\n\n\tconst addObservable = createObservable()\n\tconst removeObservable = createObservable()\n\n\tconst query = Object.assign(sparseSet, {\n\t\tcomponents,\n\t\tnotComponents,\n\t\torComponents,\n\t\tallComponents,\n\t\tmasks,\n\t\tnotMasks,\n\t\torMasks,\n\t\thasMasks,\n\t\tgenerations,\n\t\ttoRemove,\n\t\taddObservable,\n\t\tremoveObservable,\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponents.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, Prefab, eid)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n/**\n * @function innerQuery\n * @description Performs an internal query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function innerQuery(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\treturn queryData.dense\n}\n\n/**\n * @function query\n * @description Performs a query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {readonly number[]} The result of the query as a readonly array of entity IDs.\n */\nexport function query(world: World, terms: QueryTerm[]): readonly number[] {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms) as number[]\n}\n\n/**\n * @function bufferQuery\n * @description Performs a buffered query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {Uint32Array} The result of the query as a Uint32Array.\n */\nexport function bufferQuery(world: World, terms: QueryTerm[]): Uint32Array {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms, { buffered: true }) as Uint32Array\n}\n\n/**\n * @function queryCheckEntity\n * @description Checks if an entity matches a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: number): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) === 0) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: number) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { getEntityComponents, World } from '.'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number | string} target - The target entity ID or string.\n */\nexport type OnTargetRemovedCallback = (subject: number, target: number | string) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol('relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol('pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol('isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol('relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: () => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: () => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n\n    return ((target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n\n        if (!ctx.pairsMap.has(normalizedTarget)) {\n            const component = createStore()\n            defineHiddenProperty(component, $relationData, {\n                pairTarget: normalizedTarget,\n                ...ctx\n            })\n            ctx.pairsMap.set(normalizedTarget, component)\n        }\n\n        return ctx.pairsMap.get(normalizedTarget)!\n    }) as Relation<T>\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard: Relation<any> = createRelation()\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA: Relation<any> = createRelation()\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, relation: Relation<any>, eid: number) => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n", "/**\n * @module Component\n */\n\nimport { entityExists, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport { \n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World } from './World'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable()\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to check for.\n * @param {number} eid - The entity ID.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, component: ComponentRef, eid: number): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * Recursively inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n */\nconst recursivelyInherit = (world: World, baseEid: number, inheritedEid: number) => {\n\taddComponent(world, IsA(inheritedEid), baseEid)\n\tconst components = getEntityComponents(world, inheritedEid)\n\tfor (const component of components) {\n\t\tif (component === Prefab) {\n\t\t\tcontinue\n\t\t}\n\t\taddComponent(world, component, baseEid)\n\t\t// TODO: onSet observable\n\t\tconst keys = Object.keys(component)\n\t\tfor (const key of keys) {\n\t\t\tcomponent[key][baseEid] = component[key][inheritedEid]\n\t\t}\n\t}\n\n\tconst inheritedTargets = getRelationTargets(world, IsA, inheritedEid)\n\tfor (const inheritedEid2 of inheritedTargets) {\n\t\trecursivelyInherit(world, baseEid, inheritedEid2)\n\t}\n}\n\n/**\n * Adds a component to an entity.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to add.\n * @param {number} eid - The entity ID.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, component: ComponentRef, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\t}\n\n\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\tif (hasComponent(world, component, eid)) return\n\n\tconst componentNode = ctx.componentMap.get(component)!\n\tconst { generationId, bitflag, queries } = componentNode\n\n\tctx.entityMasks[generationId][eid] |= bitflag\n\n\tif (!hasComponent(world, Prefab, eid)) {\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\t}\n\n\tctx.entityComponents.get(eid)!.add(component)\n\n\tif (component[$isPairComponent]) {\n\t\tconst relation = component[$relation]\n\t\taddComponent(world, Pair(relation, Wildcard), eid)\n\t\tconst target = component[$pairTarget]\n\t\taddComponent(world, Pair(Wildcard, target), eid)\n\n\t\tconst relationData = relation[$relationData]\n\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\tconst oldTarget = getRelationTargets(world, relation, eid)[0]\n\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\tremoveComponent(world, relation(oldTarget), eid)\n\t\t\t}\n\t\t}\n\n\t\tif (relation === IsA) {\n\t\t\tconst inheritedTargets = getRelationTargets(world, IsA, eid)\n\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\trecursivelyInherit(world, eid, inherited)\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Adds multiple components to an entity.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to add.\n * @param {number} eid - The entity ID.\n */\nexport const addComponents = (world: World, components: ComponentRef[], eid: number) => {\n\tcomponents.forEach((component) => addComponent(world, component, eid))\n}\n\n/**\n * Removes a component from an entity.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to remove.\n * @param {number} eid - The entity ID.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, component: ComponentRef, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\t}\n\n\tif (!hasComponent(world, component, eid)) return\n\n\tconst componentNode = ctx.componentMap.get(component)!\n\tconst { generationId, bitflag, queries } = componentNode\n\n\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\tqueries.forEach((queryData: Query) => {\n\t\tqueryData.toRemove.remove(eid)\n\n\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\tif (match) queryAddEntity(queryData, eid)\n\t\telse queryRemoveEntity(world, queryData, eid)\n\t})\n\n\tctx.entityComponents.get(eid)!.delete(component)\n\n\tif (component[$isPairComponent]) {\n\t\tconst target = component[$pairTarget]\n\t\tremoveComponent(world, Pair(Wildcard, target), eid)\n\n\t\tconst relation = component[$relation]\n\t\tconst otherTargets = getRelationTargets(world, relation, eid)\n\t\tif (otherTargets.length === 0) {\n\t\t\tremoveComponent(world, Pair(relation, Wildcard), eid)\n\t\t}\n\t}\n}\n\n/**\n * Removes multiple components from an entity.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to remove.\n * @param {number} eid - The entity ID.\n */\nexport const removeComponents = (\n\tworld: World,\n\tcomponents: ComponentRef[],\n\teid: number,\n) => {\n\tcomponents.forEach((component) => removeComponent(world, component, eid))\n}\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tinnerQuery,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport const Prefab = {}\nexport const addPrefab = (world: World) => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, Prefab, eid)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): number => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, Pair(ChildOf, parent), child)\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n        for (const subject of innerQuery(world, [Wildcard(currentEid)])) {\n            if (!entityExists(world, subject)) {\n                continue\n            }\n\n            for (const component of ctx.entityComponents.get(subject)!) {\n                if (!component[$isPairComponent]) {\n                    continue\n                }\n\n                const relation = component[$relation]\n                const relationData = relation[$relationData]\n                componentRemovalQueue.push(() => removeComponent(world, Pair(Wildcard, currentEid), subject))\n\n                if (component[$pairTarget] === currentEid) {\n                    componentRemovalQueue.push(() => removeComponent(world, component, subject))\n                    if (relationData.autoRemoveSubject) {\n                        removalQueue.push(subject)\n                    }\n                    if (relationData.onTargetRemoved) {\n                        componentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n                    }\n                }\n            }\n        }\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: number): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error('bitECS - entity is undefined.')\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: number) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "import { createSoASerializer, createSoADeserializer, PrimitiveBrand } from './SoASerializer'\nimport {\n    addComponent,\n    hasComponent,\n    World,\n    getAllEntities,\n    addEntity,\n} from '../core'\n\n/**\n * Creates a snapshot serializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the world state and returns a slice of the buffer.\n */\nexport const createSnapshotSerializer = (world: World, components: Record<string, PrimitiveBrand>[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n\n    /**\n     * Serializes entity-component relationships.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeEntityComponentRelationships = (entities: number[]) => {\n        const entityCount = entities.length\n        \n        // Write entity count\n        dataView.setUint32(offset, entityCount)\n        offset += 4\n\n        // Serialize entity-component relationships\n        for (let i = 0; i < entityCount; i++) {\n            const entityId = entities[i]\n            let componentCount = 0\n            \n            dataView.setUint32(offset, entityId)\n            offset += 4\n            \n            const componentCountOffset = offset\n            offset += 1\n            \n            for (let j = 0; j < components.length; j++) {\n                if (hasComponent(world, components[j], entityId)) {\n                    dataView.setUint8(offset, j)\n                    offset += 1\n                    componentCount++\n                }\n            }\n            \n            dataView.setUint8(componentCountOffset, componentCount)\n        }\n    }\n\n    /**\n     * Serializes component data for all entities.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeComponentData = (entities: number[]) => {\n        const soaSerializer = createSoASerializer(components, buffer.slice(offset))\n        const componentData = soaSerializer(entities)\n        new Uint8Array(buffer).set(new Uint8Array(componentData), offset)\n        offset += componentData.byteLength\n    }\n\n    return () => {\n        offset = 0\n        const entities = getAllEntities(world)\n        serializeEntityComponentRelationships(entities)\n        serializeComponentData(entities)\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a snapshot deserializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @returns {Function} A function that takes a serialized packet and deserializes it into the world, returning a map of packet entity IDs to world entity IDs.\n */\nexport const createSnapshotDeserializer = (world: World, components: Record<string, PrimitiveBrand>[]) => {\n    const soaDeserializer = createSoADeserializer(components)\n\n    return (packet: ArrayBuffer): Map<number, number> => {\n        const dataView = new DataView(packet)\n        let offset = 0\n        const entityIdMap = new Map<number, number>()\n\n        // Read entity count\n        const entityCount = dataView.getUint32(offset)\n        offset += 4\n\n        // Deserialize entity-component relationships\n        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n\n            const worldEntityId = addEntity(world)\n            entityIdMap.set(packetEntityId, worldEntityId)\n\n            const componentCount = dataView.getUint8(offset)\n            offset += 1\n\n            for (let i = 0; i < componentCount; i++) {\n                const componentIndex = dataView.getUint8(offset)\n                offset += 1\n                addComponent(world, components[componentIndex], worldEntityId)\n            }\n        }\n\n        // Deserialize component data\n        soaDeserializer(packet.slice(offset), entityIdMap)\n\n        return entityIdMap\n    }\n}\n", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n} from '../core'\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components to observe for changes.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the queued changes and returns a slice of the buffer.\n */\nexport const createObserverSerializer = (world: World, networkedTag: any, components: any[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, number, number][] = []\n\n    components.forEach((component, i) => {\n        observe(world, onAdd(networkedTag, component), (eid: number) => {\n            queue.push([eid, 0, i])\n        })\n\n        observe(world, onRemove(networkedTag, component), (eid: number) => {\n            queue.push([eid, 1, i])\n        })\n    })\n\n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            dataView.setUint8(offset, componentId)\n            offset += 1\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components that can be added or removed.\n * @returns {Function} A function that takes a serialized packet and an optional entity ID mapping, and applies the changes to the world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: any, components: any[]) => {\n    return (packet: ArrayBuffer, entityIdMapping: Map<number, number> = new Map()) => {\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            const componentId = dataView.getUint8(offset)\n            offset += 1\n\n            const component = components[componentId]\n\n            let worldEntityId = entityIdMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                entityIdMapping.set(packetEntityId, worldEntityId)\n            }\n\n            if (operationType === 0) {\n                addComponent(world, component, worldEntityId)\n                addComponent(world, networkedTag, worldEntityId)\n            } else if (operationType === 1) {\n                removeComponent(world, component, worldEntityId)\n            }\n        }\n\n        return entityIdMapping\n    }\n}\n"],
  "mappings": "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",
  "names": ["$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "typeTagForSerialization", "symbol", "a", "u8", "i8", "u16", "i16", "u32", "i32", "f32", "f64", "typeSetters", "view", "offset", "value", "typeGetters", "createComponentSerializer", "component", "props", "setters", "prop", "arr", "type", "index", "bytesWritten", "createComponentDeserializer", "getters", "entityIdMapping", "bytesRead", "originalIndex", "indexSize", "i", "size", "createSoASerializer", "components", "buffer", "componentSerializers", "indices", "j", "createSoADeserializer", "componentDeserializers", "packet", "defineHiddenProperty", "obj", "key", "value", "addEntityId", "index", "recycledId", "id", "isEntityIdAlive", "index", "id", "record", "$internal", "getAllEntities", "world", "$internal", "createSparseSet", "dense", "sparse", "has", "val", "index", "swapped", "createUint32SparseSet", "initialCapacity", "length", "newDense", "createObservable", "observers", "observer", "entity", "args", "listener", "$opType", "$opComponents", "onAdd", "components", "onRemove", "observe", "world", "hook", "callback", "ctx", "$internal", "$opType", "type", "$opComponents", "components", "hash", "queryHash", "queryData", "registerQuery", "queryHash", "world", "terms", "ctx", "$internal", "getComponentId", "component", "registerComponent", "termToString", "term", "$opType", "sortedComponentIds", "$opComponents", "a", "b", "registerQuery", "options", "hash", "components", "notComponents", "orComponents", "processComponents", "comps", "targetArray", "comp", "mapComponents", "c", "allComponents", "sparseSet", "createUint32SparseSet", "createSparseSet", "toRemove", "generations", "v", "reduceBitflags", "masks", "notMasks", "orMasks", "hasMasks", "addObservable", "createObservable", "removeObservable", "query", "entityIndex", "i", "eid", "hasComponent", "Prefab", "queryCheckEntity", "queryAddEntity", "queryCheckEntity", "world", "query", "eid", "ctx", "$internal", "masks", "notMasks", "orMasks", "generations", "generationId", "qMask", "qNotMask", "qOrMask", "eMask", "queryAddEntity", "query", "eid", "queryRemoveEntity", "world", "query", "eid", "ctx", "$internal", "$relation", "$pairTarget", "$isPairComponent", "$relationData", "createBaseRelation", "data", "relation", "target", "normalizedTarget", "Wildcard", "component", "defineHiddenProperty", "withStore", "createStore", "ctx", "makeExclusive", "withAutoRemoveSubject", "withOnTargetRemoved", "onRemove", "Pair", "relation", "target", "Wildcard", "createRelation", "IsA", "getRelationTargets", "world", "eid", "components", "getEntityComponents", "targets", "c", "$relation", "$pairTarget", "args", "store", "exclusive", "autoRemoveSubject", "onTargetRemoved", "withStore", "makeExclusive", "withAutoRemoveSubject", "withOnTargetRemoved", "acc", "modifier", "createBaseRelation", "registerComponent", "world", "component", "ctx", "$internal", "queries", "data", "createObservable", "hasComponent", "world", "component", "eid", "ctx", "$internal", "registeredComponent", "generationId", "bitflag", "recursivelyInherit", "baseEid", "inheritedEid", "addComponent", "IsA", "components", "getEntityComponents", "Prefab", "keys", "key", "inheritedTargets", "getRelationTargets", "inheritedEid2", "entityExists", "registerComponent", "componentNode", "queries", "queryData", "queryCheckEntity", "queryAddEntity", "queryRemoveEntity", "$isPairComponent", "relation", "$relation", "Pair", "Wildcard", "target", "$pairTarget", "$relationData", "oldTarget", "removeComponent", "inherited", "removeComponent", "world", "component", "eid", "ctx", "$internal", "entityExists", "hasComponent", "componentNode", "generationId", "bitflag", "queries", "queryData", "queryCheckEntity", "queryAddEntity", "queryRemoveEntity", "$isPairComponent", "target", "$pairTarget", "Pair", "Wildcard", "relation", "$relation", "getRelationTargets", "Prefab", "addEntity", "world", "ctx", "$internal", "eid", "addEntityId", "q", "queryCheckEntity", "queryAddEntity", "getEntityComponents", "world", "eid", "ctx", "$internal", "isEntityIdAlive", "entityExists", "createSnapshotSerializer", "world", "components", "buffer", "dataView", "offset", "serializeEntityComponentRelationships", "entities", "entityCount", "i", "entityId", "componentCount", "componentCountOffset", "j", "hasComponent", "serializeComponentData", "componentData", "createSoASerializer", "getAllEntities", "createSnapshotDeserializer", "soaDeserializer", "createSoADeserializer", "packet", "entityIdMap", "entityIndex", "packetEntityId", "worldEntityId", "addEntity", "componentIndex", "addComponent", "createObserverSerializer", "world", "networkedTag", "components", "buffer", "dataView", "offset", "queue", "component", "observe", "onAdd", "eid", "onRemove", "i", "entityId", "type", "componentId", "createObserverDeserializer", "packet", "entityIdMapping", "packetEntityId", "operationType", "worldEntityId", "addEntity", "addComponent", "removeComponent"]
}
