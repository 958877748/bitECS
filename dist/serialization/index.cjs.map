{
  "version": 3,
  "sources": ["../../src/serialization/index.ts", "../../src/serialization/SoASerializer.ts", "../../src/serialization/AoSSerializer.ts", "../../src/serialization/SnapshotSerializer.ts", "../../src/serialization/ObserverSerializer.ts"],
  "sourcesContent": ["\nexport {\n    createSoASerializer,\n    createSoADeserializer,\n    u8, i8, u16, i16, u32, i32, f32, f64, str, array,\n    $i8, $u16, $i16, $u32, $i32, $f32, $f64, $u8, $str,\n    type PrimitiveBrand\n} from './SoASerializer'\n\nexport {\n    createAoSSerializer,\n    createAoSDeserializer,\n    type AoSComponentRef,\n    type AoSSerializerOptions,\n    type AoSDeserializerOptions\n} from './AoSSerializer'\n\nexport {\n    createSnapshotSerializer,\n    createSnapshotDeserializer,\n} from './SnapshotSerializer'\n\nexport {\n    createObserverSerializer,\n    createObserverDeserializer\n} from './ObserverSerializer';", "\n/**\n * Symbols representing different data types for serialization.\n */\nexport const $u8 = Symbol.for('bitecs-u8'), $i8 = Symbol.for('bitecs-i8'), $u16 = Symbol.for('bitecs-u16'), $i16 = Symbol.for('bitecs-i16'),\n    $u32 = Symbol.for('bitecs-u32'), $i32 = Symbol.for('bitecs-i32'), $f32 = Symbol.for('bitecs-f32'), $f64 = Symbol.for('bitecs-f64'),\n    $str = Symbol.for('bitecs-str'),\n    $arr = Symbol.for('bitecs-arr')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64 | typeof $str\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = ((number[] | string[]) & { [key: symbol]: true }) | TypedArray\n\n/**\n * Type representing a component reference, which is a record mapping string keys to either\n * a PrimitiveBrand (number array with type symbol), TypedArray, or ArrayType values.\n * Used to define the structure of components that can be serialized.\n */\nexport type ComponentRef = Record<string, PrimitiveBrand | TypedArray | ArrayType<any>>\n\nexport type ArrayType<T> = T[] & { [$arr]: TypeSymbol | TypeFunction | ArrayType<any> }\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: any[] = []): PrimitiveBrand =>\n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64),\n            str = typeTagForSerialization($str)\n\n/**\n * Mapping from type functions to their corresponding symbols.\n */\nconst functionToSymbolMap = new Map([\n    [u8, $u8], [i8, $i8], [u16, $u16], [i16, $i16],\n    [u32, $u32], [i32, $i32], [f32, $f32], [f64, $f64],\n    [str, $str]\n])\n\n/**\n * Type representing a type function.\n */\ntype TypeFunction = typeof u8 | typeof i8 | typeof u16 | typeof i16 | typeof u32 | typeof i32 | typeof f32 | typeof f64 | typeof str\n\n/**\n * Object containing setter functions for each data type.\n */\nexport const typeSetters: Record<TypeSymbol, (view: DataView, offset: number, value: any) => number> = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; },\n    [$str]: (view: DataView, offset: number, value: string) => {\n        const enc = textEncoder\n        const bytes = enc.encode(value)\n        let written = 0\n        written += typeSetters[$u32](view, offset + written, bytes.length)\n        new Uint8Array(view.buffer, view.byteOffset + offset + written, bytes.length).set(bytes)\n        written += bytes.length\n        return written\n    }\n} as Record<TypeSymbol, (view: DataView, offset: number, value: any) => number>\n\n/**\n * Object containing getter functions for each data type.\n */\nexport const typeGetters: Record<TypeSymbol, (view: DataView, offset: number) => { value: any, size: number }> = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 }),\n    [$str]: (view: DataView, offset: number) => {\n        const { value: len, size: lenSize } = typeGetters[$u32](view, offset)\n        const bytes = new Uint8Array(view.buffer, view.byteOffset + offset + lenSize, len)\n        const dec = textDecoder\n        const strValue = dec.decode(bytes)\n        return { value: strValue, size: lenSize + len }\n    }\n} as Record<TypeSymbol, (view: DataView, offset: number) => { value: any, size: number }>\n\n/**\n * Resolves a type (symbol, function, or array type) to its corresponding symbol.\n */\nfunction resolveTypeToSymbol(type: TypeSymbol | TypeFunction | ArrayType<any>): TypeSymbol {\n    if (typeof type === 'symbol') {\n        return type\n    }\n    if (typeof type === 'function') {\n        const symbol = functionToSymbolMap.get(type as TypeFunction) as TypeSymbol | undefined\n        if (symbol) return symbol\n        throw new Error(`Unknown type function: ${type}`)\n    }\n    if (isArrayType(type)) {\n        return resolveTypeToSymbol(type[$arr])\n    }\n    // Default fallback\n    return $f32\n}\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const array = <T extends any[] = any[]>(type: TypeSymbol | TypeFunction | ArrayType<any> = f32): ArrayType<T> => {\n    const arr = [] as any[];\n\n    Object.defineProperty(arr, $arr, { value: type, enumerable: false, writable: false, configurable: false })\n\n    return arr as ArrayType<T>;\n}\n\n/**\n * Checks if a value is a TypedArray, branded array, or ArrayType\n */\nfunction isTypedArrayOrBranded(arr: any): arr is PrimitiveBrand | TypedArray | ArrayType<any> {\n    return arr && (\n        ArrayBuffer.isView(arr) || \n        (Array.isArray(arr) && typeof arr === 'object')\n    )\n}\n\n/**\n * Gets the type symbol for an array\n */\nexport function getTypeForArray(arr: PrimitiveBrand | TypedArray | ArrayType<any>): TypeSymbol {\n    // Check for ArrayType first\n    if (isArrayType(arr)) {\n        return resolveTypeToSymbol(arr[$arr])\n    }\n    // Check for branded arrays\n    for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64, $str] as TypeSymbol[]) {\n        if (symbol in arr) return symbol\n    }\n    // Then check TypedArrays\n    if (arr instanceof Int8Array) return $i8\n    if (arr instanceof Uint8Array) return $u8\n    if (arr instanceof Int16Array) return $i16\n    if (arr instanceof Uint16Array) return $u16\n    if (arr instanceof Int32Array) return $i32\n    if (arr instanceof Uint32Array) return $u32\n    if (arr instanceof Float32Array) return $f32\n    return $f64\n}\n\n/**\n * Checks if a value is an array type\n */\nexport function isArrayType(value: any): value is ArrayType<any> {\n    return Array.isArray(value) && $arr in value\n}\n\n/**\n * Gets the element type information for an array type\n */\nexport function getArrayElementType(arrayType: ArrayType<any>): TypeSymbol | TypeFunction | ArrayType<any> {\n    return arrayType[$arr]\n}\n\n/**\n * Serializes an array value to a DataView\n */\nexport function serializeArrayValue(\n    elementType: ArrayType<any> | TypeSymbol | TypeFunction,\n    value: any[],\n    view: DataView,\n    offset: number\n): number {\n    let bytesWritten = 0\n\n    const isArrayDefined = Array.isArray(value) ? 1 : 0\n    bytesWritten += typeSetters[$u8](view, offset, isArrayDefined)\n\n    if (!isArrayDefined) {\n        return bytesWritten\n    }\n\n    bytesWritten += typeSetters[$u32](view, offset + bytesWritten, value.length)\n\n    // Write each element\n    for (let i = 0; i < value.length; i++) {\n        const element = value[i]\n        if (isArrayType(elementType)) {\n            bytesWritten += serializeArrayValue(getArrayElementType(elementType), element, view, offset + bytesWritten)\n        } else {\n            // Primitive type - resolve to symbol\n            const symbol = resolveTypeToSymbol(elementType)\n            bytesWritten += typeSetters[symbol](view, offset + bytesWritten, element)\n        }\n    }\n\n    return bytesWritten\n}\n\n\nexport function deserializeArrayValue(\n    elementType: ArrayType<any> | TypeSymbol | TypeFunction,\n    view: DataView,\n    offset: number\n) {\n    let bytesRead = 0\n\n    const isArrayResult = typeGetters[$u8](view, offset + bytesRead)\n    bytesRead += isArrayResult.size\n    if (!isArrayResult.value) {\n        return { size: bytesRead }\n    }\n\n    const arrayLengthResult = typeGetters[$u32](view, offset + bytesRead)\n    bytesRead += arrayLengthResult.size;\n\n    const arr = new Array(arrayLengthResult.value) as any;\n    for (let i = 0; i < arr.length; i++) {\n        if (isArrayType(elementType)) {\n            const { value, size } = deserializeArrayValue(getArrayElementType(elementType), view, offset + bytesRead)\n            bytesRead += size\n            if (Array.isArray(value)) {\n                arr[i] = value\n            }\n        } else {\n            // Primitive type - resolve to symbol\n            const symbol = resolveTypeToSymbol(elementType)\n            const { value, size } = typeGetters[symbol](view, offset + bytesRead)\n            bytesRead += size\n            arr[i] = value\n        }\n    }\n\n    return { value: arr, size: bytesRead }\n}\n\n/**\n * Checks if an array type is a float type\n */\nconst isFloatType = (array: any) => {\n    const arrayType = getTypeForArray(array)\n    return arrayType === $f32 || arrayType === $f64\n}\n\n/**\n * Gets epsilon value for an array type (0 for non-floats)\n */\nconst getEpsilonForType = (array: any, epsilon: number) => \n    isFloatType(array) ? epsilon : 0\n\n/**\n * Gets or creates a shadow array for change detection\n */\nconst getShadow = (shadowMap: Map<any, any>, array: any) => {\n    let shadow = shadowMap.get(array)\n    if (!shadow) {\n        // Create shadow array with proper initialization\n        if (ArrayBuffer.isView(array)) {\n            // TypedArray\n            shadow = new (array.constructor as any)((array as any).length)\n        } else {\n            // Regular array (like f32([]) arrays) - initialize with zeros\n            shadow = new Array(array.length).fill(0)\n        }\n        shadowMap.set(array, shadow)\n    }\n    return shadow\n}\n\n/**\n * Checks if a value has changed and updates the shadow\n */\nconst hasChanged = (shadowMap: Map<any, any>, array: any, index: number, epsilon = 0.0001) => {\n    const shadow = getShadow(shadowMap, array)\n    const currentValue = array[index]\n    const actualEpsilon = getEpsilonForType(array, epsilon)\n    \n    const changed = actualEpsilon > 0\n        ? Math.abs(shadow[index] - currentValue) > actualEpsilon\n        : shadow[index] !== currentValue\n    \n    shadow[index] = currentValue\n    return changed\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @param {boolean} diff - Whether to use diff mode (only serialize changed values).\n * @param {Map} shadowMap - Map to store shadow copies for diff mode.\n * @param {number} epsilon - Epsilon for float comparison in diff mode.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>, diff = false, shadowMap?: Map<any, any>, epsilon = 0.0001) => {\n    // Handle direct array case\n    if (isTypedArrayOrBranded(component)) {\n        const type = getTypeForArray(component)\n        const setter = typeSetters[type]\n        return (view: DataView, offset: number, index: number, componentId: number) => {\n            if (diff && shadowMap) {\n                if (!hasChanged(shadowMap, component, index, epsilon)) return 0 // No change\n                \n                let bytesWritten = 0\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, componentId) // cid\n                bytesWritten += setter(view, offset + bytesWritten, component[index])\n                return bytesWritten\n            } else {\n                let bytesWritten = 0\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n                bytesWritten += setter(view, offset + bytesWritten, component[index])\n                return bytesWritten\n            }\n        }\n    }\n\n    // Handle component case\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        if (!isTypedArrayOrBranded(arr)) {\n            throw new Error(`Invalid array type for property ${prop}`)\n        }\n        return getTypeForArray(arr)\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number, componentId: number) => {\n        if (diff && shadowMap) {\n            let changeMask = 0\n            // First pass: check what changed and build mask\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                \n                if (hasChanged(shadowMap, componentProperty, index, epsilon)) {\n                    changeMask |= 1 << i\n                }\n            }\n            \n            if (changeMask === 0) return 0 // No changes for this component\n            \n            let bytesWritten = 0\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, componentId) // cid\n            \n            // Write mask\n            const maskSetter = props.length <= 8 ? typeSetters[$u8] : props.length <= 16 ? typeSetters[$u16] : typeSetters[$u32]\n            bytesWritten += maskSetter(view, offset + bytesWritten, changeMask)\n            \n            // Write only changed values (shadows already updated by hasChanged)\n            for (let i = 0; i < props.length; i++) {\n                if (changeMask & (1 << i)) {\n                    const componentProperty = component[props[i]]\n                    \n                    if (isArrayType(componentProperty)) {\n                        bytesWritten += serializeArrayValue(getArrayElementType(componentProperty), componentProperty[index], view, offset + bytesWritten)\n                    } else {\n                        bytesWritten += setters[i](view, offset + bytesWritten, componentProperty[index])\n                    }\n                }\n            }\n            return bytesWritten\n        } else {\n            let bytesWritten = 0\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                if (isArrayType(componentProperty)) {\n                    bytesWritten += serializeArrayValue(getArrayElementType(componentProperty), componentProperty[index], view, offset + bytesWritten)\n                } else {\n                    bytesWritten += setters[i](view, offset + bytesWritten, componentProperty[index])\n                }\n            }\n            return bytesWritten\n        }\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @param {boolean} diff - Whether to expect diff mode data with change masks.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>, diff = false) => {\n    // Handle direct array case\n    if (isTypedArrayOrBranded(component)) {\n        const type = getTypeForArray(component)\n        const getter = typeGetters[type]\n        return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n            let bytesRead = 0\n            const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset)\n            bytesRead += indexSize\n            const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n            \n            if (diff) {\n                // Skip cid (component ID)\n                const { size: cidSize } = typeGetters[$u32](view, offset + bytesRead)\n                bytesRead += cidSize\n            }\n            \n            const { value, size } = getter(view, offset + bytesRead)\n            component[index] = value\n            return bytesRead + size\n        }\n    }\n\n    // Handle component case\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        if (!isTypedArrayOrBranded(arr)) {\n            throw new Error(`Invalid array type for property ${prop}`)\n        }\n        return getTypeForArray(arr)\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        if (diff) {\n            // Skip cid (component ID)\n            const { size: cidSize } = typeGetters[$u32](view, offset + bytesRead)\n            bytesRead += cidSize\n            \n            const maskGetter = props.length <= 8 ? typeGetters[$u8] : props.length <= 16 ? typeGetters[$u16] : typeGetters[$u32]\n            const { value: changeMask, size: maskSize } = maskGetter(view, offset + bytesRead)\n            bytesRead += maskSize\n            \n            for (let i = 0; i < props.length; i++) {\n                if (changeMask & (1 << i)) {\n                    const componentProperty = component[props[i]]\n                    if (isArrayType(componentProperty)) {\n                        const { value, size } = deserializeArrayValue(getArrayElementType(componentProperty), view, offset + bytesRead)\n                        if (Array.isArray(value)){\n                            componentProperty[index] = value\n                        }\n                        bytesRead += size\n                    } else {\n                        const { value, size } = getters[i](view, offset + bytesRead)\n                        component[props[i]][index] = value\n                        bytesRead += size\n                    }\n                }\n            }\n        } else {\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                if (isArrayType(componentProperty)) {\n                    const { value, size } = deserializeArrayValue(getArrayElementType(componentProperty), view, offset + bytesRead)\n                    if (Array.isArray(value)){\n                        componentProperty[index] = value\n                    }\n                    bytesRead += size\n                } else {\n                    const { value, size } = getters[i](view, offset + bytesRead)\n                    component[props[i]][index] = value\n                    bytesRead += size\n                }\n            }\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Options for SoA serializer\n */\nexport type SoASerializerOptions = {\n    diff?: boolean\n    buffer?: ArrayBuffer\n    epsilon?: number\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {SoASerializerOptions} [options] - Serializer options.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: (ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>)[], options: SoASerializerOptions = {}) => {\n    const { \n        diff = false, \n        buffer = new ArrayBuffer(1024 * 1024 * 100), \n        epsilon = 0.0001 \n    } = options\n    const view = new DataView(buffer)\n    const shadowMap = diff ? new Map() : undefined\n    const componentSerializers = components.map(component => createComponentSerializer(component, diff, shadowMap, epsilon))\n    return (indices: number[] | readonly number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index, j) // Pass component ID\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Options for SoA deserializer\n */\nexport type SoADeserializerOptions = {\n    diff?: boolean\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @param {SoADeserializerOptions} [options] - Deserializer options.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: (ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>)[], options: SoADeserializerOptions = {}) => {\n    const { diff = false } = options\n    const componentDeserializers = components.map(component => createComponentDeserializer(component, diff))\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            if (diff) {\n                // Read eid, cid\n                const { value: originalEid, size: eidSize } = typeGetters[$u32](view, offset)\n                const { value: componentId, size: cidSize } = typeGetters[$u32](view, offset + eidSize)\n                \n                // Call component deserializer starting from eid position\n                offset += componentDeserializers[componentId](view, offset, entityIdMapping)\n            } else {\n                for (let i = 0; i < componentDeserializers.length; i++) {\n                    offset += componentDeserializers[i](view, offset, entityIdMapping)\n                }\n            }\n        }\n    }\n}\n", "import { \n    $u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64, $arr,\n    TypedArray, TypeSymbol, PrimitiveBrand, ArrayType,\n    typeSetters, typeGetters, getTypeForArray, isArrayType, getArrayElementType,\n    serializeArrayValue, deserializeArrayValue\n} from './SoASerializer'\n\n/**\n * Component reference for AoS serialization - a component array where each element stores object data\n */\nexport type AoSComponentRef =\n    | PrimitiveBrand\n    | TypedArray\n    | ArrayType<any>\n    | Record<string, PrimitiveBrand | TypedArray | ArrayType<any>>\n\n/**\n * Checks if an array type is a float type\n */\nconst isFloatType = (array: any) => {\n    const arrayType = getTypeForArray(array)\n    return arrayType === $f32 || arrayType === $f64\n}\n\n/**\n * Gets epsilon value for an array type (0 for non-floats)\n */\nconst getEpsilonForType = (array: any, epsilon: number) => \n    isFloatType(array) ? epsilon : 0\n\n/**\n * Gets or creates a shadow component array for change detection\n */\nconst getShadowComponent = (shadowMap: Map<any, any>, component: AoSComponentRef) => {\n    let shadow = shadowMap.get(component)\n    if (!shadow) {\n        shadow = []\n        shadowMap.set(component, shadow)\n    }\n    return shadow\n}\n\n/**\n * Checks if a component value has changed for a specific entity\n */\nconst hasComponentChanged = (shadowMap: Map<any, any>, component: AoSComponentRef, entityId: number, epsilon: number) => {\n    const shadow = getShadowComponent(shadowMap, component)\n    const currentValue = component[entityId]\n    const shadowValue = shadow[entityId]\n    \n    if (currentValue === undefined) return false\n    if (shadowValue === undefined) return true\n    \n    if (typeof currentValue === 'object' && currentValue !== null) {\n        // Object component - check each property\n        const componentDef = component as any // Has property definitions\n        for (const prop in currentValue) {\n            if (componentDef[prop]) {\n                const propEpsilon = getEpsilonForType(componentDef[prop], epsilon)\n                const changed = propEpsilon > 0\n                    ? Math.abs(shadowValue[prop] - currentValue[prop]) > propEpsilon\n                    : shadowValue[prop] !== currentValue[prop]\n                if (changed) return true\n            }\n        }\n        return false\n    } else {\n        // Direct value component\n        const valueEpsilon = getEpsilonForType(component, epsilon)\n        return valueEpsilon > 0\n            ? Math.abs(shadowValue - currentValue) > valueEpsilon\n            : shadowValue !== currentValue\n    }\n}\n\n/**\n * Updates shadow with current value\n */\nconst updateShadow = (shadowMap: Map<any, any>, component: AoSComponentRef, entityId: number) => {\n    const shadow = getShadowComponent(shadowMap, component)\n    const currentValue = component[entityId]\n    \n    if (typeof currentValue === 'object' && currentValue !== null) {\n        // Deep copy object\n        shadow[entityId] = { ...currentValue }\n    } else {\n        // Direct value\n        shadow[entityId] = currentValue\n    }\n}\n\n/**\n * Creates a serializer for a single AoS component\n */\nconst createAoSComponentSerializer = (component: AoSComponentRef, diff: boolean, shadowMap?: Map<any, any>, epsilon = 0.0001) => {\n    // Determine if this is an object component by checking if it has property definitions\n    const isObjectComponent = typeof component === 'object' && \n        Object.keys(component).some(key => isNaN(parseInt(key)) && typeof component[key] === 'object')\n    \n    if (isObjectComponent) {\n        // Object component like { x: f32(), y: f32() }\n        const props = Object.keys(component).filter(key => isNaN(parseInt(key)))\n        const types = props.map(prop => getTypeForArray(component[prop]))\n        const setters = types.map(type => typeSetters[type])\n        \n        return (view: DataView, offset: number, entityId: number) => {\n            const value = component[entityId]\n            if (value === undefined) return 0\n            \n            if (diff && shadowMap) {\n                if (!hasComponentChanged(shadowMap, component, entityId, epsilon)) {\n                    return 0\n                }\n                updateShadow(shadowMap, component, entityId)\n            }\n            \n            let bytesWritten = 0\n            \n            // Serialize all properties\n            for (let i = 0; i < props.length; i++) {\n                const prop = component[props[i]]\n                const propValue = value[props[i]]\n                \n                if (isArrayType(prop)) {\n                    bytesWritten += serializeArrayValue(getArrayElementType(prop), propValue, view, offset + bytesWritten)\n                } else {\n                    bytesWritten += setters[i](view, offset + bytesWritten, propValue)\n                }\n            }\n            \n            return bytesWritten\n        }\n    } else {\n        // Direct value component\n        const type = getTypeForArray(component as PrimitiveBrand | TypedArray | ArrayType<any>)\n        const setter = typeSetters[type]\n        \n        return (view: DataView, offset: number, entityId: number) => {\n            const value = (component as any)[entityId]\n            if (value === undefined) return 0\n            \n            if (diff && shadowMap) {\n                if (!hasComponentChanged(shadowMap, component as any, entityId, epsilon)) {\n                    return 0\n                }\n                updateShadow(shadowMap, component as any, entityId)\n            }\n            \n            return setter(view, offset, value)\n        }\n    }\n}\n\n/**\n * Creates a deserializer for a single AoS component\n */\nconst createAoSComponentDeserializer = (component: AoSComponentRef) => {\n    // Determine if this is an object component\n    const isObjectComponent = typeof component === 'object' && \n        Object.keys(component).some(key => isNaN(parseInt(key)) && typeof component[key] === 'object')\n    \n    if (isObjectComponent) {\n        // Object component\n        const props = Object.keys(component).filter(key => isNaN(parseInt(key)))\n        const types = props.map(prop => getTypeForArray(component[prop]))\n        const getters = types.map(type => typeGetters[type])\n        \n        return (view: DataView, offset: number, entityId: number) => {\n            let bytesRead = 0\n            const value: any = {}\n            \n            // Deserialize all properties\n            for (let i = 0; i < props.length; i++) {\n                const prop = component[props[i]]\n                \n                if (isArrayType(prop)) {\n                    const { value: propValue, size } = deserializeArrayValue(getArrayElementType(prop), view, offset + bytesRead)\n                    if (Array.isArray(propValue)) {\n                        value[props[i]] = propValue\n                    }\n                    bytesRead += size\n                } else {\n                    const { value: propValue, size } = getters[i](view, offset + bytesRead)\n                    value[props[i]] = propValue\n                    bytesRead += size\n                }\n            }\n            \n            component[entityId] = value\n            return bytesRead\n        }\n    } else {\n        // Direct value component\n        const type = getTypeForArray(component as PrimitiveBrand | TypedArray | ArrayType<any>)\n        const getter = typeGetters[type]\n        \n        return (view: DataView, offset: number, entityId: number) => {\n            const { value, size } = getter(view, offset)\n            ;(component as any)[entityId] = value\n            return size\n        }\n    }\n}\n\n/**\n * Options for AoS serializer\n */\nexport type AoSSerializerOptions = {\n    diff?: boolean\n    buffer?: ArrayBuffer\n    epsilon?: number\n}\n\n/**\n * Creates a serializer function for Array of Structures (AoS) components.\n * @param {AoSComponentRef[]} components - The AoS components to serialize.\n * @param {AoSSerializerOptions} [options] - Serializer options.\n * @returns {Function} A function that serializes the AoS data.\n */\nexport const createAoSSerializer = (components: AoSComponentRef[], options: AoSSerializerOptions = {}) => {\n    const { \n        diff = false, \n        buffer = new ArrayBuffer(1024 * 1024 * 100), \n        epsilon = 0.0001 \n    } = options\n\n    const view = new DataView(buffer)\n    const shadowMap = diff ? new Map<any, any>() : undefined\n    const componentSerializers = components.map(component => \n        createAoSComponentSerializer(component, diff, shadowMap, epsilon)\n    )\n\n    return (entityIds: number[] | readonly number[]): ArrayBuffer => {\n        let offset = 0\n        \n        for (let i = 0; i < entityIds.length; i++) {\n            const entityId = entityIds[i]\n            \n            if (diff) {\n                // Check if any component has changes for this entity\n                let entityHasChanges = false\n                for (let j = 0; j < components.length; j++) {\n                    if (shadowMap && hasComponentChanged(shadowMap, components[j], entityId, epsilon)) {\n                        entityHasChanges = true\n                        break\n                    }\n                }\n                \n                if (!entityHasChanges) continue\n                \n                // Write entity ID\n                offset += typeSetters[$u32](view, offset, entityId)\n                \n                // Write changed components and build mask\n                const maskOffset = offset\n                const maskSetter = components.length <= 8 ? typeSetters[$u8] : components.length <= 16 ? typeSetters[$u16] : typeSetters[$u32]\n                offset += maskSetter === typeSetters[$u8] ? 1 : maskSetter === typeSetters[$u16] ? 2 : 4\n                \n                let componentMask = 0\n                for (let j = 0; j < componentSerializers.length; j++) {\n                    const bytesWritten = componentSerializers[j](view, offset, entityId)\n                    if (bytesWritten > 0) {\n                        componentMask |= 1 << j\n                        offset += bytesWritten\n                    }\n                }\n                \n                // Write the component mask\n                maskSetter(view, maskOffset, componentMask)\n            } else {\n                // Write entity ID\n                offset += typeSetters[$u32](view, offset, entityId)\n                \n                // Write all components\n                for (let j = 0; j < componentSerializers.length; j++) {\n                    offset += componentSerializers[j](view, offset, entityId)\n                }\n            }\n        }\n        \n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Options for AoS deserializer\n */\nexport type AoSDeserializerOptions = {\n    diff?: boolean\n}\n\n/**\n * Creates a deserializer function for Array of Structures (AoS) components.\n * @param {AoSComponentRef[]} components - The AoS components to deserialize.\n * @param {AoSDeserializerOptions} [options] - Deserializer options.\n * @returns {Function} A function that deserializes the AoS data.\n */\nexport const createAoSDeserializer = (components: AoSComponentRef[], options: AoSDeserializerOptions = {}) => {\n    const { diff = false } = options\n    const componentDeserializers = components.map(component => createAoSComponentDeserializer(component))\n\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            // Read entity ID\n            const { value: originalEntityId, size: entityIdSize } = typeGetters[$u32](view, offset)\n            offset += entityIdSize\n            const entityId = entityIdMapping ? entityIdMapping.get(originalEntityId) ?? originalEntityId : originalEntityId\n\n            if (diff) {\n                // Read component mask\n                const maskGetter = components.length <= 8 ? typeGetters[$u8] : components.length <= 16 ? typeGetters[$u16] : typeGetters[$u32]\n                const { value: componentMask, size: maskSize } = maskGetter(view, offset)\n                offset += maskSize\n\n                // Read changed components\n                for (let i = 0; i < components.length; i++) {\n                    if (componentMask & (1 << i)) {\n                        offset += componentDeserializers[i](view, offset, entityId)\n                    }\n                }\n            } else {\n                // Read all components\n                for (let i = 0; i < componentDeserializers.length; i++) {\n                    offset += componentDeserializers[i](view, offset, entityId)\n                }\n            }\n        }\n    }\n}", "import { createSoASerializer, createSoADeserializer, PrimitiveBrand } from './SoASerializer'\nimport {\n    addComponent,\n    hasComponent,\n    World,\n    getAllEntities,\n    addEntity,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    Relation,\n    ComponentRef,\n    query\n} from 'bitecs'\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32 } from './SoASerializer'\n\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            dataView.setFloat64(offset, value)\n            return offset + 8\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr) {\n                arr[eid] = dataView.getUint32(offset)\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Creates a snapshot serializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the world state and returns a slice of the buffer.\n */\nexport const createSnapshotSerializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n\n    /**\n     * Serializes entity-component relationships.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeEntityComponentRelationships = (entities: readonly number[]) => {\n        const entityCount = entities.length\n        \n        // Write entity count\n        dataView.setUint32(offset, entityCount)\n        offset += 4\n\n        // Serialize entity-component relationships\n        for (let i = 0; i < entityCount; i++) {\n            const entityId = entities[i]\n            let componentCount = 0\n            \n            dataView.setUint32(offset, entityId)\n            offset += 4\n            \n            const componentCountOffset = offset\n            offset += 1\n            \n            for (let j = 0; j < components.length; j++) {\n                const component = components[j]\n                if (isRelation(component)) {\n                    const targets = getRelationTargets(world, entityId, component as Relation<any>)\n                    for (const target of targets) {\n                        dataView.setUint8(offset, j)\n                        offset += 1\n                        dataView.setUint32(offset, target)\n                        offset += 4\n                        const relationData = (component as any)(target)\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                        componentCount++\n                    }\n                } else if (hasComponent(world, entityId, component)) {\n                    dataView.setUint8(offset, j)\n                    offset += 1\n                    componentCount++\n                }\n            }\n            \n            dataView.setUint8(componentCountOffset, componentCount)\n        }\n    }\n\n    /**\n     * Serializes component data for all entities.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeComponentData = (entities: readonly number[]) => {\n        const soaSerializer = createSoASerializer(components, { buffer: buffer.slice(offset) })\n        const componentData = soaSerializer(entities)\n        new Uint8Array(buffer).set(new Uint8Array(componentData), offset)\n        offset += componentData.byteLength\n    }\n\n    return () => {\n        offset = 0\n        const entities = getAllEntities(world)\n        serializeEntityComponentRelationships(entities)\n        serializeComponentData(entities)\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a snapshot deserializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @returns {Function} A function that takes a serialized packet and deserializes it into the world, returning a map of packet entity IDs to world entity IDs.\n */\nexport const createSnapshotDeserializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], constructorMapping?: Map<number, number>) => {\n    let entityIdMapping = constructorMapping || new Map<number, number>()\n    const soaDeserializer = createSoADeserializer(components)\n\n    return (packet: ArrayBuffer, overrideMapping?: Map<number, number>): Map<number, number> => {\n        const currentMapping = overrideMapping || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        // Read entity count\n        const entityCount = dataView.getUint32(offset)\n        offset += 4\n\n        // Deserialize entity-component relationships\n        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n\n            let worldEntityId = currentMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                currentMapping.set(packetEntityId, worldEntityId)\n            }\n\n            const componentCount = dataView.getUint8(offset)\n            offset += 1\n\n            for (let i = 0; i < componentCount; i++) {\n                const componentIndex = dataView.getUint8(offset)\n                offset += 1\n                const component = components[componentIndex]\n                \n                if (isRelation(component)) {\n                    const targetId = dataView.getUint32(offset)\n                    offset += 4\n                    let worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId === undefined) {\n                        worldTargetId = addEntity(world)\n                        currentMapping.set(targetId, worldTargetId)\n                    }\n                    const relationComponent = (component as (target: any) => any)(worldTargetId)\n                    addComponent(world, worldEntityId, relationComponent)\n                    offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset)\n                } else {\n                    addComponent(world, worldEntityId, component)\n                }\n            }\n        }\n\n        // Deserialize component data\n        soaDeserializer(packet.slice(offset), currentMapping)\n\n        return currentMapping\n    }\n}\n\n\nexport const test = (w:any) => {\n    return w === Wildcard\n}", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n    entityExists,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    EntityId\n} from 'bitecs'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3,\n    AddRelation = 4,\n    RemoveRelation = 5,\n}\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32 } from './SoASerializer'\n\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            dataView.setFloat64(offset, value)\n            return offset + 8\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr) {\n                arr[eid] = dataView.getUint32(offset)\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number, number?, any?][] = []\n    const relationTargets = new Map<number, Map<number, number>>()\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n        relationTargets.delete(eid)\n    })\n\n    components.forEach((component, i) => {\n        if (isRelation(component)) {\n            observe(world, onAdd(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targets = getRelationTargets(world, eid, component)\n                for (const target of targets) {\n                    if (!relationTargets.has(eid)) {\n                        relationTargets.set(eid, new Map())\n                    }\n                    relationTargets.get(eid).set(i, target)\n                    const relationData = component(target)\n                    queue.push([eid, OperationType.AddRelation, i, target, relationData])\n                }\n            })\n\n            observe(world, onRemove(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targetMap = relationTargets.get(eid)\n                if (targetMap) {\n                    const target = targetMap.get(i)\n                    if (target !== undefined) {\n                        queue.push([eid, OperationType.RemoveRelation, i, target])\n                        targetMap.delete(i)\n                        if (targetMap.size === 0) {\n                            relationTargets.delete(eid)\n                        }\n                    }\n                }\n            })\n        } else {\n            observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.AddComponent, i])\n            })\n\n            observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.RemoveComponent, i])\n            })\n        }\n    })\n    \n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId, targetId, relationData] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            if (type === OperationType.AddComponent || \n                type === OperationType.RemoveComponent || \n                type === OperationType.AddRelation ||\n                type === OperationType.RemoveRelation) {\n                dataView.setUint8(offset, componentId)\n                offset += 1\n                \n                if (type === OperationType.AddRelation || type === OperationType.RemoveRelation) {\n                    dataView.setUint32(offset, targetId)\n                    offset += 4\n                    \n                    if (type === OperationType.AddRelation && relationData) {\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                    }\n                }\n            }\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], constructorMapping?: Map<number, number>) => {\n    let entityIdMapping = constructorMapping || new Map<number, number>()\n    \n    return (packet: ArrayBuffer, overrideMapping?: Map<number, number>) => {\n        // Allow overriding the mapping for this call\n        const currentMapping = overrideMapping || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            let componentId = -1\n            let targetId = -1\n            \n            if (operationType === OperationType.AddComponent || \n                operationType === OperationType.RemoveComponent ||\n                operationType === OperationType.AddRelation ||\n                operationType === OperationType.RemoveRelation) {\n                componentId = dataView.getUint8(offset)\n                offset += 1\n                \n                if (operationType === OperationType.AddRelation || operationType === OperationType.RemoveRelation) {\n                    targetId = dataView.getUint32(offset)\n                    offset += 4\n                }\n            }\n\n            const component = components[componentId]\n            let worldEntityId = currentMapping.get(packetEntityId)\n\n            if (operationType === OperationType.AddEntity) {\n                if (worldEntityId === undefined) {\n                    worldEntityId = addEntity(world)\n                    currentMapping.set(packetEntityId, worldEntityId)\n                    addComponent(world, worldEntityId, networkedTag)\n                } else {\n                    // TODO: figure out if this should ignore, throw, warn, or if the observer serializer should maybe do a snapshot on first call?\n                    // throw new Error(`Entity with ID ${packetEntityId} already exists in the mapping.`)\n                    console.warn(`Attempted to deserialize addEntity with ID ${packetEntityId}, but it has already been deserialzied and exists in the mapping.`)\n                }\n            } else if (worldEntityId !== undefined && entityExists(world, worldEntityId)) {\n                if (operationType === OperationType.RemoveEntity) {\n                    removeEntity(world, worldEntityId)\n                    currentMapping.delete(packetEntityId)\n                } else if (operationType === OperationType.AddComponent) {\n                    addComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.RemoveComponent) {\n                    removeComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.AddRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        const relationComponent = component(worldTargetId)\n                        addComponent(world, worldEntityId, relationComponent)\n                        offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset)\n                    }\n                } else if (operationType === OperationType.RemoveRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        removeComponent(world, worldEntityId, component(worldTargetId))\n                    }\n                }\n            }\n        }\n\n        return currentMapping\n    }\n}\n"],
  "mappings": "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",
  "names": ["array", "isFloatType", "array", "getEpsilonForType", "import_bitecs", "serializeRelationData", "deserializeRelationData"]
}
