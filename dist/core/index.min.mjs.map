{
  "version": 3,
  "sources": ["../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/SparseSet.ts", "../../src/core/utils/Observer.ts", "../../src/core/Query.ts", "../../src/core/Relation.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/core/utils/pipe.ts"],
  "sourcesContent": ["export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\r\n    value,\r\n    enumerable: false,\r\n    writable: true,\r\n    configurable: true,\r\n})\r\n\r\nexport const defineHiddenProperties = (obj:any,kv:any) => {\r\n    const descriptors = {\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true,\r\n    }\r\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\r\n}", "/**\r\n * Represents the structure for managing entity IDs.\r\n */\r\nexport type EntityIndex = {\r\n    /** The number of currently alive entities. */\r\n    aliveCount: number\r\n    /** Array of entity IDs, densely packed. */\r\n    dense: number[]\r\n    /** Sparse array mapping entity IDs to their index in the dense array. */\r\n    sparse: number[]\r\n    /** The highest entity ID that has been assigned. */\r\n    maxId: number\r\n    /** Flag indicating if versioning is enabled. */\r\n    versioning: boolean\r\n    /** Number of bits used for versioning. */\r\n    versionBits: number\r\n    /** Bit mask for entity ID. */\r\n    entityMask: number\r\n    /** Bit shift for version. */\r\n    versionShift: number\r\n    /** Bit mask for version. */\r\n    versionMask: number\r\n}\r\n\r\n/**\r\n * Extracts the entity ID from a versioned entity ID by stripping off the version.\r\n * @param {EntityIndex} index - The EntityIndex containing the masks.\r\n * @param {number} id - The versioned entity ID.\r\n * @returns {number} The entity ID without the version.\r\n */\r\nexport const getId = (index: EntityIndex, id: number): number => id & index.entityMask;\r\n\r\n/**\r\n * Extracts the version from an entity ID.\r\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\r\n * @param {number} id - The entity ID.\r\n * @returns {number} The version.\r\n */\r\nexport const getVersion = (index: EntityIndex, id: number): number => \r\n    (id >>> index.versionShift) & ((1 << index.versionBits) - 1);\r\n\r\n/**\r\n * Increments the version of an entity ID.\r\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\r\n * @param {number} id - The entity ID.\r\n * @returns {number} The new entity ID with incremented version.\r\n */\r\nexport const incrementVersion = (index: EntityIndex, id: number): number => {\r\n    const currentVersion = getVersion(index, id);\r\n    const newVersion = (currentVersion + 1) & ((1 << index.versionBits) - 1);\r\n    return (id & index.entityMask) | (newVersion << index.versionShift);\r\n}\r\n\r\n/**\r\n * Creates configuration options for entity ID recycling with versioning.\r\n * @param {number} [versionBits] - Optional number of bits to use for version numbers. Defaults to 8 if not specified.\r\n * @returns {object} Configuration object with versioning enabled and specified version bits.\r\n */\r\nexport const withVersioning = (versionBits?: number) => ({\r\n    versioning: true,\r\n    versionBits\r\n})\r\n\r\n/**\r\n * Creates and initializes a new EntityIndex.\r\n * @param {object|function} [options] - Optional configuration object from withVersioning() or withVersioning function.\r\n * @param {boolean} options.versioning - Flag to enable versioning for recycled IDs.\r\n * @param {number} options.versionBits - Number of bits to use for versioning (default: 8).\r\n * @returns {EntityIndex} A new EntityIndex object.\r\n */\r\nexport const createEntityIndex = (options?: ReturnType<typeof withVersioning> | typeof withVersioning): EntityIndex => {\r\n    const config = options \r\n        ? typeof options === 'function' \r\n            ? options()\r\n            : options\r\n        : { versioning: false, versionBits: 8 }\r\n\r\n    const versionBits = config.versionBits ?? 8\r\n    const versioning = config.versioning ?? false\r\n    \r\n    const entityBits = 32 - versionBits\r\n    const entityMask = (1 << entityBits) - 1\r\n    const versionShift = entityBits\r\n    const versionMask = ((1 << versionBits) - 1) << versionShift\r\n\r\n    return {\r\n        aliveCount: 0,\r\n        dense: [],\r\n        sparse: [],\r\n        maxId: 0,\r\n        versioning,\r\n        versionBits,\r\n        entityMask,\r\n        versionShift,\r\n        versionMask\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a new entity ID to the index or recycles an existing one.\r\n * @param {EntityIndex} index - The EntityIndex to add to.\r\n * @returns {number} The new or recycled entity ID.\r\n */\r\nexport const addEntityId = (index: EntityIndex): number => {\r\n    if (index.aliveCount < index.dense.length) {\r\n        // Recycle id\r\n        const recycledId = index.dense[index.aliveCount];\r\n        const entityId = recycledId;\r\n        index.sparse[entityId] = index.aliveCount;\r\n        index.aliveCount++;\r\n        return recycledId;\r\n    }\r\n\r\n    // Create new id\r\n    const id = ++index.maxId;\r\n    index.dense.push(id);\r\n    index.sparse[id] = index.aliveCount;\r\n    index.aliveCount++;\r\n\r\n    return id;\r\n}\r\n\r\n/**\r\n * Removes an entity ID from the index.\r\n * @param {EntityIndex} index - The EntityIndex to remove from.\r\n * @param {number} id - The entity ID to remove.\r\n */\r\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\r\n    const denseIndex = index.sparse[id];\r\n    if (denseIndex === undefined || denseIndex >= index.aliveCount) {\r\n        // Entity is not alive or doesn't exist, nothing to be done\r\n        return;\r\n    }\r\n\r\n    const lastIndex = index.aliveCount - 1;\r\n    const lastId = index.dense[lastIndex];\r\n\r\n    // Swap with the last element\r\n    index.sparse[lastId] = denseIndex;\r\n    index.dense[denseIndex] = lastId;\r\n\r\n    // Update the removed entity's record\r\n    index.sparse[id] = lastIndex; // Set to lastIndex instead of undefined\r\n    index.dense[lastIndex] = id; // Keep the original id, don't strip version\r\n\r\n    // Version the ID if enabled\r\n    if (index.versioning) {\r\n        const newId = incrementVersion(index, id);\r\n        index.dense[lastIndex] = newId;\r\n    }\r\n\r\n    index.aliveCount--;\r\n}\r\n\r\n/**\r\n * Checks if an entity ID is currently alive in the index.\r\n * @param {EntityIndex} index - The EntityIndex to check.\r\n * @param {number} id - The entity ID to check.\r\n * @returns {boolean} True if the entity ID is alive, false otherwise.\r\n */\r\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\r\n    const entityId = getId(index, id);\r\n    const denseIndex = index.sparse[entityId];\r\n    return denseIndex !== undefined && denseIndex < index.aliveCount && index.dense[denseIndex] === id;\r\n}\r\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\r\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\r\nimport { ComponentRef, ComponentData } from './Component'\r\nimport { Query } from './Query'\r\nimport { EntityId } from './Entity'\r\n\r\nexport const $internal = Symbol.for('bitecs_internal')\r\n\r\nexport type WorldContext = {\r\n    entityIndex: EntityIndex\r\n    entityMasks: number[][]\r\n    entityComponents: Map<EntityId, Set<ComponentRef>>\r\n    bitflag: number\r\n    componentMap: Map<ComponentRef, ComponentData>\r\n    componentCount: number\r\n    queries: Set<Query>\r\n    queriesHashMap: Map<string, Query>\r\n    notQueries: Set<any>\r\n    dirtyQueries: Set<any>\r\n    entitiesWithRelations: Set<EntityId>\r\n}\r\n\r\nexport type InternalWorld = {\r\n    [$internal]: WorldContext\r\n}\r\n\r\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\r\n\r\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \r\n    defineHiddenProperty(context || {} as T, $internal, {\r\n        entityIndex: entityIndex || createEntityIndex(),\r\n        entityMasks: [[]],\r\n        entityComponents: new Map(),\r\n        bitflag: 1,\r\n        componentMap: new Map(),\r\n        componentCount: 0,\r\n        queries: new Set(),\r\n        queriesHashMap: new Map(),\r\n        notQueries: new Set(),\r\n        dirtyQueries: new Set(),\r\n        entitiesWithRelations: new Set(),\r\n}) as World<T>\r\n\r\n/**\r\n * Creates a new world with various configurations.\r\n * @template T\r\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\r\n * @returns {World<T>} The created world.\r\n */\r\n\r\n// TODO: middleware\r\n\r\nexport function createWorld<T extends object = {}>(\r\n    ...args: Array<EntityIndex | T>\r\n): World<T> {\r\n    let entityIndex: EntityIndex | undefined\r\n    let context: T | undefined\r\n\r\n    args.forEach(arg => {\r\n        if (typeof arg === 'object' && 'add' in arg && 'remove' in arg) {\r\n            entityIndex = arg as EntityIndex\r\n        } else if (typeof arg === 'object') {\r\n            context = arg as T\r\n        }\r\n    })\r\n\r\n    return createBaseWorld<T>(context, entityIndex)\r\n}\r\n\r\n/**\r\n * Resets a world.\r\n *\r\n * @param {World} world\r\n * @returns {object}\r\n */\r\nexport const resetWorld = (world: World) => {\r\n    const ctx = (world as InternalWorld)[$internal]\r\n    ctx.entityIndex = createEntityIndex()\r\n    ctx.entityMasks = [[]]\r\n    ctx.entityComponents = new Map()\r\n    ctx.bitflag = 1\r\n    ctx.componentMap = new Map()\r\n    ctx.componentCount = 0\r\n    ctx.queries = new Set()\r\n    ctx.queriesHashMap = new Map()\r\n    ctx.notQueries = new Set()\r\n    ctx.dirtyQueries = new Set()\r\n    ctx.entitiesWithRelations = new Set()\r\n    return world\r\n}\r\n\r\n/**\r\n * Deletes a world by removing its internal data.\r\n *\r\n * @param {World} world - The world to be deleted.\r\n */\r\nexport const deleteWorld = (world: World) => {\r\n    delete (world as any)[$internal];\r\n}\r\n\r\n/**\r\n * Returns all components registered to a world\r\n *\r\n * @param {World} world\r\n * @returns Array\r\n */\r\nexport const getWorldComponents = (world: World) =>\r\n    Object.keys((world as InternalWorld)[$internal].componentMap)\r\n\r\n/**\r\n * Returns all existing entities in a world\r\n *\r\n * @param {World} world\r\n * @returns Array\r\n */\r\nexport const getAllEntities = (world: World): readonly EntityId[] => Array.from((world as InternalWorld)[$internal].entityComponents.keys())\r\n", "export type SparseSet = {\r\n    add: (val: number) => void\r\n    remove: (val: number) => void\r\n    has: (val: number) => boolean\r\n    sparse: number[]\r\n    dense: number[] | Uint32Array\r\n    reset: () => void\r\n}\r\n\r\nexport const createSparseSet = (): SparseSet => {\r\n\tconst dense: number[] = []\r\n\tconst sparse: number[] = []\r\n\r\n\tconst has = (val: number) => dense[sparse[val]] === val\r\n\r\n\tconst add = (val: number) => {\r\n\t\tif (has(val)) return\r\n\t\tsparse[val] = dense.push(val) - 1\r\n\t}\r\n\r\n\tconst remove = (val: number) => {\r\n\t\tif (!has(val)) return\r\n\t\tconst index = sparse[val]\r\n\t\tconst swapped = dense.pop()!\r\n\t\tif (swapped !== val) {\r\n\t\t\tdense[index] = swapped\r\n\t\t\tsparse[swapped] = index\r\n\t\t}\r\n\t}\r\n\r\n\tconst reset = () => {\r\n\t\tdense.length = 0\r\n\t\tsparse.length = 0\r\n\t}\r\n\r\n\treturn {\r\n\t\tadd,\r\n\t\tremove,\r\n\t\thas,\r\n\t\tsparse,\r\n\t\tdense,\r\n\t\treset,\r\n\t}\r\n}\r\n\r\nconst SharedArrayBufferOrArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer\r\n\r\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\r\n\tconst sparse: number[] = []\r\n\tlet length = 0\r\n\tlet dense: Uint32Array = new Uint32Array(new SharedArrayBufferOrArrayBuffer(initialCapacity * 4))\r\n\r\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\r\n\r\n\tconst add = (val: number) => {\r\n\t\tif (has(val)) return\r\n\t\tif (length >= dense.length) {\r\n\t\t\tconst newDense = new Uint32Array(new SharedArrayBufferOrArrayBuffer(dense.length * 2 * 4))\r\n\t\t\tnewDense.set(dense)\r\n\t\t\tdense = newDense\r\n\t\t}\r\n\t\tdense[length] = val\r\n\t\tsparse[val] = length\r\n\t\tlength++\r\n\t}\r\n\r\n\tconst remove = (val: number) => {\r\n\t\tif (!has(val)) return\r\n\t\tlength--\r\n\t\tconst index = sparse[val]\r\n\t\tconst swapped = dense[length]\r\n\t\tdense[index] = swapped\r\n\t\tsparse[swapped] = index\r\n\t}\r\n\r\n\tconst reset = () => {\r\n\t\tlength = 0\r\n\t\tsparse.length = 0\r\n\t}\r\n\r\n\treturn {\r\n\t\tadd,\r\n\t\tremove,\r\n\t\thas,\r\n\t\tsparse,\r\n\t\tget dense() {\r\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\r\n\t\t},\r\n\t\treset,\r\n\t}\r\n}", "import { EntityId } from \"../Entity\"\r\n\r\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\r\n\r\nexport interface Observable {\r\n  subscribe: (observer: Observer) => () => void\r\n  notify: (entity: EntityId, ...args: any[])  => void | object\r\n}\r\n\r\nexport const createObservable = (): Observable => {\r\n  const observers = new Set<Observer>()\r\n\r\n  const subscribe = (observer: Observer) => {\r\n    observers.add(observer)\r\n    return () => {\r\n      observers.delete(observer)\r\n    }\r\n  }\r\n  const notify = (entity: EntityId, ...args: any[]) => {\r\n    return Array.from(observers).reduce((acc, listener) => {\r\n      const result = listener(entity, ...args)\r\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\r\n    }, {})\r\n  }\r\n\r\n  return {\r\n    subscribe,\r\n    notify\r\n  }\r\n}\r\n", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\r\nimport { hasComponent, registerComponent } from './Component'\r\nimport { ComponentRef, ComponentData } from './Component'\r\nimport { World } from \"./World\"\r\nimport { InternalWorld } from './World'\r\nimport { $internal } from './World'\r\nimport { createObservable } from './utils/Observer'\r\nimport { EntityId, Prefab } from './Entity'\r\n\r\n/**\r\n * @typedef {Uint32Array | readonly number[]} QueryResult\r\n * @description The result of a query, either as a Uint32Array or a readonly array of numbers.\r\n */\r\nexport type QueryResult = Uint32Array | readonly EntityId[]\r\n\r\n/**\r\n * @typedef {Object} Query\r\n * @description Represents a query in the ECS.\r\n * @property {ComponentRef[]} allComponents - All components in the query.\r\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\r\n * @property {ComponentRef[]} notComponents - Components that should not be present.\r\n * @property {Object.<number, number>} masks - Bitmasks for each component generation.\r\n * @property {Object.<number, number>} orMasks - OR bitmasks for each component generation.\r\n * @property {Object.<number, number>} notMasks - NOT bitmasks for each component generation.\r\n * @property {Object.<number, number>} hasMasks - HAS bitmasks for each component generation.\r\n * @property {number[]} generations - Component generations.\r\n * @property {SparseSet} toRemove - Set of entities to be removed.\r\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\r\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\r\n */\r\nexport type Query = SparseSet & {\r\n\tallComponents: ComponentRef[]\r\n\torComponents: ComponentRef[]\r\n\tnotComponents: ComponentRef[]\r\n\tmasks: Record<number, number>\r\n\torMasks: Record<number, number>\r\n\tnotMasks: Record<number, number>\r\n\thasMasks: Record<number, number>\r\n\tgenerations: number[]\r\n\ttoRemove: SparseSet\r\n\taddObservable: ReturnType<typeof createObservable>\r\n\tremoveObservable: ReturnType<typeof createObservable>\r\n\tqueues: Record<any, any>\r\n}\r\n\r\n/**\r\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\r\n * @description Types of query operators.\r\n */\r\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\r\n/**\r\n * Symbol for query operator type.\r\n * @type {Symbol}\r\n */\r\nexport const $opType = Symbol.for('bitecs-opType')\r\n\r\n/**\r\n * Symbol for query operator terms.\r\n * @type {Symbol}\r\n */\r\nexport const $opTerms = Symbol.for('bitecs-opTerms')\r\n\r\n/**\r\n * @typedef {Object} OpReturnType\r\n * @property {symbol} [$opType] - The type of the operator.\r\n * @property {symbol} [$opTerms] - The components involved in the operation.\r\n */\r\nexport type OpReturnType = {\r\n\t[$opType]: string\r\n\t[$opTerms]: ComponentRef[]\r\n}\r\n\r\n/**\r\n * @typedef {Function} QueryOperator\r\n * @description A function that creates a query operator.\r\n * @param {...ComponentRef} components - The components to apply the operator to.\r\n * @returns {OpReturnType} The result of the operator.\r\n */\r\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\r\n\r\n/**\r\n * @typedef {ComponentRef | QueryOperator} QueryTerm\r\n * @description A term in a query, either a component reference or a query operator.\r\n */\r\nexport type QueryTerm = ComponentRef | QueryOperator\r\n\r\n\r\n// Aliases\r\nexport type OrOp = QueryOperator\r\nexport type AndOp = QueryOperator\r\nexport type NotOp = QueryOperator\r\nexport type AnyOp = OrOp\r\nexport type AllOp = AndOp\r\nexport type NoneOp = NotOp\r\n\r\n/**\r\n * @function Or\r\n * @description Creates an 'Or' query operator.\r\n * @param {...ComponentRef} components - The components to apply the 'Or' operator to.\r\n * @returns {OpReturnType} The 'Or' operator configuration.\r\n */\r\nexport const Or: OrOp = (...components: ComponentRef[]) => ({\r\n\t[$opType]: 'Or',\r\n\t[$opTerms]: components\r\n})\r\n\r\n/**\r\n * @function And\r\n * @description Creates an 'And' query operator.\r\n * @param {...ComponentRef} components - The components to apply the 'And' operator to.\r\n * @returns {OpReturnType} The 'And' operator configuration.\r\n */\r\nexport const And: AndOp = (...components: ComponentRef[]) => ({\r\n\t[$opType]: 'And',\r\n\t[$opTerms]: components\r\n})\r\n\r\n/**\r\n * @function Not\r\n * @description Creates a 'Not' query operator.\r\n * @param {...ComponentRef} components - The components to apply the 'Not' operator to.\r\n * @returns {OpReturnType} The 'Not' operator configuration.\r\n */\r\nexport const Not: NotOp = (...components: ComponentRef[]) => ({\r\n\t[$opType]: 'Not',\r\n\t[$opTerms]: components\r\n})\r\n\r\nexport const Any: AnyOp = Or\r\nexport const All: AllOp = And\r\nexport const None: NoneOp = Not\r\n\r\n/**\r\n * @typedef {Function} ObservableHook\r\n * @description A function that creates an observable hook for queries.\r\n * @param {...QueryTerm} terms - The query terms to observe.\r\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\r\n */\r\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\r\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\r\n\t[$opTerms]: QueryTerm[]\r\n}\r\n\r\nexport type ObservableHook = ReturnType<ObservableHookDef>\r\n\r\n/**\r\n * @function onAdd\r\n * @description Creates an 'add' observable hook.\r\n * @param {...QueryTerm} terms - The query terms to observe for addition.\r\n * @returns {OpReturnType} The 'add' observable hook configuration.\r\n */\r\nexport const onAdd: ObservableHookDef = (...terms: QueryTerm[]) => ({\r\n\t[$opType]: 'add',\r\n\t[$opTerms]: terms\r\n})\r\n\r\n/**\r\n * @function onRemove\r\n * @description Creates a 'remove' observable hook.\r\n * @param {...QueryTerm} terms - The query terms to observe for removal.\r\n * @returns {OpReturnType} The 'remove' observable hook configuration.\r\n */\r\nexport const onRemove: ObservableHookDef = (...terms: QueryTerm[]) => ({\r\n\t[$opType]: 'remove',\r\n\t[$opTerms]: terms\r\n})\r\n\r\n/**\r\n * @function onSet\r\n * @description Creates a 'set' observable hook.\r\n * @param {...QueryTerm} terms - The query terms to observe for setting.\r\n * @returns {OpReturnType} The 'set' observable hook configuration.\r\n */\r\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({\r\n\t[$opType]: 'set',\r\n\t[$opTerms]: [component]\r\n})\r\n\r\n/**\r\n * @function onGet\r\n * @description Creates a 'get' observable hook.\r\n * @param {...QueryTerm} terms - The query terms to observe for getting.\r\n * @returns {OpReturnType} The 'get' observable hook configuration.\r\n */\r\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({\r\n\t[$opType]: 'get',\r\n\t[$opTerms]: [component]\r\n})\r\n\r\n/**\r\n * @function observe\r\n * @description Observes changes in entities based on specified components.\r\n * @param {World} world - The world object.\r\n * @param {ObservableHook} hook - The observable hook.\r\n * @param {function(number): any} callback - The callback function to execute when changes occur.\r\n * @returns {function(): void} A function to unsubscribe from the observation.\r\n */\r\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst { [$opType]: type, [$opTerms]: components } = hook\r\n\r\n\tif (type === 'add' || type === 'remove') {\r\n\t\tconst hash = queryHash(world, components)\r\n\t\tlet queryData = ctx.queriesHashMap.get(hash)!\r\n\r\n\t\tif (!queryData) {\r\n\t\t\tqueryData = registerQuery(world, components)\r\n\t\t}\r\n\r\n\t\tconst observableKey = type === 'add' ? 'addObservable' : 'removeObservable'\r\n\t\treturn queryData[observableKey].subscribe(callback)\r\n\t} else if (type === 'set' || type === 'get') {\r\n\t\tif (components.length !== 1) {\r\n\t\t\tthrow new Error('Set and Get hooks can only observe a single component')\r\n\t\t}\r\n\t\tconst component = components[0]\r\n\t\tlet componentData = ctx.componentMap.get(component)\r\n\t\tif (!componentData) {\r\n\t\t\tcomponentData = registerComponent(world, component)\r\n\t\t}\r\n\t\tconst observableKey = type === 'set' ? 'setObservable' : 'getObservable'\r\n\t\treturn componentData[observableKey].subscribe(callback)\r\n\t}\r\n\r\n\tthrow new Error(`Invalid hook type: ${type}`)\r\n}\r\n\r\n/**\r\n * @function queryHash\r\n * @description Generates a hash for a query based on its terms.\r\n * @param {World} world - The world object.\r\n * @param {QueryTerm[]} terms - The query terms.\r\n * @returns {string} The generated hash.\r\n */\r\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\r\n\tconst getComponentId = (component: ComponentRef): number => {\r\n\t\tif (!ctx.componentMap.has(component)) {\r\n\t\t\tregisterComponent(world, component)\r\n\t\t}\r\n\t\treturn ctx.componentMap.get(component)!.id\r\n\t}\r\n\tconst termToString = (term: QueryTerm): string => {\r\n\t\tif ($opType in term) {\r\n\t\t\tconst componentIds = term[$opTerms].map(getComponentId)\r\n\t\t\tconst sortedComponentIds = componentIds.sort((a, b) => a - b)\r\n\t\t\tconst sortedType = term[$opType].toLowerCase()\r\n\t\t\treturn `${sortedType}(${sortedComponentIds.join(',')})`\r\n\t\t} else {\r\n\t\t\treturn getComponentId(term).toString()\r\n\t\t}\r\n\t}\r\n\r\n\treturn terms\r\n\t\t.map(termToString)\r\n\t\t.sort()\r\n\t\t.join('-')\r\n}\r\n\r\n/**\r\n * @function registerQuery\r\n * @description Registers a new query in the world.\r\n * @param {World} world - The world object.\r\n * @param {QueryTerm[]} terms - The query terms.\r\n * @param {Object} [options] - Additional options.\r\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\r\n * @returns {Query} The registered query.\r\n */\r\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst hash = queryHash(world, terms)\r\n\t// if (ctx.queriesHashMap.has(hash)) {\r\n\t// \treturn ctx.queriesHashMap.get(hash)!\r\n\t// }\r\n\tconst components: ComponentRef[] = []\r\n\tconst notComponents: ComponentRef[] = []\r\n\tconst orComponents: ComponentRef[] = []\r\n\r\n\tconst processComponents = (comps: ComponentRef[], targetArray: ComponentRef[]) => {\r\n\t\tcomps.forEach((comp: ComponentRef) => {\r\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\r\n\t\t\ttargetArray.push(comp)\r\n\t\t})\r\n\t}\r\n\r\n\tterms.forEach((term: QueryTerm) => {\r\n\t\tif ($opType in term) {\r\n\t\t\tif (term[$opType] === 'Not') {\r\n\t\t\t\tprocessComponents(term[$opTerms], notComponents)\r\n\t\t\t} else if (term[$opType] === 'Or') {\r\n\t\t\t\tprocessComponents(term[$opTerms], orComponents)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\r\n\t\t\tcomponents.push(term)\r\n\t\t}\r\n\t})\r\n\r\n\tconst mapComponents = (c: ComponentRef) => ctx.componentMap.get(c)!\r\n\tconst allComponents = components.concat(notComponents.flat()).concat(orComponents.flat()).map(mapComponents)\r\n\r\n\tconst sparseSet = options.buffered ? createUint32SparseSet() : createSparseSet()\r\n\r\n\tconst toRemove = createSparseSet()\r\n\r\n\tconst generations = allComponents\r\n\t\t.map((c) => c.generationId)\r\n\t\t.reduce((a, v) => {\r\n\t\t\tif (a.includes(v)) return a\r\n\t\t\ta.push(v)\r\n\t\t\treturn a\r\n\t\t}, [] as number[])\r\n\r\n\tconst reduceBitflags = (a: { [key: number]: number }, c: ComponentData) => {\r\n\t\tif (!a[c.generationId]) a[c.generationId] = 0\r\n\t\ta[c.generationId] |= c.bitflag\r\n\t\treturn a\r\n\t}\r\n\r\n\tconst masks = components.map(mapComponents).reduce(reduceBitflags, {})\r\n\tconst notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {})\r\n\tconst orMasks = orComponents.map(mapComponents).reduce(reduceBitflags, {})\r\n\tconst hasMasks = allComponents.reduce(reduceBitflags, {})\r\n\r\n\tconst addObservable = createObservable()\r\n\tconst removeObservable = createObservable()\r\n\r\n\tconst query = Object.assign(sparseSet, {\r\n\t\tcomponents,\r\n\t\tnotComponents,\r\n\t\torComponents,\r\n\t\tallComponents,\r\n\t\tmasks,\r\n\t\tnotMasks,\r\n\t\torMasks,\r\n\t\thasMasks,\r\n\t\tgenerations,\r\n\t\ttoRemove,\r\n\t\taddObservable,\r\n\t\tremoveObservable,\r\n\t\tqueues: {},\r\n\t}) as Query\r\n\r\n\tctx.queries.add(query)\r\n\r\n\tctx.queriesHashMap.set(hash, query)\r\n\r\n\tallComponents.forEach((c) => {\r\n\t\tc.queries.add(query)\r\n\t})\r\n\r\n\tif (notComponents.length) ctx.notQueries.add(query)\r\n\r\n\tconst entityIndex = ctx.entityIndex\r\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\r\n\t\tconst eid = entityIndex.dense[i]\r\n\t\tif (hasComponent(world, eid, Prefab)) continue\r\n\t\tconst match = queryCheckEntity(world, query, eid)\r\n\t\tif (match) {\r\n\t\t\tqueryAddEntity(query, eid)\r\n\t\t}\r\n\t}\r\n\r\n\treturn query\r\n}\r\n\r\n/**\r\n * @function innerQuery\r\n * @description Performs an internal query operation.\r\n * @param {World} world - The world object.\r\n * @param {QueryTerm[]} terms - The query terms.\r\n * @param {Object} [options] - Additional options.\r\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\r\n * @returns {QueryResult} The result of the query.\r\n */\r\nexport function innerQuery(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst hash = queryHash(world, terms)\r\n\tlet queryData = ctx.queriesHashMap.get(hash)\r\n\tif (!queryData) {\r\n\t\tqueryData = registerQuery(world, terms, options)\r\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\r\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\r\n\t}\r\n\treturn queryData.dense\r\n}\r\n\r\n/**\r\n * @function query\r\n * @description Performs a query operation.\r\n * @param {World} world - The world object.\r\n * @param {QueryTerm[]} terms - The query terms.\r\n * @returns {readonly EntityId[]} The result of the query as a readonly array of entity IDs.\r\n */\r\nexport function query(world: World, terms: QueryTerm[]): readonly EntityId[] {\r\n\tcommitRemovals(world)\r\n\treturn innerQuery(world, terms) as EntityId[]\r\n}\r\n\r\n/**\r\n * @function bufferQuery\r\n * @description Performs a buffered query operation.\r\n * @param {World} world - The world object.\r\n * @param {QueryTerm[]} terms - The query terms.\r\n * @returns {Uint32Array} The result of the query as a Uint32Array.\r\n */\r\nexport function bufferQuery(world: World, terms: QueryTerm[]): Uint32Array {\r\n\tcommitRemovals(world)\r\n\treturn innerQuery(world, terms, { buffered: true }) as Uint32Array\r\n}\r\n\r\n/**\r\n * @function queryCheckEntity\r\n * @description Checks if an entity matches a query.\r\n * @param {World} world - The world object.\r\n * @param {Query} query - The query to check against.\r\n * @param {number} eid - The entity ID to check.\r\n * @returns {boolean} True if the entity matches the query, false otherwise.\r\n */\r\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst { masks, notMasks, orMasks, generations } = query\r\n\r\n\tfor (let i = 0; i < generations.length; i++) {\r\n\t\tconst generationId = generations[i]\r\n\t\tconst qMask = masks[generationId]\r\n\t\tconst qNotMask = notMasks[generationId]\r\n\t\tconst qOrMask = orMasks[generationId]\r\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\r\n\r\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tif (qMask && (eMask & qMask) !== qMask) {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tif (qOrMask && (eMask & qOrMask) === 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\n/**\r\n * @function queryCheckComponent\r\n * @description Checks if a component matches a query.\r\n * @param {Query} query - The query to check against.\r\n * @param {ComponentData} c - The component data to check.\r\n * @returns {boolean} True if the component matches the query, false otherwise.\r\n */\r\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\r\n\tconst { generationId, bitflag } = c\r\n\tconst { hasMasks } = query\r\n\tconst mask = hasMasks[generationId]\r\n\treturn (mask & bitflag) === bitflag\r\n}\r\n\r\n/**\r\n * @function queryAddEntity\r\n * @description Adds an entity to a query.\r\n * @param {Query} query - The query to add the entity to.\r\n * @param {number} eid - The entity ID to add.\r\n */\r\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\r\n\tquery.toRemove.remove(eid)\r\n\r\n\tquery.addObservable.notify(eid)\r\n\r\n\tquery.add(eid)\r\n}\r\n\r\n/**\r\n * @function queryCommitRemovals\r\n * @description Commits removals for a query.\r\n * @param {Query} query - The query to commit removals for.\r\n */\r\nconst queryCommitRemovals = (query: Query) => {\r\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\r\n\t\tconst eid = query.toRemove.dense[i]\r\n\r\n\t\tquery.remove(eid)\r\n\t}\r\n\tquery.toRemove.reset()\r\n}\r\n\r\n/**\r\n * @function commitRemovals\r\n * @description Commits all pending removals for queries in the world.\r\n * @param {World} world - The world object.\r\n */\r\nexport const commitRemovals = (world: World) => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tif (!ctx.dirtyQueries.size) return\r\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\r\n\tctx.dirtyQueries.clear()\r\n}\r\n\r\n/**\r\n * @function queryRemoveEntity\r\n * @description Removes an entity from a query.\r\n * @param {World} world - The world object.\r\n * @param {Query} query - The query to remove the entity from.\r\n * @param {number} eid - The entity ID to remove.\r\n */\r\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst has = query.has(eid)\r\n\tif (!has || query.toRemove.has(eid)) return\r\n\tquery.toRemove.add(eid)\r\n\tctx.dirtyQueries.add(query)\r\n\tquery.removeObservable.notify(eid)\r\n}\r\n\r\n/**\r\n * @function removeQuery\r\n * @description Removes a query from the world.\r\n * @param {World} world - The world object.\r\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\r\n */\r\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst hash = queryHash(world, terms)\r\n\tconst query = ctx.queriesHashMap.get(hash)\r\n\tif (query) {\r\n\t\tctx.queries.delete(query)\r\n\t\tctx.queriesHashMap.delete(hash)\r\n\t}\r\n}\r\n", "import { getEntityComponents, World } from '.'\r\nimport { EntityId } from './Entity'\r\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\r\n\r\n/**\r\n * Callback function type for when a target is removed from a relation.\r\n * @callback OnTargetRemovedCallback\r\n * @param {number} subject - The subject entity ID.\r\n * @param {number} target - The target entity ID.\r\n */\r\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\r\n\r\n/**\r\n * Possible types for a relation target.\r\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\r\n */\r\nexport type RelationTarget = number | '*' | typeof Wildcard\r\n/**\r\n * Symbol for accessing the relation of a component.\r\n * @type {Symbol}\r\n */\r\nexport const $relation = Symbol.for('bitecs-relation')\r\n\r\n/**\r\n * Symbol for accessing the pair target of a component.\r\n * @type {Symbol}\r\n */\r\nexport const $pairTarget = Symbol.for('bitecs-pairTarget')\r\n\r\n/**\r\n * Symbol for checking if a component is a pair component.\r\n * @type {Symbol}\r\n */\r\nexport const $isPairComponent = Symbol.for('bitecs-isPairComponent')\r\n\r\n/**\r\n * Symbol for accessing the relation data of a component.\r\n * @type {Symbol}\r\n */\r\nexport const $relationData = Symbol.for('bitecs-relationData')\r\n\r\n/**\r\n * Interface for relation data.\r\n * @interface RelationData\r\n * @template T\r\n */\r\ntype RelationData<T> = {\r\n    pairsMap: Map<number | string | Relation<any>, T>\r\n    initStore: (eid: EntityId) => T\r\n    exclusiveRelation: boolean\r\n    autoRemoveSubject: boolean\r\n    onTargetRemoved: OnTargetRemovedCallback\r\n}\r\n\r\n/**\r\n * Type definition for a Relation function.\r\n * @template T\r\n * @typedef {function} Relation\r\n * @param {RelationTarget} target - The target of the relation.\r\n * @returns {T} The relation component.\r\n */\r\nexport type Relation<T> = (target: RelationTarget) => T\r\n\r\n/**\r\n * Creates a base relation.\r\n * @template T\r\n * @returns {Relation<T>} The created base relation.\r\n */\r\nconst createBaseRelation = <T>(): Relation<T> => {\r\n    const data = {\r\n        pairsMap: new Map(),\r\n        initStore: undefined,\r\n        exclusiveRelation: false,\r\n        autoRemoveSubject: false,\r\n        onTargetRemoved: undefined\r\n    }\r\n    const relation = (target: RelationTarget): T => {\r\n        if (target === undefined) throw Error('Relation target is undefined')\r\n        const normalizedTarget = target === '*' ? Wildcard : target\r\n        if (!data.pairsMap.has(normalizedTarget)) {\r\n            const component = data.initStore ? data.initStore(target) : {} as T\r\n            defineHiddenProperty(component, $relation, relation)\r\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\r\n            defineHiddenProperty(component, $isPairComponent, true)\r\n            data.pairsMap.set(normalizedTarget, component)\r\n        }\r\n\r\n        return data.pairsMap.get(normalizedTarget)!\r\n    }\r\n\r\n    defineHiddenProperty(relation, $relationData, data)\r\n\r\n    return relation as Relation<T>\r\n}\r\n\r\n/**\r\n * Adds a store to a relation.\r\n * @template T\r\n * @param {function(): T} createStore - Function to create the store.\r\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\r\n */\r\nexport const withStore = <T>(createStore: (eid: EntityId) => T) => (relation: Relation<T>): Relation<T> => {\r\n    const ctx = relation[$relationData] as RelationData<T>\r\n    ctx.initStore = createStore\r\n    return relation\r\n}\r\n\r\n/**\r\n * Makes a relation exclusive.\r\n * @template T\r\n * @param {Relation<T>} relation - The relation to make exclusive.\r\n * @returns {Relation<T>} The modified relation.\r\n */\r\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\r\n    const ctx = relation[$relationData] as RelationData<T>\r\n    ctx.exclusiveRelation = true\r\n    return relation\r\n}\r\n\r\n/**\r\n * Adds auto-remove subject behavior to a relation.\r\n * @template T\r\n * @param {Relation<T>} relation - The relation to modify.\r\n * @returns {Relation<T>} The modified relation.\r\n */\r\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\r\n    const ctx = relation[$relationData] as RelationData<T>\r\n    ctx.autoRemoveSubject = true\r\n    return relation\r\n}\r\n\r\n/**\r\n * Adds an onTargetRemoved callback to a relation.\r\n * @template T\r\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\r\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\r\n */\r\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\r\n    const ctx = relation[$relationData] as RelationData<T>\r\n    ctx.onTargetRemoved = onRemove\r\n    return relation\r\n}\r\n\r\n// TODO: withSetter\r\n/**\r\n * Adds validation to a relation.\r\n * @template T\r\n * @param {function(T): boolean} validateFn - The validation function.\r\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\r\n */\r\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\r\n    const originalRelation = relation\r\n    return ((target: RelationTarget): T => {\r\n        const component = originalRelation(target)\r\n        if (!validateFn(component)) {\r\n            throw new Error('Validation failed for relation component')\r\n        }\r\n        return component\r\n    }) as Relation<T>\r\n}\r\n\r\n/**\r\n * Creates a pair from a relation and a target.\r\n * @template T\r\n * @param {Relation<T>} relation - The relation.\r\n * @param {RelationTarget} target - The target.\r\n * @returns {T} The created pair.\r\n * @throws {Error} If the relation is undefined.\r\n */\r\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\r\n    if (relation === undefined) throw Error('Relation is undefined')\r\n    return relation(target)\r\n}\r\n\r\n/**\r\n * Gets the relation targets for an entity.\r\n * @param {World} world - The world object.\r\n * @param {Relation<any>} relation - The relation to get targets for.\r\n * @param {number} eid - The entity ID.\r\n * @returns {Array<any>} An array of relation targets.\r\n */\r\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>): number[] => {\r\n\tconst components = getEntityComponents(world, eid)\r\n\tconst targets = []\r\n\tfor (const c of components) {\r\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard && !isRelation(c[$pairTarget])) {\r\n\t\t\ttargets.push(c[$pairTarget])\r\n\t\t}\r\n\t}\r\n\treturn targets\r\n}\r\n\r\n/**\r\n * Creates a new relation.\r\n * @template T\r\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\r\n * @returns {Relation<T>} The created relation.\r\n */\r\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\r\n\r\n/**\r\n * Creates a new relation with options.\r\n * @template T\r\n * @param {Object} options - Options for creating the relation.\r\n * @param {function(): T} [options.store] - Function to create the store.\r\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\r\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\r\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\r\n * @returns {Relation<T>} The created relation.\r\n */\r\nexport function createRelation<T>(options: {\r\n    store?: () => T\r\n    exclusive?: boolean\r\n    autoRemoveSubject?: boolean\r\n    onTargetRemoved?: OnTargetRemovedCallback\r\n}): Relation<T>\r\nexport function createRelation<T>(\r\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\r\n        store?: () => T\r\n        exclusive?: boolean\r\n        autoRemoveSubject?: boolean\r\n        onTargetRemoved?: OnTargetRemovedCallback\r\n    }]\r\n): Relation<T> {\r\n    if (args.length === 1 && typeof args[0] === 'object') {\r\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\r\n        const modifiers = [\r\n            store && withStore(store),\r\n            exclusive && makeExclusive,\r\n            autoRemoveSubject && withAutoRemoveSubject,\r\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\r\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\r\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\r\n    } else {\r\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\r\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\r\n    }\r\n}\r\n\r\n/**\r\n * Symbol used to mark a relation as a wildcard relation\r\n */\r\nexport const $wildcard = Symbol.for('bitecs-wildcard')\r\n\r\n/**\r\n * Creates a wildcard relation that matches any target.\r\n * @template T\r\n * @returns {Relation<T>} The created wildcard relation.\r\n */\r\nexport function createWildcardRelation<T>(): Relation<T> {\r\n    const relation = createBaseRelation<T>()\r\n    Object.defineProperty(relation, $wildcard, {\r\n        value: true,\r\n        enumerable: false,\r\n        writable: false,\r\n        configurable: false\r\n    })\r\n    return relation\r\n}\r\n\r\n/**\r\n * Gets the singleton wildcard instance.\r\n * @returns {Relation<any>} The global wildcard relation instance.\r\n */\r\nexport function getWildcard(): Relation<any> {\r\n    const GLOBAL_WILDCARD = Symbol.for('bitecs-global-wildcard')\r\n    \r\n    if (!(globalThis as any)[GLOBAL_WILDCARD]) {\r\n        (globalThis as any)[GLOBAL_WILDCARD] = createWildcardRelation()\r\n    }\r\n    \r\n    return (globalThis as any)[GLOBAL_WILDCARD]\r\n}\r\n\r\n/**\r\n * Wildcard relation.\r\n * @type {Relation<any>}\r\n */\r\nexport const Wildcard = getWildcard()\r\n\r\n/**\r\n * Creates an IsA relation.\r\n * @template T\r\n * @returns {Relation<T>} The created IsA relation.\r\n */\r\nexport function createIsARelation<T>(): Relation<T> {\r\n    return createBaseRelation<T>()\r\n}\r\n\r\n/**\r\n * Gets the singleton IsA instance.\r\n * @returns {Relation<any>} The global IsA relation instance.\r\n */\r\nexport function getIsA(): Relation<any> {\r\n    const GLOBAL_ISA = Symbol.for('bitecs-global-isa')\r\n    \r\n    if (!(globalThis as any)[GLOBAL_ISA]) {\r\n        (globalThis as any)[GLOBAL_ISA] = createIsARelation()\r\n    }\r\n    \r\n    return (globalThis as any)[GLOBAL_ISA]\r\n}\r\n\r\n/**\r\n * IsA relation.\r\n * @type {Relation<any>}\r\n */\r\nexport const IsA = getIsA()\r\n\r\n/**\r\n * Checks if a relation is a wildcard relation.\r\n * @param {any} relation - The relation to check.\r\n * @returns {boolean} True if the relation is a wildcard relation, false otherwise.\r\n */\r\nexport function isWildcard(relation: any): boolean {\r\n    if (!relation) return false\r\n    const symbols = Object.getOwnPropertySymbols(relation)\r\n    return symbols.includes($wildcard)\r\n}\r\n\r\n/**\r\n * Checks if a component is a relation.\r\n * @param {any} component - The component to check.\r\n * @returns {boolean} True if the component is a relation, false otherwise.\r\n */\r\nexport function isRelation(component: any): boolean {\r\n    if (!component) return false\r\n    const symbols = Object.getOwnPropertySymbols(component)\r\n    return symbols.includes($relationData)\r\n}\r\n", "import { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\r\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\r\nimport { Query } from './Query'\r\nimport {\r\n\tIsA,\r\n\tPair,\r\n\tWildcard,\r\n\tgetRelationTargets,\r\n\t$relationData,\r\n\t$isPairComponent,\r\n\t$pairTarget,\r\n\t$relation\r\n} from './Relation'\r\nimport { createObservable, Observable } from './utils/Observer'\r\nimport { $internal, InternalWorld, World, WorldContext } from './World'\r\n\r\n/**\r\n * Represents a reference to a component.\r\n * @typedef {any} ComponentRef\r\n */\r\nexport type ComponentRef = any\r\n\r\n/**\r\n * Represents the data associated with a component.\r\n * @interface ComponentData\r\n * @property {number} id - The unique identifier for the component.\r\n * @property {number} generationId - The generation ID of the component.\r\n * @property {number} bitflag - The bitflag used for component masking.\r\n * @property {ComponentRef} ref - Reference to the component.\r\n * @property {Set<Query>} queries - Set of queries associated with the component.\r\n * @property {Observable} setObservable - Observable for component changes.\r\n */\r\nexport interface ComponentData {\r\n\tid: number\r\n\tgenerationId: number\r\n\tbitflag: number\r\n\tref: ComponentRef\r\n\tqueries: Set<Query>\r\n\tsetObservable: Observable\r\n\tgetObservable: Observable\r\n}\r\n\r\n/**\r\n * Registers a component with the world.\r\n * @param {World} world - The world object.\r\n * @param {ComponentRef} component - The component to register.\r\n * @returns {ComponentData} The registered component data.\r\n * @throws {Error} If the component is null or undefined.\r\n */\r\nexport const registerComponent = (world: World, component: ComponentRef) => {\r\n\tif (!component) {\r\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\r\n\t}\r\n\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst queries = new Set<Query>()\r\n\r\n\tconst data: ComponentData = {\r\n\t\tid: ctx.componentCount++,\r\n\t\tgenerationId: ctx.entityMasks.length - 1,\r\n\t\tbitflag: ctx.bitflag,\r\n\t\tref: component,\r\n\t\tqueries,\r\n\t\tsetObservable: createObservable(),\r\n\t\tgetObservable: createObservable(),\r\n\t}\r\n\r\n\tctx.componentMap.set(component, data)\r\n\r\n\tctx.bitflag *= 2\r\n\tif (ctx.bitflag >= 2 ** 31) {\r\n\t\tctx.bitflag = 1\r\n\t\tctx.entityMasks.push([])\r\n\t}\r\n\r\n\treturn data\r\n}\r\n\r\n/**\r\n * Registers multiple components with the world.\r\n * @param {World} world - The world object.\r\n * @param {ComponentRef[]} components - Array of components to register.\r\n */\r\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\r\n\tcomponents.forEach((component) => registerComponent(world, component))\r\n}\r\n\r\n/**\r\n * Checks if an entity has a specific component.\r\n * @param {World} world - The world object.\r\n * @param {number} eid - The entity ID.\r\n * @param {ComponentRef} component - The component to check for.\r\n * @returns {boolean} True if the entity has the component, false otherwise.\r\n */\r\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst registeredComponent = ctx.componentMap.get(component)\r\n\tif (!registeredComponent) return false\r\n\r\n\tconst { generationId, bitflag } = registeredComponent\r\n\tconst mask = ctx.entityMasks[generationId][eid]\r\n\r\n\treturn (mask & bitflag) === bitflag\r\n}\r\n/**\r\n * Retrieves the data associated with a component for a specific entity.\r\n * @param {World} world - The world object.\r\n * @param {EntityId} eid - The entity ID.\r\n * @param {ComponentRef} component - The component to retrieve data for.\r\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\r\n */\r\nexport const getComponentData = (world: World, eid: EntityId, component: ComponentRef): any => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst componentData = ctx.componentMap.get(component)\r\n\r\n\tif (!componentData) {\r\n\t\treturn undefined\r\n\t}\r\n\r\n\tif (!hasComponent(world, eid, component)) {\r\n\t\treturn undefined\r\n\t}\r\n\r\n\t// Notify observers that this component is being accessed\r\n\treturn componentData.getObservable.notify(eid)\r\n}\r\n\r\n/**\r\n * Helper function to set component data.\r\n * @param {ComponentRef} component - The component to set.\r\n * @param {any} data - The data to set for the component.\r\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\r\n */\r\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\r\n\tcomponent,\r\n\tdata\r\n})\r\n\r\n/**\r\n * Recursvely inherits components from one entity to another.\r\n * @param {World} world - The world object.\r\n * @param {number} baseEid - The ID of the entity inheriting components.\r\n * @param {number} inheritedEid - The ID of the entity being inherited from.\r\n * @param {boolean} isFirstSuper - Whether this is the first super in the inheritance chain.\r\n */\r\nconst recursivelyInherit = (ctx: WorldContext, world: World, baseEid: EntityId, inheritedEid: EntityId, visited = new Set<EntityId>()): void => {\r\n\t// Guard against circular inheritance\r\n\tif (visited.has(inheritedEid)) return\r\n\tvisited.add(inheritedEid)\r\n\t\r\n\t// Add IsA relation first\r\n\taddComponent(world, baseEid, IsA(inheritedEid))\r\n\t\r\n\t// Copy components and their data from this level\r\n\t// This needs to happen before recursing to ancestors so closer ancestors take precedence\r\n\tfor (const component of getEntityComponents(world, inheritedEid)) {\r\n\t\t// TODO: inherit reference vs copy\r\n\t\tif (component === Prefab) continue\r\n\t\t\r\n\t\t// Only add component if entity doesn't already have it\r\n\t\t// This ensures closer ancestors take precedence\r\n\t\tif (!hasComponent(world, baseEid, component)) {\r\n\t\t\taddComponent(world, baseEid, component)\r\n\t\t\t\r\n\t\t\tconst componentData = ctx.componentMap.get(component)\r\n\t\t\tif (componentData?.setObservable) {\r\n\t\t\t\tconst data = getComponentData(world, inheritedEid, component)\r\n\t\t\t\tcomponentData.setObservable.notify(baseEid, data)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Then recursively inherit from ancestors\r\n\t// This ensures more distant ancestors don't override closer ones\r\n\tfor (const parentEid of getRelationTargets(world, inheritedEid, IsA)) {\r\n\t\trecursivelyInherit(ctx, world, baseEid, parentEid, visited)\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents a component with data to be set on an entity.\r\n */\r\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\r\n\r\n/**\r\n * Adds one or more components to an entity.\r\n * @param {World} world - The world object.\r\n * @param {EntityId} eid - The entity ID.\r\n * @param {...(ComponentRef | ComponentSetter)} components - Components to add or set.\r\n * @throws {Error} If the entity does not exist in the world.\r\n */\r\nexport const addComponent = (world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void => {\r\n\tif (!entityExists(world, eid)) {\r\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\r\n\t}\r\n\t\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\t\r\n\tcomponents.forEach(componentOrSet => {\r\n\t\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\r\n\t\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\r\n\r\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\r\n\r\n\t\tconst componentData = ctx.componentMap.get(component)!\r\n\t\tif (data !== undefined) {\r\n\t\t\tcomponentData.setObservable.notify(eid, data)\r\n\t\t}\r\n\r\n\t\tif (hasComponent(world, eid, component)) return\r\n\r\n\t\tconst { generationId, bitflag, queries } = componentData\r\n\r\n\t\tctx.entityMasks[generationId][eid] |= bitflag\r\n\r\n\t\tif (!hasComponent(world, eid, Prefab)) {\r\n\t\t\tqueries.forEach((queryData: Query) => {\r\n\t\t\t\tqueryData.toRemove.remove(eid)\r\n\t\t\t\tconst match = queryCheckEntity(world, queryData, eid)\r\n\r\n\t\t\t\tif (match) queryAddEntity(queryData, eid)\r\n\t\t\t\telse queryRemoveEntity(world, queryData, eid)\r\n\t\t\t})\r\n\t\t}\r\n\t\tctx.entityComponents.get(eid)!.add(component)\r\n\t\tif (component[$isPairComponent]) {\r\n\t\t\tconst relation = component[$relation]\r\n\t\t\tconst target = component[$pairTarget]\r\n\r\n\t\t\t// Add both Wildcard pairs for relation and target\r\n\t\t\taddComponent(world, eid, Pair(relation, Wildcard))\r\n\t\t\taddComponent(world, eid, Pair(Wildcard, target))\r\n\r\n\t\t\t// For non-Wildcard targets, add Wildcard pair to track relation targets\r\n\t\t\tif (typeof target === 'number') {\r\n\t\t\t\t// Add Wildcard pair for target being a relation target\r\n\t\t\t\taddComponent(world, target, Pair(Wildcard, eid))\r\n\t\t\t\taddComponent(world, target, Pair(Wildcard, relation))\r\n\t\t\t\t// Track entities with relations for autoRemoveSubject\r\n\t\t\t\tctx.entitiesWithRelations.add(target)\r\n\t\t\t\tctx.entitiesWithRelations.add(eid)\r\n\t\t\t}\r\n\r\n\t\t\t// add target to a set to make autoRemoveSubject checks faster\r\n\t\t\tctx.entitiesWithRelations.add(target)\r\n\r\n\t\t\tconst relationData = relation[$relationData]\r\n\t\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\r\n\t\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\r\n\t\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\r\n\t\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (relation === IsA) {\r\n\t\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\r\n\t\t\t\tfor (const inherited of inheritedTargets) {\r\n\t\t\t\t\trecursivelyInherit(ctx, world, eid, inherited)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n}\r\n\r\n/**\r\n * Alias for addComponent.\r\n */\r\nexport const addComponents = addComponent\r\n\r\n/**\r\n * Removes one or more components from an entity.\r\n * @param {World} world - The world object.\r\n * @param {number} eid - The entity ID.\r\n * @param {...ComponentRef} components - Components to remove.\r\n * @throws {Error} If the entity does not exist in the world.\r\n */\r\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tif (!entityExists(world, eid)) {\r\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\r\n\t}\r\n\r\n\tcomponents.forEach(component => {\r\n\t\tif (!hasComponent(world, eid, component)) return\r\n\r\n\t\tconst componentNode = ctx.componentMap.get(component)!\r\n\t\tconst { generationId, bitflag, queries } = componentNode\r\n\r\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\r\n\r\n\t\tqueries.forEach((queryData: Query) => {\r\n\t\t\tqueryData.toRemove.remove(eid)\r\n\r\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\r\n\r\n\t\t\tif (match) queryAddEntity(queryData, eid)\r\n\t\t\telse queryRemoveEntity(world, queryData, eid)\r\n\t\t})\r\n\r\n\t\tctx.entityComponents.get(eid)!.delete(component)\r\n\r\n\t\tif (component[$isPairComponent]) {\r\n\t\t\tconst target = component[$pairTarget]\r\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\r\n\r\n\t\t\tconst relation = component[$relation]\r\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\r\n\t\t\tif (otherTargets.length === 0) {\r\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n}\r\n\r\n/**\r\n * Alias for removeComponent.\r\n */\r\nexport const removeComponents = removeComponent\r\n", "import { addComponent, removeComponent } from './Component'\r\nimport {\r\n\tinnerQuery,\r\n\tqueryAddEntity,\r\n\tqueryCheckEntity,\r\n\tqueryRemoveEntity,\r\n} from './Query'\r\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\r\nimport { World } from \"./World\"\r\nimport { InternalWorld } from './World'\r\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\r\nimport { $internal } from './World'\r\nimport { ComponentRef } from './Component'\r\n\r\nexport type EntityId = number\r\n\r\nexport const Prefab = {}\r\nexport const addPrefab = (world: World): EntityId => {\r\n\tconst eid = addEntity(world)\r\n\r\n\taddComponent(world, eid, Prefab)\r\n\r\n\treturn eid\r\n}\r\n\r\n/**\r\n * Adds a new entity to the specified world.\r\n *\r\n * @param {World} world\r\n * @returns {number} eid\r\n */\r\nexport const addEntity = (world: World): EntityId => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tconst eid = addEntityId(ctx.entityIndex)\r\n\r\n\tctx.notQueries.forEach((q) => {\r\n\t\tconst match = queryCheckEntity(world, q, eid)\r\n\t\tif (match) queryAddEntity(q, eid)\r\n\t})\r\n\r\n\tctx.entityComponents.set(eid, new Set())\r\n\r\n\treturn eid\r\n}\r\n\r\n/**\r\n * Removes an existing entity from the specified world.\r\n *\r\n * @param {World} world\r\n * @param {number} eid\r\n */\r\n\r\nexport const removeEntity = (world: World, eid: EntityId) => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\t// Check if entity is already removed\r\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\r\n\r\n\t// Remove relation components from entities that have a relation to this one, breadth-first\r\n\t// e.g. addComponent(world, child, ChildOf(parent))\r\n\t// when parent is removed, we need to remove the child\r\n\tconst removalQueue = [eid]\r\n\tconst processedEntities = new Set()\r\n    while (removalQueue.length > 0) {\r\n        \r\n\t\tconst currentEid = removalQueue.shift()!\r\n        if (processedEntities.has(currentEid)) continue\r\n        processedEntities.add(currentEid)\r\n\r\n        const componentRemovalQueue = []\r\n\r\n\t\tif (ctx.entitiesWithRelations.has(currentEid)) {\r\n\t\t\tfor (const subject of innerQuery(world, [Wildcard(currentEid)])) {\r\n\t\t\t\tif (!entityExists(world, subject)) {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (const component of ctx.entityComponents.get(subject)!) {\r\n\t\t\t\t\tif (!component[$isPairComponent]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst relation = component[$relation]\r\n\t\t\t\t\tconst relationData = relation[$relationData]\r\n\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\r\n\r\n\t\t\t\t\tif (component[$pairTarget] === currentEid) {\r\n\t\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, component))\r\n\t\t\t\t\t\tif (relationData.autoRemoveSubject) {\r\n\t\t\t\t\t\t\tremovalQueue.push(subject)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (relationData.onTargetRemoved) {\r\n\t\t\t\t\t\t\tcomponentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.entitiesWithRelations.delete(currentEid)\r\n\t\t}\r\n\r\n        for (const removeOperation of componentRemovalQueue) {\r\n            removeOperation()\r\n        }\r\n\r\n\t\tfor (const eid of removalQueue) {\r\n\t\t\tremoveEntity(world, eid)\r\n\t\t}\r\n\r\n\t\t// Remove entity from all queries\r\n\t\tfor (const query of ctx.queries) {\r\n\t\t\tqueryRemoveEntity(world, query, currentEid)\r\n\t\t}\r\n\r\n\t\t// Free the entity ID\r\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\r\n\r\n\t\t// Remove all entity state from world\r\n\t\tctx.entityComponents.delete(currentEid)\r\n\r\n\t\t// Clear entity bitmasks\r\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\r\n\t\t\tctx.entityMasks[i][currentEid] = 0\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n *  Returns an array of components that an entity possesses.\r\n *\r\n * @param {*} world\r\n * @param {*} eid\r\n */\r\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\r\n\tconst ctx = (world as InternalWorld)[$internal]\r\n\tif (eid === undefined) throw new Error(`getEntityComponents: entity id is undefined.`)\r\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\r\n\t\tthrow new Error(`getEntityComponents: entity ${eid} does not exist in the world.`)\r\n\treturn Array.from(ctx.entityComponents.get(eid)!)\r\n}\r\n\r\n/**\r\n * Checks the existence of an entity in a world\r\n *\r\n * @param {World} world\r\n * @param {number} eid\r\n */\r\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\r\n", "type Func = (...args: any) => any\r\nexport const pipe = <T extends Func, U extends Func, R extends Func>\r\n    (...functions: [T, ...U[], R]): ((...args: Parameters<T>) => ReturnType<R>) => {\r\n    return (...args: Parameters<T>): ReturnType<R> => \r\n        functions.reduce((result, fn) => [fn(...result)], args as any)[0]\r\n}\r\n"],
  "mappings": "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",
  "names": ["defineHiddenProperty", "obj", "key", "value", "getId", "index", "id", "getVersion", "incrementVersion", "newVersion", "withVersioning", "versionBits", "createEntityIndex", "options", "config", "versioning", "entityBits", "entityMask", "versionShift", "versionMask", "addEntityId", "recycledId", "entityId", "removeEntityId", "denseIndex", "lastIndex", "lastId", "newId", "isEntityIdAlive", "$internal", "createBaseWorld", "context", "entityIndex", "defineHiddenProperty", "createEntityIndex", "createWorld", "args", "arg", "resetWorld", "world", "ctx", "deleteWorld", "getWorldComponents", "getAllEntities", "createSparseSet", "dense", "sparse", "has", "val", "index", "swapped", "SharedArrayBufferOrArrayBuffer", "createUint32SparseSet", "initialCapacity", "length", "newDense", "createObservable", "observers", "observer", "entity", "args", "acc", "listener", "result", "$opType", "$opTerms", "Or", "components", "And", "Not", "Any", "All", "None", "onAdd", "terms", "onRemove", "onSet", "component", "onGet", "observe", "world", "hook", "callback", "ctx", "$internal", "type", "hash", "queryHash", "queryData", "registerQuery", "componentData", "registerComponent", "getComponentId", "termToString", "term", "sortedComponentIds", "a", "b", "options", "notComponents", "orComponents", "processComponents", "comps", "targetArray", "comp", "mapComponents", "allComponents", "sparseSet", "createUint32SparseSet", "createSparseSet", "toRemove", "generations", "v", "reduceBitflags", "c", "masks", "notMasks", "orMasks", "hasMasks", "addObservable", "createObservable", "removeObservable", "query", "entityIndex", "i", "eid", "hasComponent", "Prefab", "queryCheckEntity", "queryAddEntity", "innerQuery", "commitRemovals", "queryCheckEntity", "world", "query", "eid", "ctx", "$internal", "masks", "notMasks", "orMasks", "generations", "i", "generationId", "qMask", "qNotMask", "qOrMask", "eMask", "queryAddEntity", "query", "eid", "queryCommitRemovals", "i", "commitRemovals", "world", "ctx", "$internal", "queryRemoveEntity", "removeQuery", "terms", "hash", "queryHash", "$relation", "$pairTarget", "$isPairComponent", "$relationData", "createBaseRelation", "data", "relation", "target", "normalizedTarget", "Wildcard", "component", "defineHiddenProperty", "withStore", "createStore", "ctx", "makeExclusive", "withAutoRemoveSubject", "withOnTargetRemoved", "onRemove", "Pair", "relation", "target", "getRelationTargets", "world", "eid", "components", "getEntityComponents", "targets", "c", "$relation", "$pairTarget", "Wildcard", "isRelation", "createRelation", "args", "store", "exclusive", "autoRemoveSubject", "onTargetRemoved", "withStore", "makeExclusive", "withAutoRemoveSubject", "withOnTargetRemoved", "acc", "modifier", "createBaseRelation", "$wildcard", "createWildcardRelation", "getWildcard", "GLOBAL_WILDCARD", "createIsARelation", "getIsA", "GLOBAL_ISA", "IsA", "isWildcard", "component", "$relationData", "registerComponent", "world", "component", "ctx", "$internal", "queries", "data", "createObservable", "registerComponents", "components", "hasComponent", "eid", "registeredComponent", "generationId", "bitflag", "getComponentData", "componentData", "set", "recursivelyInherit", "baseEid", "inheritedEid", "visited", "addComponent", "IsA", "getEntityComponents", "Prefab", "parentEid", "getRelationTargets", "entityExists", "componentOrSet", "queryData", "queryCheckEntity", "queryAddEntity", "queryRemoveEntity", "$isPairComponent", "relation", "$relation", "target", "$pairTarget", "Pair", "Wildcard", "$relationData", "oldTarget", "removeComponent", "inheritedTargets", "inherited", "addComponents", "componentNode", "removeComponents", "Prefab", "addPrefab", "world", "eid", "addEntity", "addComponent", "ctx", "$internal", "addEntityId", "q", "queryCheckEntity", "queryAddEntity", "removeEntity", "isEntityIdAlive", "removalQueue", "processedEntities", "currentEid", "componentRemovalQueue", "subject", "innerQuery", "Wildcard", "entityExists", "component", "$isPairComponent", "relationData", "$relation", "$relationData", "removeComponent", "Pair", "$pairTarget", "removeOperation", "query", "queryRemoveEntity", "removeEntityId", "i", "getEntityComponents", "pipe", "functions", "args", "result", "fn"]
}
