{
  "version": 3,
  "sources": ["../../src/core/index.ts", "../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/SparseSet.ts", "../../src/core/utils/Observer.ts", "../../src/core/Query.ts", "../../src/core/Relation.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/core/utils/pipe.ts"],
  "sourcesContent": ["export {\n\tcreateWorld,\n\tresetWorld,\n\tgetWorldComponents,\n\tgetAllEntities,\n\t$internal,\n\twithContext,\n\twithEntityIndex\n} from './World'\n\nexport type {\n\tWorld,\n\tInternalWorld,\n\tWorldContext\n} from './World'\n\nexport {\n\taddEntity,\n\tremoveEntity,\n\tgetEntityComponents,\n\tentityExists,\n\tPrefab,\n} from './Entity'\n\nexport {\n\tregisterComponent,\n\tregisterComponents,\n\thasComponent,\n\taddComponent,\n\taddComponents,\n\tremoveComponent,\n\tremoveComponents,\n} from './Component'\n\nexport type {\n\tComponentRef,\n\tComponentData\n} from './Component'\n\nexport {\n\tcommitRemovals,\n\tremoveQuery,\n\tregisterQuery,\n\tinnerQuery,\n\tquery,\n\tobserve,\n\tonAdd,\n\tonRemove,\n\tObservableHook,\n\tQueryResult,\n\tQuery,\n\tQueryOperatorType,\n\tOpReturnType,\n\tQueryOperator,\n\tQueryTerm,\n\tOrOp,\n\tAndOp,\n\tNotOp,\n\tAnyOp,\n\tAllOp,\n\tNoneOp,\n\tOr,\n\tAnd,\n\tNot,\n\tAny,\n\tAll,\n\tNone\n} from './Query'\n\nexport { pipe } from './utils/pipe'\n\nexport * from './Relation'\n\nexport { createEntityIndex } from './EntityIndex'\n", "export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "export type EntityIndex = {\n    aliveCount: number\n    dense: number[]\n    sparse: number[]\n    maxId: number\n}\n\nexport const createEntityIndex = (): EntityIndex => ({\n    aliveCount: 0,\n    dense: [],\n    sparse: [],\n    maxId: 0,\n})\n\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount]\n        index.sparse[recycledId] = index.aliveCount\n        index.aliveCount++\n        return recycledId\n    }\n\n    // Create new id\n    const id = ++index.maxId\n    index.dense.push(id)\n    index.sparse[id] = index.aliveCount\n    index.aliveCount++\n\n    return id\n}\n\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const record = index.sparse[id]\n    if (record === undefined || record >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return\n    }\n\n    const denseIndex = record\n    const lastIndex = index.aliveCount - 1\n    const lastId = index.dense[lastIndex]\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex\n    index.dense[denseIndex] = lastId\n\n    // Update the removed entity's record\n    index.sparse[id] = index.dense.length\n    index.dense[lastIndex] = id\n\n    index.aliveCount--\n}\n\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const record = index.sparse[id]\n    return record !== undefined && index.dense[record] === id\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query } from './Query'\n\nexport const $internal = Symbol('internal')\n\nexport type WorldContext = {\n\tentityIndex: EntityIndex\n\tentityMasks: number[][]\n\tentityComponents: Map<number, Set<ComponentRef>>\n\tbitflag: number\n\tcomponentMap: WeakMap<ComponentRef, ComponentData>\n\tcomponentCount: number\n\tqueries: Set<Query>\n\tqueriesHashMap: Map<string, Query>\n\tnotQueries: Set<any>\n\tdirtyQueries: Set<any>\n}\n\nexport type InternalWorld = {\n\t[$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = T\ntype WorldModifier<T> = (world: World) => World & T\n\nconst createBaseWorld = (context?: object): World => {\n    const worldContext: WorldContext = {\n        entityIndex: createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new WeakMap(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n    }\n\n    const world = context || {}\n    defineHiddenProperty(world, $internal, worldContext)\n    return world as World\n}\n\nexport const withEntityIndex = (entityIndex: EntityIndex): WorldModifier<{}> => \n    (world: World) => {\n        const ctx = (world as InternalWorld)[$internal]\n        ctx.entityIndex = entityIndex\n        return world\n    }\n\nexport const withContext = <T extends object>(context: T): WorldModifier<T> =>\n    (world: World) => {\n        return Object.assign(context, world) as World & T\n    }\n\nexport const createWorld = <T extends object = {}>(\n    ...args: Array<WorldModifier<any> | {\n        entityIndex?: EntityIndex\n        context?: T\n    }>\n): World<T> => {\n    const processInputs = (inputs: typeof args) => {\n        let context: T | undefined\n        const modifiers: Array<WorldModifier<any>> = []\n\n        inputs.forEach(arg => {\n            if (typeof arg === 'object' && !Array.isArray(arg) && !(arg instanceof Function)) {\n                const { entityIndex, context: ctx } = arg\n                if (entityIndex) modifiers.push(withEntityIndex(entityIndex))\n                if (ctx) context = ctx\n            } else if (typeof arg === 'function') {\n                modifiers.push(arg as WorldModifier<any>)\n            }\n        })\n\n        return { context, modifiers }\n    }\n\n    const { context, modifiers } = processInputs(args)\n    const baseWorld = createBaseWorld(context)\n\n    return modifiers.reduce((world, modifier) => modifier(world), baseWorld) as World<T>\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tctx.entityIndex = createEntityIndex()\n\tctx.entityMasks = [[]]\n\tctx.entityComponents = new Map()\n\tctx.bitflag = 1\n\tctx.componentMap = new Map()\n\tctx.componentCount = 0\n\tctx.queries = new Set()\n\tctx.queriesHashMap = new Map()\n\tctx.notQueries = new Set()\n\tctx.dirtyQueries = new Set()\n\treturn world\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) => \n\tObject.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World) => (world as InternalWorld)[$internal].entityIndex.dense.slice(0)\n", "export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n}\n\nexport const createSparseSet = () => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t}\n}\n\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(initialCapacity)\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(dense.length * 2)\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t}\n};", "export type Observer = (entity: number, ...args: any[]) => void\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: number, ...args: any[])  => void\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n\n  const notify = (entity: number, ...args: any[]) => {\n    observers.forEach((listener) => listener(entity, ...args))\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { Prefab } from './Entity'\n\nexport type QueryResult = Uint32Array | readonly number[]\n\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: { [key: number]: number }\n\torMasks: { [key: number]: number }\n\tnotMasks: { [key: number]: number }\n\thasMasks: { [key: number]: number }\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n}\n\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n\nexport type OpReturnType = {\n    type: QueryOperatorType\n    components: ComponentRef[]\n}\n\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\nexport type QueryTerm = ComponentRef | QueryOperator\n\n// Aliases\nexport type OrOp = QueryOperator\nexport type AndOp = QueryOperator\nexport type NotOp = QueryOperator\nexport type AnyOp = OrOp\nexport type AllOp = AndOp\nexport type NoneOp = NotOp\n\nexport type ObservableHook = (...components: ComponentRef[]) => {\n\ttype: 'add' | 'remove' | 'set'\n\tcomponents: ComponentRef[]\n}\n\nexport const onAdd: ObservableHook = (...components: ComponentRef[]) => ({ type: 'add', components })\nexport const onRemove: ObservableHook = (...components: ComponentRef[]) => ({ type: 'remove', components })\nexport const onSet: ObservableHook = (...components: ComponentRef[]) => ({ type: 'set', components })\n\nexport const set = <T>(world: World, eid: number, component: ComponentRef, params: T): void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tlet componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\tregisterComponent(world, component)\n\t\tcomponentData = ctx.componentMap.get(component)\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\tthrow new Error(`Entity ${eid} does not have component ${component.name}`)\n\t}\n\n\tcomponentData.setObservable.notify(eid, params)\n\n\treturn component\n}\n\n\nexport const observe = (world: World, hook: ReturnType<typeof onAdd | typeof onRemove>, callback: (eid: number) => void): () => void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { type, components } = hook\n\tconst hash = queryHash(world, components)\n\tlet queryData = ctx.queriesHashMap.get(hash)!\n\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, components)\n\t}\n\n\tconst observableKey = type === 'add' ? 'addObservable' : type === 'remove' ? 'removeObservable' : 'setObservable'\n\n\tconst unsubscribe = queryData[observableKey].subscribe(callback)\n\n\treturn unsubscribe\n}\n\nexport const Or: OrOp = (...components: ComponentRef[]) => ({\n\ttype: 'Or',\n\tcomponents\n})\n\nexport const And: AndOp = (...components: ComponentRef[]) => ({\n\ttype: 'And',\n\tcomponents\n})\n\nexport const Not: NotOp = (...components: ComponentRef[]) => ({\n\ttype: 'Not',\n\tcomponents\n})\n\nexport const Any: AnyOp = Or\nexport const All: AllOp = And\nexport const None: NoneOp = Not\n\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n    const ctx = (world as InternalWorld)[$internal]\n\n    const getComponentId = (component: ComponentRef): number => {\n        if (!ctx.componentMap.has(component)) {\n            registerComponent(world, component)\n        }\n        return ctx.componentMap.get(component)!.id\n    }\n\n    const termToString = (term: QueryTerm): string => {\n        if ('type' in term) {\n            const componentIds = term.components.map(getComponentId)\n            const sortedComponentIds = componentIds.sort((a, b) => a - b)\n            const sortedType = term.type.toLowerCase()\n            return `${sortedType}(${sortedComponentIds.join(',')})`\n        } else {\n            return getComponentId(term).toString()\n        }\n    }\n\n    return terms\n        .map(termToString)\n        .sort()\n        .join('-')\n}\n\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\t// if (ctx.queriesHashMap.has(hash)) {\n\t// \treturn ctx.queriesHashMap.get(hash)!\n\t// }\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst processComponents = (comps: ComponentRef[], targetArray: ComponentRef[]) => {\n\t\tcomps.forEach((comp: ComponentRef) => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\ttargetArray.push(comp)\n\t\t})\n\t}\n\n\tterms.forEach((term: QueryTerm) => {\n\t\tif ('type' in term) {\n\t\t\tif (term.type === 'Not') {\n\t\t\t\tprocessComponents(term.components, notComponents)\n\t\t\t} else if (term.type === 'Or') {\n\t\t\t\tprocessComponents(term.components, orComponents)\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst mapComponents = (c: ComponentRef) => ctx.componentMap.get(c)!\n\tconst allComponents = components.concat(notComponents).concat(orComponents.flat()).map(mapComponents)\n\n\tconst sparseSet = options.buffered ? createUint32SparseSet() : createSparseSet()\n\n\tconst toRemove = createSparseSet()\n\n\tconst generations = allComponents\n\t\t.map((c) => c.generationId)\n\t\t.reduce((a, v) => {\n\t\t\tif (a.includes(v)) return a\n\t\t\ta.push(v)\n\t\t\treturn a\n\t\t}, [] as number[])\n\n\tconst reduceBitflags = (a: { [key:number]: number }, c: ComponentData) => {\n\t\tif (!a[c.generationId]) a[c.generationId] = 0\n\t\ta[c.generationId] |= c.bitflag\n\t\treturn a\n\t}\n\n\tconst masks = components.map(mapComponents).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponents.reduce(reduceBitflags, {})\n\n\tconst addObservable = createObservable()\n\tconst removeObservable = createObservable()\n\n\tconst query = Object.assign(sparseSet, {\n\t\tcomponents,\n\t\tnotComponents,\n\t\torComponents,\n\t\tallComponents,\n\t\tmasks,\n\t\tnotMasks,\n\t\torMasks,\n\t\thasMasks,\n\t\tgenerations,\n\t\ttoRemove,\n\t\taddObservable,\n\t\tremoveObservable,\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponents.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, Prefab, eid)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\nexport function innerQuery(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\treturn queryData.dense\n}\n\nexport function query(world: World, terms: QueryTerm[]): readonly number[] {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms) as number[]\n}\n\nexport function bufferQuery(world: World, terms: QueryTerm[]): Uint32Array {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms, { buffered: true }) as Uint32Array\n}\n\nexport function queryCheckEntity(world: World, query: Query, eid: number): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) === 0) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\nexport const queryAddEntity = (query: Query, eid: number) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\nexport const queryRemoveEntity = (world: World, query: Query, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { getEntityComponents, World } from '.'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\nexport type OnTargetRemovedCallback = (subject: number, target: number | string) => void\nexport type RelationTarget = number | '*' | typeof Wildcard\n\nexport const $relation = Symbol('relation')\nexport const $pairTarget = Symbol('pairTarget')\nexport const $isPairComponent = Symbol('isPairComponent')\n\nexport const $relationData = Symbol('relationData')\n\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: () => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\nexport type Relation<T> = (target: RelationTarget) => T\n\n// Base relation creation\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n// Modifiers\nexport const withStore = <T>(createStore: () => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n\n    return ((target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n\n        if (!ctx.pairsMap.has(normalizedTarget)) {\n            const component = createStore()\n            defineHiddenProperty(component, $relationData, {\n                pairTarget: normalizedTarget,\n                ...ctx\n            })\n            ctx.pairsMap.set(normalizedTarget, component)\n        }\n\n        return ctx.pairsMap.get(normalizedTarget)!\n    }) as Relation<T>\n}\n\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\nexport const withAutoRemove = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\nexport const withOnRemove = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n// Utility functions\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\nexport const Wildcard: Relation<any> = createRelation()\nexport const IsA: Relation<any> = createRelation()\n\n// TODO: cache until dirty\nexport const getRelationTargets = (world: World, relation: Relation<any>, eid: number) => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemove,\n            onTargetRemoved && withOnRemove(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n", "import { entityExists, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport { \n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World } from './World'\n\nexport type ComponentRef = any\n\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n}\n\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable()\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\nexport const hasComponent = (world: World, component: ComponentRef, eid: number): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n\nconst recursivelyInherit = (world: World, baseEid: number, inheritedEid: number) => {\n\taddComponent(world, IsA(inheritedEid), baseEid)\n\tconst components = getEntityComponents(world, inheritedEid)\n\tfor (const component of components) {\n\t\tif (component === Prefab) {\n\t\t\tcontinue\n\t\t}\n\t\taddComponent(world, component, baseEid)\n\t\t// TODO: onSet observable\n\t\tconst keys = Object.keys(component)\n\t\tfor (const key of keys) {\n\t\t\tcomponent[key][baseEid] = component[key][inheritedEid]\n\t\t}\n\t}\n\n\tconst inheritedTargets = getRelationTargets(world, IsA, inheritedEid)\n\tfor (const inheritedEid2 of inheritedTargets) {\n\t\trecursivelyInherit(world, baseEid, inheritedEid2)\n\t}\n}\n\nexport const addComponent = (world: World, component: ComponentRef, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\t}\n\n\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\tif (hasComponent(world, component, eid)) return\n\n\tconst componentNode = ctx.componentMap.get(component)!\n\tconst { generationId, bitflag, queries } = componentNode\n\n\tctx.entityMasks[generationId][eid] |= bitflag\n\n\tif (!hasComponent(world, Prefab, eid)) {\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\t}\n\n\tctx.entityComponents.get(eid)!.add(component)\n\n\tif (component[$isPairComponent]) {\n\t\tconst relation = component[$relation]\n\t\taddComponent(world, Pair(relation, Wildcard), eid)\n\t\tconst target = component[$pairTarget]\n\t\taddComponent(world, Pair(Wildcard, target), eid)\n\n\t\tconst relationData = relation[$relationData]\n\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\tconst oldTarget = getRelationTargets(world, relation, eid)[0]\n\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\tremoveComponent(world, relation(oldTarget), eid)\n\t\t\t}\n\t\t}\n\n\t\tif (relation === IsA) {\n\t\t\tconst inheritedTargets = getRelationTargets(world, IsA, eid)\n\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\trecursivelyInherit(world, eid, inherited)\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport const addComponents = (world: World, components: ComponentRef[], eid: number) => {\n\tcomponents.forEach((component) => addComponent(world, component, eid))\n}\n\nexport const removeComponent = (world: World, component: ComponentRef, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\t}\n\n\tif (!hasComponent(world, component, eid)) return\n\n\tconst componentNode = ctx.componentMap.get(component)!\n\tconst { generationId, bitflag, queries } = componentNode\n\n\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\tqueries.forEach((queryData: Query) => {\n\t\tqueryData.toRemove.remove(eid)\n\n\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\tif (match) queryAddEntity(queryData, eid)\n\t\telse queryRemoveEntity(world, queryData, eid)\n\t})\n\n\tctx.entityComponents.get(eid)!.delete(component)\n\n\tif (component[$isPairComponent]) {\n\t\tconst target = component[$pairTarget]\n\t\tremoveComponent(world, Pair(Wildcard, target), eid)\n\n\t\tconst relation = component[$relation]\n\t\tconst otherTargets = getRelationTargets(world, relation, eid)\n\t\tif (otherTargets.length === 0) {\n\t\t\tremoveComponent(world, Pair(relation, Wildcard), eid)\n\t\t}\n\t}\n}\n\nexport const removeComponents = (\n\tworld: World,\n\tcomponents: ComponentRef[],\n\teid: number,\n) => {\n\tcomponents.forEach((component) => removeComponent(world, component, eid))\n}\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tinnerQuery,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport const Prefab = {}\nexport const addPrefab = (world: World) => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, Prefab, eid)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): number => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: number) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, Pair(ChildOf, parent), child)\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n        for (const subject of innerQuery(world, [Wildcard(currentEid)])) {\n            if (!entityExists(world, subject)) {\n                continue\n            }\n\n            for (const component of ctx.entityComponents.get(subject)!) {\n                if (!component[$isPairComponent]) {\n                    continue\n                }\n\n                const relation = component[$relation]\n                const relationData = relation[$relationData]\n                componentRemovalQueue.push(() => removeComponent(world, Pair(Wildcard, currentEid), subject))\n\n                if (component[$pairTarget] === currentEid) {\n                    componentRemovalQueue.push(() => removeComponent(world, component, subject))\n                    if (relationData.autoRemoveSubject) {\n                        removalQueue.push(subject)\n                    }\n                    if (relationData.onTargetRemoved) {\n                        componentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n                    }\n                }\n            }\n        }\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: number): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error('bitECS - entity is undefined.')\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: number) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "type Func = (...args: any) => any\nexport const pipe = <T extends Func, U extends Func, R extends Func>\n    (...functions: [T, ...U[], R]): ((...args: Parameters<T>) => ReturnType<R>) => {\n    return (...args: Parameters<T>): ReturnType<R> => \n        functions.reduce((result, fn) => [fn(...result)], args as any)[0]\n}\n"],
  "mappings": "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",
  "names": ["core_exports", "__export", "$internal", "$isPairComponent", "$pairTarget", "$relation", "$relationData", "All", "And", "Any", "IsA", "None", "Not", "Or", "Pair", "Prefab", "Wildcard", "addComponent", "addComponents", "addEntity", "commitRemovals", "createEntityIndex", "createRelation", "createWorld", "entityExists", "getAllEntities", "getEntityComponents", "getRelationTargets", "getWorldComponents", "hasComponent", "innerQuery", "makeExclusive", "observe", "onAdd", "onRemove", "pipe", "query", "registerComponent", "registerComponents", "registerQuery", "removeComponent", "removeComponents", "removeEntity", "removeQuery", "resetWorld", "withAutoRemove", "withContext", "withEntityIndex", "withOnRemove", "withStore", "__toCommonJS", "defineHiddenProperty", "obj", "key", "value", "createEntityIndex", "addEntityId", "index", "recycledId", "id", "removeEntityId", "record", "denseIndex", "lastIndex", "lastId", "isEntityIdAlive", "$internal", "createBaseWorld", "context", "worldContext", "createEntityIndex", "world", "defineHiddenProperty", "withEntityIndex", "entityIndex", "ctx", "withContext", "createWorld", "args", "processInputs", "inputs", "modifiers", "arg", "baseWorld", "modifier", "resetWorld", "getWorldComponents", "getAllEntities", "createSparseSet", "dense", "sparse", "has", "val", "index", "swapped", "createUint32SparseSet", "initialCapacity", "length", "newDense", "createObservable", "observers", "observer", "entity", "args", "listener", "onAdd", "components", "onRemove", "observe", "world", "hook", "callback", "ctx", "$internal", "type", "components", "hash", "queryHash", "queryData", "registerQuery", "Or", "And", "Not", "Any", "All", "None", "terms", "getComponentId", "component", "registerComponent", "termToString", "term", "sortedComponentIds", "a", "b", "options", "notComponents", "orComponents", "processComponents", "comps", "targetArray", "comp", "mapComponents", "c", "allComponents", "sparseSet", "createUint32SparseSet", "createSparseSet", "toRemove", "generations", "v", "reduceBitflags", "masks", "notMasks", "orMasks", "hasMasks", "addObservable", "createObservable", "removeObservable", "query", "entityIndex", "i", "eid", "hasComponent", "Prefab", "queryCheckEntity", "queryAddEntity", "innerQuery", "commitRemovals", "queryCheckEntity", "world", "query", "eid", "ctx", "$internal", "masks", "notMasks", "orMasks", "generations", "i", "generationId", "qMask", "qNotMask", "qOrMask", "eMask", "queryAddEntity", "query", "eid", "queryCommitRemovals", "i", "commitRemovals", "world", "ctx", "$internal", "queryRemoveEntity", "removeQuery", "terms", "hash", "queryHash", "$relation", "$pairTarget", "$isPairComponent", "$relationData", "createBaseRelation", "data", "relation", "target", "normalizedTarget", "Wildcard", "component", "defineHiddenProperty", "withStore", "createStore", "ctx", "makeExclusive", "withAutoRemove", "withOnRemove", "onRemove", "Pair", "relation", "target", "Wildcard", "createRelation", "IsA", "getRelationTargets", "world", "eid", "components", "getEntityComponents", "targets", "c", "$relation", "$pairTarget", "args", "store", "exclusive", "autoRemoveSubject", "onTargetRemoved", "withStore", "makeExclusive", "withAutoRemove", "withOnRemove", "acc", "modifier", "createBaseRelation", "registerComponent", "world", "component", "ctx", "$internal", "queries", "data", "createObservable", "registerComponents", "components", "hasComponent", "eid", "registeredComponent", "generationId", "bitflag", "recursivelyInherit", "baseEid", "inheritedEid", "addComponent", "IsA", "getEntityComponents", "Prefab", "keys", "key", "inheritedTargets", "getRelationTargets", "inheritedEid2", "entityExists", "componentNode", "queryData", "queryCheckEntity", "queryAddEntity", "queryRemoveEntity", "$isPairComponent", "relation", "$relation", "Pair", "Wildcard", "target", "$pairTarget", "$relationData", "oldTarget", "removeComponent", "inherited", "addComponents", "removeComponents", "Prefab", "addEntity", "world", "ctx", "$internal", "eid", "addEntityId", "q", "queryCheckEntity", "queryAddEntity", "removeEntity", "isEntityIdAlive", "removalQueue", "processedEntities", "currentEid", "componentRemovalQueue", "subject", "innerQuery", "Wildcard", "entityExists", "component", "$isPairComponent", "relationData", "$relation", "$relationData", "removeComponent", "Pair", "$pairTarget", "removeOperation", "query", "queryRemoveEntity", "removeEntityId", "getEntityComponents", "pipe", "functions", "args", "result", "fn"]
}
