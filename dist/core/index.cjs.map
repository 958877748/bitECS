{
  "version": 3,
  "sources": ["../../src/core/index.ts", "../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/SparseSet.ts", "../../src/core/utils/Observer.ts", "../../src/core/Relation.ts", "../../src/core/Hierarchy.ts", "../../src/core/Query.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/core/utils/pipe.ts"],
  "sourcesContent": ["export {\n\tcreateWorld,\n\tresetWorld,\n\tdeleteWorld,\n\tgetWorldComponents,\n\tgetAllEntities,\n\t$internal,\n} from './World'\n\nexport type {\n\tWorld,\n\tInternalWorld,\n\tWorldContext\n} from './World'\n\nexport {\n\ttype EntityId,\n\taddEntity,\n\tremoveEntity,\n\tgetEntityComponents,\n\tentityExists,\n\tPrefab,\n\taddPrefab,\n} from './Entity'\n\nexport { \n\tcreateEntityIndex,\n\tgetId,\n\tgetVersion,\n\twithVersioning,\n} from './EntityIndex'\n\nexport {\n\tregisterComponent,\n\tregisterComponents,\n\thasComponent,\n\taddComponent,\n\taddComponents,\n\tsetComponent,\n\tremoveComponent,\n\tremoveComponents,\n\tgetComponent,\n\tset\n} from './Component'\n\nexport type {\n\tComponentRef,\n\tComponentData\n} from './Component'\n\nexport {\n\tcommitRemovals,\n\tremoveQuery,\n\tregisterQuery,\n\tquery,\n\tobserve,\n\tonAdd,\n\tonRemove,\n\tOr,\n\tAnd,\n\tNot,\n\tAny,\n\tAll,\n\tNone,\n\tonGet,\n\tonSet,\n\tHierarchy,\n\tCascade,\n\tasBuffer,\n\tisNested,\n\tnoCommit,\n\ttype QueryOptions,\n\ttype HierarchyTerm,\n\ttype QueryModifier,\n} from './Query'\n\nexport type {\n\tObservableHookDef,\n\tObservableHook,\n\tQueryResult,\n\tQuery,\n\tQueryOperatorType,\n\tOpReturnType,\n\tQueryOperator,\n\tQueryTerm,\n\tOrOp,\n\tAndOp,\n\tNotOp,\n\tAnyOp,\n\tAllOp,\n\tNoneOp,\n} from './Query'\n\nexport { pipe } from './utils/pipe'\n\nexport {\n\twithAutoRemoveSubject,\n\twithOnTargetRemoved,\n\twithStore,\n\tcreateRelation,\n\tgetRelationTargets,\n\tWildcard,\n\tIsA,\n\tPair,\n\tisRelation,\n\tisWildcard,\n} from './Relation'\n\nexport type {\n\tOnTargetRemovedCallback,\n\tRelation,\n\tRelationTarget,\n} from './Relation'\n\nexport {\n\tgetHierarchyDepth,\n\tgetMaxHierarchyDepth,\n} from './Hierarchy'\n", "export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n    /** Flag indicating if versioning is enabled. */\n    versioning: boolean\n    /** Number of bits used for versioning. */\n    versionBits: number\n    /** Bit mask for entity ID. */\n    entityMask: number\n    /** Bit shift for version. */\n    versionShift: number\n    /** Bit mask for version. */\n    versionMask: number\n}\n\n/**\n * Extracts the entity ID from a versioned entity ID by stripping off the version.\n * @param {EntityIndex} index - The EntityIndex containing the masks.\n * @param {number} id - The versioned entity ID.\n * @returns {number} The entity ID without the version.\n */\nexport const getId = (index: EntityIndex, id: number): number => id & index.entityMask;\n\n/**\n * Extracts the version from an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The version.\n */\nexport const getVersion = (index: EntityIndex, id: number): number => \n    (id >>> index.versionShift) & ((1 << index.versionBits) - 1);\n\n/**\n * Increments the version of an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The new entity ID with incremented version.\n */\nexport const incrementVersion = (index: EntityIndex, id: number): number => {\n    const currentVersion = getVersion(index, id);\n    const newVersion = (currentVersion + 1) & ((1 << index.versionBits) - 1);\n    return (id & index.entityMask) | (newVersion << index.versionShift);\n}\n\n/**\n * Creates configuration options for entity ID recycling with versioning.\n * @param {number} [versionBits] - Optional number of bits to use for version numbers. Defaults to 8 if not specified.\n * @returns {object} Configuration object with versioning enabled and specified version bits.\n */\nexport const withVersioning = (versionBits?: number) => ({\n    versioning: true,\n    versionBits\n})\n\n/**\n * Creates and initializes a new EntityIndex.\n * @param {object|function} [options] - Optional configuration object from withVersioning() or withVersioning function.\n * @param {boolean} options.versioning - Flag to enable versioning for recycled IDs.\n * @param {number} options.versionBits - Number of bits to use for versioning (default: 8).\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (options?: ReturnType<typeof withVersioning> | typeof withVersioning): EntityIndex => {\n    const config = options \n        ? typeof options === 'function' \n            ? options()\n            : options\n        : { versioning: false, versionBits: 8 }\n\n    const versionBits = config.versionBits ?? 8\n    const versioning = config.versioning ?? false\n    \n    const entityBits = 32 - versionBits\n    const entityMask = (1 << entityBits) - 1\n    const versionShift = entityBits\n    const versionMask = ((1 << versionBits) - 1) << versionShift\n\n    return {\n        aliveCount: 0,\n        dense: [],\n        sparse: [],\n        maxId: 0,\n        versioning,\n        versionBits,\n        entityMask,\n        versionShift,\n        versionMask\n    }\n}\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount];\n        const entityId = recycledId;\n        index.sparse[entityId] = index.aliveCount;\n        index.aliveCount++;\n        return recycledId;\n    }\n\n    // Create new id\n    const id = ++index.maxId;\n    index.dense.push(id);\n    index.sparse[id] = index.aliveCount;\n    index.aliveCount++;\n\n    return id;\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const denseIndex = index.sparse[id];\n    if (denseIndex === undefined || denseIndex >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return;\n    }\n\n    const lastIndex = index.aliveCount - 1;\n    const lastId = index.dense[lastIndex];\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex;\n    index.dense[denseIndex] = lastId;\n\n    // Update the removed entity's record\n    index.sparse[id] = lastIndex; // Set to lastIndex instead of undefined\n    index.dense[lastIndex] = id; // Keep the original id, don't strip version\n\n    // Version the ID if enabled\n    if (index.versioning) {\n        const newId = incrementVersion(index, id);\n        index.dense[lastIndex] = newId;\n    }\n\n    index.aliveCount--;\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const entityId = getId(index, id);\n    const denseIndex = index.sparse[entityId];\n    return denseIndex !== undefined && denseIndex < index.aliveCount && index.dense[denseIndex] === id;\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query } from './Query'\nimport { EntityId } from './Entity'\nimport { type SparseSet } from './utils/SparseSet'\n\nexport const $internal = Symbol.for('bitecs_internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<EntityId, Set<ComponentRef>>\n    bitflag: number\n    componentMap: Map<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n    entitiesWithRelations: Set<EntityId>\n    hierarchyData: Map<ComponentRef, {\n        depths: Uint32Array\n        dirty: SparseSet\n        depthToEntities: Map<number, SparseSet>\n        maxDepth: number\n    }>\n    hierarchyActiveRelations: Set<ComponentRef>\n    hierarchyQueryCache: Map<ComponentRef, { hash: string, result: readonly EntityId[] }>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \n    defineHiddenProperty(context || {} as T, $internal, {\n        entityIndex: entityIndex || createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new Map(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n        entitiesWithRelations: new Set(),\n        // Initialize hierarchy tracking\n        hierarchyData: new Map(),\n        hierarchyActiveRelations: new Set(),\n        hierarchyQueryCache: new Map(),\n}) as World<T>\n\n/**\n * Creates a new world with various configurations.\n * @template T\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\n * @returns {World<T>} The created world.\n */\n\n// TODO: middleware\n\nexport function createWorld<T extends object = {}>(\n    ...args: Array<EntityIndex | T>\n): World<T> {\n    let entityIndex: EntityIndex | undefined\n    let context: T | undefined\n\n    args.forEach(arg => {\n        if (typeof arg === 'object' && 'dense' in arg && 'sparse' in arg && 'aliveCount' in arg) {\n            entityIndex = arg as EntityIndex\n        } else if (typeof arg === 'object') {\n            context = arg as T\n        }\n    })\n\n    return createBaseWorld<T>(context, entityIndex)\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    ctx.entitiesWithRelations = new Set()\n    ctx.hierarchyData = new Map()\n    ctx.hierarchyActiveRelations = new Set()\n    ctx.hierarchyQueryCache = new Map()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World): readonly EntityId[] => Array.from((world as InternalWorld)[$internal].entityComponents.keys())\n", "export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n    sort: (compareFn?: (a: number, b: number) => number) => void\n}\n\nexport const createSparseSet = (): SparseSet => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\tconst sort = (compareFn?: (a: number, b: number) => number) => {\n\t\tdense.sort(compareFn)\n\t\tfor (let i = 0; i < dense.length; i++) {\n\t\t\tsparse[dense[i]] = i\n\t\t}\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t\tsort,\n\t}\n}\n\nconst SharedArrayBufferOrArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(new SharedArrayBufferOrArrayBuffer(initialCapacity * 4))\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(new SharedArrayBufferOrArrayBuffer(dense.length * 2 * 4))\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\tconst sort = (compareFn?: (a: number, b: number) => number) => {\n\t\t// Create temporary array for sorting\n\t\tconst temp = Array.from(dense.subarray(0, length))\n\t\ttemp.sort(compareFn)\n\t\t\n\t\t// Copy back to dense array\n\t\tfor (let i = 0; i < temp.length; i++) {\n\t\t\tdense[i] = temp[i]\n\t\t}\n\t\t\n\t\t// rebuild sparse mapping\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tsparse[dense[i]] = i\n\t\t}\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t\tsort,\n\t}\n}", "import { EntityId } from \"../Entity\"\n\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: EntityId, ...args: any[])  => void | object\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n  const notify = (entity: EntityId, ...args: any[]) => {\n    return Array.from(observers).reduce((acc, listener) => {\n      const result = listener(entity, ...args)\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\n    }, {})\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { getEntityComponents, World } from '.'\nimport { EntityId } from './Entity'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number} target - The target entity ID.\n */\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol.for('bitecs-relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol.for('bitecs-pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol.for('bitecs-isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol.for('bitecs-relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: (eid: EntityId) => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = data.initStore ? data.initStore(target) : {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: (eid: EntityId) => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n    return relation\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>): number[] => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard && !isRelation(c[$pairTarget])) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n\n/**\n * Symbol used to mark a relation as a wildcard relation\n */\nexport const $wildcard = Symbol.for('bitecs-wildcard')\n\n/**\n * Creates a wildcard relation that matches any target.\n * @template T\n * @returns {Relation<T>} The created wildcard relation.\n */\nexport function createWildcardRelation<T>(): Relation<T> {\n    const relation = createBaseRelation<T>()\n    Object.defineProperty(relation, $wildcard, {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: false\n    })\n    return relation\n}\n\n/**\n * Gets the singleton wildcard instance.\n * @returns {Relation<any>} The global wildcard relation instance.\n */\nexport function getWildcard(): Relation<any> {\n    const GLOBAL_WILDCARD = Symbol.for('bitecs-global-wildcard')\n    \n    if (!(globalThis as any)[GLOBAL_WILDCARD]) {\n        (globalThis as any)[GLOBAL_WILDCARD] = createWildcardRelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_WILDCARD]\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard = getWildcard()\n\n/**\n * Creates an IsA relation.\n * @template T\n * @returns {Relation<T>} The created IsA relation.\n */\nexport function createIsARelation<T>(): Relation<T> {\n    return createBaseRelation<T>()\n}\n\n/**\n * Gets the singleton IsA instance.\n * @returns {Relation<any>} The global IsA relation instance.\n */\nexport function getIsA(): Relation<any> {\n    const GLOBAL_ISA = Symbol.for('bitecs-global-isa')\n    \n    if (!(globalThis as any)[GLOBAL_ISA]) {\n        (globalThis as any)[GLOBAL_ISA] = createIsARelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_ISA]\n}\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA = getIsA()\n\n/**\n * Checks if a relation is a wildcard relation.\n * @param {any} relation - The relation to check.\n * @returns {boolean} True if the relation is a wildcard relation, false otherwise.\n */\nexport function isWildcard(relation: any): boolean {\n    if (!relation) return false\n    const symbols = Object.getOwnPropertySymbols(relation)\n    return symbols.includes($wildcard)\n}\n\n/**\n * Checks if a component is a relation.\n * @param {any} component - The component to check.\n * @returns {boolean} True if the component is a relation, false otherwise.\n */\nexport function isRelation(component: any): boolean {\n    if (!component) return false\n    const symbols = Object.getOwnPropertySymbols(component)\n    return symbols.includes($relationData)\n}\n", "import { World, InternalWorld, $internal } from './World'\nimport { EntityId } from './Entity'\nimport { ComponentRef } from './Component'\nimport { getRelationTargets, Wildcard, Pair } from './Relation'\nimport { query, queryHash, queryInternal, type QueryResult } from './Query'\nimport { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\n\n// Constants\nconst MAX_HIERARCHY_DEPTH = 64 // Prevent stack overflow in deep hierarchies\nconst INVALID_DEPTH = 0xFFFFFFFF // 32-bit max value indicates uncomputed depth\nconst DEFAULT_BUFFER_GROWTH = 1024 // Growth increment for depth arrays\n\ntype HierarchyData = {\n    depths: Uint32Array\n    dirty: SparseSet\n    depthToEntities: Map<number, SparseSet>\n    maxDepth: number\n}\n\n/**\n * Grows the depths array to accommodate a specific entity\n */\nfunction growDepthsArray(hierarchyData: HierarchyData, entity: EntityId): Uint32Array {\n    const { depths } = hierarchyData\n    if (entity < depths.length) return depths\n    \n    const newSize = Math.max(entity + 1, depths.length * 2, depths.length + DEFAULT_BUFFER_GROWTH)\n    const newDepths = new Uint32Array(newSize)\n    newDepths.fill(INVALID_DEPTH)\n    newDepths.set(depths)\n    hierarchyData.depths = newDepths\n    return newDepths\n}\n\n/**\n * Updates the depthToEntities cache when an entity's depth changes\n */\nfunction updateDepthCache(hierarchyData: HierarchyData, entity: EntityId, newDepth: number, oldDepth?: number): void {\n    const { depthToEntities } = hierarchyData\n    \n    // Remove from old depth cache if exists\n    if (oldDepth !== undefined && oldDepth !== INVALID_DEPTH) {\n        const oldSet = depthToEntities.get(oldDepth)\n        if (oldSet) {\n            oldSet.remove(entity)\n            if (oldSet.dense.length === 0) depthToEntities.delete(oldDepth)\n        }\n    }\n    \n    // Add to new depth cache (skip INVALID_DEPTH)\n    if (newDepth !== INVALID_DEPTH) {\n        if (!depthToEntities.has(newDepth)) depthToEntities.set(newDepth, createUint32SparseSet())\n        depthToEntities.get(newDepth)!.add(entity)\n    }\n}\n\n/**\n * Updates max depth if the new depth is greater\n */\nfunction updateMaxDepth(hierarchyData: HierarchyData, depth: number): void {\n    if (depth > hierarchyData.maxDepth) {\n        hierarchyData.maxDepth = depth\n    }\n}\n\n/**\n * Sets entity depth and updates all related caches\n */\nfunction setEntityDepth(hierarchyData: HierarchyData, entity: EntityId, newDepth: number, oldDepth?: number): void {\n    hierarchyData.depths[entity] = newDepth\n    updateDepthCache(hierarchyData, entity, newDepth, oldDepth)\n    updateMaxDepth(hierarchyData, newDepth)\n}\n\n/**\n * Invalidates hierarchy query cache for a relation\n */\nfunction invalidateQueryCache(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.hierarchyQueryCache.delete(relation)\n}\n\n/**\n * Gets hierarchy data for a relation, activating tracking if needed\n */\nfunction getHierarchyData(world: World, relation: ComponentRef): HierarchyData {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        ctx.hierarchyActiveRelations.add(relation)\n        \n        // Initialize tracking for this relation\n        ensureDepthTracking(world, relation)\n        \n        // Populate depths for all existing entities and their targets\n        populateExistingDepths(world, relation)\n    }\n    \n    return ctx.hierarchyData.get(relation)!\n}\n\n/**\n * Populates depth calculations for all existing entities with this relation\n */\nfunction populateExistingDepths(world: World, relation: ComponentRef): void {\n    const entitiesWithRelation = query(world, [Pair(relation, Wildcard)])\n    \n    // Calculate depths for entities with this relation\n    for (const entity of entitiesWithRelation) {\n        getEntityDepth(world, relation, entity)\n    }\n    \n    // Calculate depths for all relation targets (avoid extra allocation)\n    const processedTargets = new Set<EntityId>()\n    for (const entity of entitiesWithRelation) {\n        for (const target of getRelationTargets(world, entity, relation)) {\n            if (!processedTargets.has(target)) {\n                processedTargets.add(target)\n                getEntityDepth(world, relation, target)\n            }\n        }\n    }\n}\n\n/**\n * Ensures depth tracking is initialized for a relation\n */\nexport function ensureDepthTracking(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    if (!ctx.hierarchyData.has(relation)) {\n        const initialSize = Math.max(DEFAULT_BUFFER_GROWTH, ctx.entityIndex.dense.length * 2)\n        const depthArray = new Uint32Array(initialSize)\n        depthArray.fill(INVALID_DEPTH)\n        \n        ctx.hierarchyData.set(relation, {\n            depths: depthArray,\n            dirty: createSparseSet(),\n            depthToEntities: new Map(),\n            maxDepth: 0\n        })\n    }\n}\n\n/**\n * Calculates the hierarchy depth of an entity for a given relation\n */\nexport function calculateEntityDepth(world: World, relation: ComponentRef, entity: EntityId, visited = new Set<EntityId>()): number {\n    if (visited.has(entity)) return 0\n    visited.add(entity)\n    \n    const targets = getRelationTargets(world, entity, relation)\n    if (targets.length === 0) return 0\n    if (targets.length === 1) return getEntityDepthWithVisited(world, relation, targets[0], visited) + 1\n    \n    let minDepth = Infinity\n    for (const target of targets) {\n        const depth = getEntityDepthWithVisited(world, relation, target, visited)\n        if (depth < minDepth) {\n            minDepth = depth\n            if (minDepth === 0) break\n        }\n    }\n    return minDepth === Infinity ? 0 : minDepth + 1\n}\n\n/**\n * Internal helper to get entity depth with cycle detection\n */\nfunction getEntityDepthWithVisited(world: World, relation: ComponentRef, entity: EntityId, visited: Set<EntityId>): number {\n    const ctx = (world as InternalWorld)[$internal]\n    ensureDepthTracking(world, relation)\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    let { depths } = hierarchyData\n    \n    depths = growDepthsArray(hierarchyData, entity)\n    \n    if (depths[entity] === INVALID_DEPTH) {\n        const depth = calculateEntityDepth(world, relation, entity, visited)\n        setEntityDepth(hierarchyData, entity, depth)\n        return depth\n    }\n    \n    return depths[entity]\n}\n\n/**\n * Gets the cached depth of an entity, calculating if needed\n */\nfunction getEntityDepth(world: World, relation: ComponentRef, entity: EntityId): number {\n    return getEntityDepthWithVisited(world, relation, entity, new Set())\n}\n\n/**\n * Marks an entity and its children as needing depth recalculation\n */\nexport function markChildrenDirty(world: World, relation: ComponentRef, parent: EntityId, dirty: SparseSet, visited = createSparseSet()): void {\n    if (visited.has(parent)) return\n    visited.add(parent)\n    \n    const children = query(world, [relation(parent)])\n    for (const child of children) {\n        dirty.add(child)\n        markChildrenDirty(world, relation, child, dirty, visited)\n    }\n}\n\n/**\n * Updates hierarchy depth when a relation is added\n */\nexport function updateHierarchyDepth(\n    world: World, \n    relation: ComponentRef, \n    entity: EntityId, \n    parent?: EntityId,\n    updating = new Set<EntityId>()\n): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Skip if hierarchy tracking is not active for this relation\n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        return\n    }\n    ensureDepthTracking(world, relation)\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    \n    // Prevent recursive updates - entity already being updated in this call stack\n    if (updating.has(entity)) {\n        // Just mark as dirty for later processing\n        hierarchyData.dirty.add(entity)\n        return\n    }\n    \n    updating.add(entity)\n    \n    const { depths, dirty } = hierarchyData\n    \n    // Calculate new depth\n    const newDepth = parent !== undefined ? \n        getEntityDepth(world, relation, parent) + 1 : 0\n    \n    // Prevent excessive depth (cycle detection)\n    if (newDepth > MAX_HIERARCHY_DEPTH) {\n        return\n    }\n    \n    const oldDepth = depths[entity]\n    setEntityDepth(hierarchyData, entity, newDepth, oldDepth === INVALID_DEPTH ? undefined : oldDepth)\n    \n    // If depth changed, mark children as dirty for recalculation\n    if (oldDepth !== newDepth) {\n        markChildrenDirty(world, relation, entity, dirty, createSparseSet())\n        invalidateQueryCache(world, relation)\n    }\n}\n\n/**\n * Invalidates hierarchy depth when a relation is removed\n */\nexport function invalidateHierarchyDepth(world: World, relation: ComponentRef, entity: EntityId): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Skip if hierarchy tracking is not active for this relation\n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        return\n    }\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    let { depths } = hierarchyData\n    \n    // Expand array if needed\n    depths = growDepthsArray(hierarchyData, entity)\n    \n    invalidateSubtree(world, relation, entity, depths, createSparseSet())\n    invalidateQueryCache(world, relation)\n}\n\n/**\n * Recursively invalidates an entire subtree\n */\nfunction invalidateSubtree(world: World, relation: ComponentRef, entity: EntityId, depths: Uint32Array, visited: SparseSet): void {\n    if (visited.has(entity)) return\n    visited.add(entity)\n    \n    const ctx = (world as InternalWorld)[$internal]\n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    \n    // Invalidate this entity and update cache\n    if (entity < depths.length) {\n        const oldDepth = depths[entity]\n        if (oldDepth !== INVALID_DEPTH) {\n            hierarchyData.depths[entity] = INVALID_DEPTH\n            updateDepthCache(hierarchyData, entity, INVALID_DEPTH, oldDepth)\n        }\n    }\n    \n    // Find and invalidate all children\n    const children = query(world, [relation(entity)])\n    for (const child of children) {\n        invalidateSubtree(world, relation, child, depths, visited)\n    }\n}\n\n/**\n * Processes all dirty depth calculations for a relation\n */\nexport function flushDirtyDepths(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    const hierarchyData = ctx.hierarchyData.get(relation)\n    \n    if (!hierarchyData) return\n    \n    const { dirty, depths } = hierarchyData\n    \n    if (dirty.dense.length === 0) return\n    \n    // Simple approach: just calculate all dirty depths\n    for (const entity of dirty.dense) {\n        if (depths[entity] === INVALID_DEPTH) {\n            const newDepth = calculateEntityDepth(world, relation, entity)\n            setEntityDepth(hierarchyData, entity, newDepth)\n        }\n    }\n    \n    dirty.reset()\n}\n\n/**\n * Query entities in hierarchical order (depth-based ordering)\n * Returns entities grouped by depth: all depth 0, then depth 1, then depth 2, etc.\n * This ensures parents always come before their children.\n */\nexport function queryHierarchy(world: World, relation: ComponentRef, components: ComponentRef[], options: { buffered?: boolean } = {}): QueryResult {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Ensure hierarchy is active\n    getHierarchyData(world, relation)\n    \n    // Check cache for this query\n    const queryKey = queryHash(world, [relation, ...components])\n    const cached = ctx.hierarchyQueryCache.get(relation)\n    \n    if (cached && cached.hash === queryKey) {\n        return cached.result\n    }\n    \n    // Update any dirty depths before sorting\n    flushDirtyDepths(world, relation)\n    \n    // Ensure query is cached using existing infrastructure, then get Query object\n    queryInternal(world, components, options)\n    const queryObj = ctx.queriesHashMap.get(queryHash(world, components))!\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    const { depths } = hierarchyData\n    \n    // Sort the query's sparse set in place - no allocation needed!\n    queryObj.sort((a, b) => {\n        const depthA = depths[a]\n        const depthB = depths[b]\n        return depthA !== depthB ? depthA - depthB : a - b\n    })\n    \n    // Cache this result (dense is already the correct type)\n    const result = queryObj.dense\n    ctx.hierarchyQueryCache.set(relation, { hash: queryKey, result: result as readonly EntityId[] })\n    \n    return result\n}\n\n/**\n * Get all entities at a specific depth level\n */\nexport function queryHierarchyDepth(world: World, relation: ComponentRef, depth: number, options: { buffered?: boolean } = {}): QueryResult {\n    // Ensure hierarchy is active and get data\n    const hierarchyData = getHierarchyData(world, relation)\n    flushDirtyDepths(world, relation)\n    \n    const entitiesAtDepth = hierarchyData.depthToEntities.get(depth)\n    \n    if (entitiesAtDepth) {\n        return entitiesAtDepth.dense\n    }\n    \n    return options.buffered ? new Uint32Array(0) : []\n}\n\n/**\n * Get depth of specific entity\n */\nexport function getHierarchyDepth(world: World, entity: EntityId, relation: ComponentRef): number {\n    getHierarchyData(world, relation)\n    return getEntityDepthWithVisited(world, relation, entity, new Set())\n}\n\n/**\n * Get maximum depth in hierarchy\n */\nexport function getMaxHierarchyDepth(world: World, relation: ComponentRef): number {\n    const hierarchyData = getHierarchyData(world, relation)\n    return hierarchyData.maxDepth\n}", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { EntityId, Prefab } from './Entity'\nimport { queryHierarchy, queryHierarchyDepth } from './Hierarchy'\n\n/**\n * @typedef {Uint32Array | readonly number[]} QueryResult\n * @description The result of a query, either as a Uint32Array or a readonly array of numbers.\n */\nexport type QueryResult = Uint32Array | readonly EntityId[]\n\n/**\n * @typedef {Object} QueryOptions\n * @description Options for configuring query behavior.\n * @property {boolean} [commit=true] - Whether to commit pending entity removals before querying.\n * @property {boolean} [buffered=false] - Whether to return results as Uint32Array instead of number[].\n */\nexport interface QueryOptions {\n\tcommit?: boolean\n\tbuffered?: boolean\n}\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS using original blazing-fast bitmask evaluation.\n * @property {ComponentRef[]} allComponents - All components referenced in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Record<number, number>} masks - Bitmasks for each component generation.\n * @property {Record<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Record<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Record<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: Record<number, number>\n\torMasks: Record<number, number>\n\tnotMasks: Record<number, number>\n\thasMasks: Record<number, number>\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n\tqueues: Record<any, any>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n/**\n * Symbol for query operator type.\n * @type {Symbol}\n */\nexport const $opType = Symbol.for('bitecs-opType')\n\n/**\n * Symbol for query operator terms.\n * @type {Symbol}\n */\nexport const $opTerms = Symbol.for('bitecs-opTerms')\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opTerms] - The components involved in the operation.\n */\nexport type OpReturnType = {\n\t[$opType]: string\n\t[$opTerms]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator | HierarchyTerm} QueryTerm\n * @description A term in a query, either a component reference, query operator, or hierarchy term.\n */\nexport type QueryTerm = ComponentRef | QueryOperator | HierarchyTerm\n\n\nconst createOp = (type: string) => (...components: ComponentRef[]) => ({ [$opType]: type, [$opTerms]: components })\n\nexport const Or: QueryOperator = createOp('Or')\nexport const And: QueryOperator = createOp('And')\nexport const Not: QueryOperator = createOp('Not')\nexport const Any = Or\nexport const All = And\nexport const None = Not\n\n// NEW: Hierarchy combinator symbols\nexport const $hierarchyType = Symbol.for('bitecs-hierarchyType')\nexport const $hierarchyRel = Symbol.for('bitecs-hierarchyRel')\nexport const $hierarchyDepth = Symbol.for('bitecs-hierarchyDepth')\n\n/**\n * @typedef {Object} HierarchyTerm\n * @description Represents a hierarchy query term for topological ordering.\n * @property {symbol} [$hierarchyType] - Always 'Hierarchy'.\n * @property {ComponentRef} [$hierarchyRel] - The relation component for hierarchy.\n * @property {number} [$hierarchyDepth] - Optional depth limit.\n */\nexport type HierarchyTerm = {\n\t[$hierarchyType]: 'Hierarchy'\n\t[$hierarchyRel]: ComponentRef\n\t[$hierarchyDepth]?: number\n}\n\n/**\n * @function Hierarchy\n * @description Creates a hierarchy query term for topological ordering (parents before children).\n * @param {ComponentRef} relation - The relation component (e.g., ChildOf).\n * @param {number} [depth] - Optional depth limit.\n * @returns {HierarchyTerm} The hierarchy term.\n */\nexport const Hierarchy = (relation: ComponentRef, depth?: number): HierarchyTerm => ({\n\t[$hierarchyType]: 'Hierarchy',\n\t[$hierarchyRel]: relation,\n\t[$hierarchyDepth]: depth\n})\n\n/**\n * @function Cascade\n * @description Alias for Hierarchy - creates a hierarchy query term for topological ordering.\n * @param {ComponentRef} relation - The relation component (e.g., ChildOf).\n * @param {number} [depth] - Optional depth limit.\n * @returns {HierarchyTerm} The hierarchy term.\n */\nexport const Cascade = Hierarchy\n\n// Query modifier symbols\nexport const $modifierType = Symbol.for('bitecs-modifierType')\n\n/**\n * @typedef {Object} QueryModifier\n * @description Represents a query modifier that can be mixed into query terms.\n * @property {symbol} [$modifierType] - The type of modifier ('buffer' | 'nested').\n */\nexport type QueryModifier = {\n\t[$modifierType]: 'buffer' | 'nested'\n}\n\nexport const asBuffer: QueryModifier = { [$modifierType]: 'buffer' }\nexport const isNested: QueryModifier = { [$modifierType]: 'nested' }\nexport const noCommit = isNested\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...QueryTerm} terms - The query terms to observe.\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\n */\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\n\t[$opTerms]: QueryTerm[]\n}\n\nexport type ObservableHook = ReturnType<ObservableHookDef>\n\nconst createHook = (type: 'add' | 'remove' | 'set' | 'get') => (...terms: QueryTerm[]) => ({ [$opType]: type, [$opTerms]: terms })\nexport const onAdd: ObservableHookDef = createHook('add')\nexport const onRemove: ObservableHookDef = createHook('remove')\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({ [$opType]: 'set', [$opTerms]: [component] })\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({ [$opType]: 'get', [$opTerms]: [component] })\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ObservableHook} hook - The observable hook.\n * @param {function(number): any} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opTerms]: components } = hook\n\n\tif (type === 'add' || type === 'remove') {\n\t\tconst queryData = ctx.queriesHashMap.get(queryHash(world, components)) || registerQuery(world, components)\n\t\treturn queryData[type === 'add' ? 'addObservable' : 'removeObservable'].subscribe(callback)\n\t}\n\t\n\tif (type === 'set' || type === 'get') {\n\t\tif (components.length !== 1) throw new Error('Set and Get hooks can only observe a single component')\n\t\tconst componentData = ctx.componentMap.get(components[0]) || registerComponent(world, components[0])\n\t\treturn componentData[type === 'set' ? 'setObservable' : 'getObservable'].subscribe(callback)\n\t}\n\n\tthrow new Error(`Invalid hook type: ${type}`)\n}\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst getComponentId = (component: ComponentRef): number => {\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\t\treturn ctx.componentMap.get(component)!.id\n\t}\n\tconst termToString = (term: QueryTerm): string => \n\t\t$opType in term ? `${term[$opType].toLowerCase()}(${term[$opTerms].map(termToString).sort().join(',')})` : getComponentId(term).toString()\n\t\n\treturn terms.map(termToString).sort().join('-')\n}\n\n/**\n * @function registerQuery  \n * @description Registers a new query in the world using unified clause-mask compilation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\n\tconst queryComponents: ComponentRef[] = []\n\tconst collect = (term: QueryTerm) => {\n\t\tif ($opType in term) term[$opTerms].forEach(collect)\n\t\telse {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tqueryComponents.push(term)\n\t\t}\n\t}\n\tterms.forEach(collect)\n\t\n\t// Use original simple approach for blazing-fast simple queries\n\t// TODO: Add nested combinator support later if needed\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst addToArray = (arr: ComponentRef[], comps: ComponentRef[]) => {\n\t\tcomps.forEach(comp => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\tarr.push(comp)\n\t\t})\n\t}\n\t\n\tterms.forEach(term => {\n\t\tif ($opType in term) {\n\t\t\tconst { [$opType]: type, [$opTerms]: comps } = term\n\t\t\tif (type === 'Not') addToArray(notComponents, comps)\n\t\t\telse if (type === 'Or') addToArray(orComponents, comps)\n\t\t\telse if (type === 'And') addToArray(components, comps)\n\t\t\telse throw new Error(`Nested combinator ${type} not supported yet - use simple queries for best performance`)\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst allComponentsData = queryComponents.map(c => ctx.componentMap.get(c)!)\n\tconst generations = [...new Set(allComponentsData.map(c => c.generationId))]\n\tconst reduceBitflags = (a: Record<number, number>, c: ComponentData) => (a[c.generationId] = (a[c.generationId] || 0) | c.bitflag, a)\n\t\n\tconst masks = components.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponentsData.reduce(reduceBitflags, {})\n\n\tconst query = Object.assign(options.buffered ? createUint32SparseSet() : createSparseSet(), {\n\t\tallComponents: queryComponents, orComponents, notComponents, masks, notMasks, orMasks, hasMasks, generations,\n\t\ttoRemove: createSparseSet(), addObservable: createObservable(), removeObservable: createObservable(), queues: {}\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponentsData.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, eid, Prefab)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n\n\n/**\n * @function queryInternal\n * @description Internal implementation for nested queries.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function queryInternal(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\n\treturn queryData.dense\n}\n\n/**\n * @function query\n * @description Performs a unified query operation with configurable options.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {...QueryModifier} modifiers - Query modifiers (asBuffer, isNested, etc.).\n * @returns {QueryResult} The result of the query.\n */\nexport function query(world: World, terms: QueryTerm[], ...modifiers: (QueryModifier | QueryOptions)[]): QueryResult {\n\tconst hierarchyTerm = terms.find(term => term && typeof term === 'object' && $hierarchyType in term) as HierarchyTerm | undefined\n\tconst regularTerms = terms.filter(term => !(term && typeof term === 'object' && $hierarchyType in term))\n\t\n\tlet buffered = false, commit = true\n\tconst hasModifiers = modifiers.some(m => m && typeof m === 'object' && $modifierType in m)\n\t\n\tfor (const modifier of modifiers) {\n\t\tif (hasModifiers && modifier && typeof modifier === 'object' && $modifierType in modifier) {\n\t\t\tconst mod = modifier as QueryModifier\n\t\t\tif (mod[$modifierType] === 'buffer') buffered = true\n\t\t\tif (mod[$modifierType] === 'nested') commit = false\n\t\t} else if (!hasModifiers) {\n\t\t\tconst opts = modifier as QueryOptions\n\t\t\tif (opts.buffered !== undefined) buffered = opts.buffered\n\t\t\tif (opts.commit !== undefined) commit = opts.commit\n\t\t}\n\t}\n\n\tif (hierarchyTerm) {\n\t\tconst { [$hierarchyRel]: relation, [$hierarchyDepth]: depth } = hierarchyTerm\n\t\treturn depth !== undefined ? queryHierarchyDepth(world, relation, depth, { buffered }) : queryHierarchy(world, relation, regularTerms, { buffered })\n\t}\n\n\tif (commit) commitRemovals(world)\n\treturn queryInternal(world, regularTerms, { buffered })\n}\n\n\n\n/**\n * @function queryCheckEntity\n * @description Original blazing-fast query evaluation using simple bitmasks.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tlet hasOrMatch = Object.keys(orMasks).length === 0\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) !== 0) {\n\t\t\thasOrMatch = true\n\t\t}\n\t}\n\n\treturn hasOrMatch\n}\n\n\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport {\n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World, WorldContext } from './World'\nimport { updateHierarchyDepth, invalidateHierarchyDepth } from './Hierarchy'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n\tgetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable(),\n\t\tgetObservable: createObservable(),\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to check for.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n/**\n * Retrieves the data associated with a component for a specific entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to retrieve data for.\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\n */\nexport const getComponent = (world: World, eid: EntityId, component: ComponentRef): any => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\treturn undefined\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\treturn undefined\n\t}\n\n\t// Notify observers that this component is being accessed\n\treturn componentData.getObservable.notify(eid)\n}\n\n/**\n * Helper function to set component data.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\n */\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\n\tcomponent,\n\tdata\n})\n\n/**\n * Recursvely inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n * @param {boolean} isFirstSuper - Whether this is the first super in the inheritance chain.\n */\nconst recursivelyInherit = (ctx: WorldContext, world: World, baseEid: EntityId, inheritedEid: EntityId, visited = new Set<EntityId>()): void => {\n\t// Guard against circular inheritance\n\tif (visited.has(inheritedEid)) return\n\tvisited.add(inheritedEid)\n\t\n\t// Add IsA relation first\n\taddComponent(world, baseEid, IsA(inheritedEid))\n\t\n\t// Copy components and their data from this level\n\t// This needs to happen before recursing to ancestors so closer ancestors take precedence\n\tfor (const component of getEntityComponents(world, inheritedEid)) {\n\t\t// TODO: inherit reference vs copy\n\t\tif (component === Prefab) continue\n\t\t\n\t\t// Only add component if entity doesn't already have it\n\t\t// This ensures closer ancestors take precedence\n\t\tif (!hasComponent(world, baseEid, component)) {\n\t\t\taddComponent(world, baseEid, component)\n\t\t\t\n\t\t\tconst componentData = ctx.componentMap.get(component)\n\t\t\tif (componentData?.setObservable) {\n\t\t\t\tconst data = getComponent(world, inheritedEid, component)\n\t\t\t\tcomponentData.setObservable.notify(baseEid, data)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Then recursively inherit from ancestors\n\t// This ensures more distant ancestors don't override closer ones\n\tfor (const parentEid of getRelationTargets(world, inheritedEid, IsA)) {\n\t\trecursivelyInherit(ctx, world, baseEid, parentEid, visited)\n\t}\n}\n\n/**\n * Represents a component with data to be set on an entity.\n */\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\n\n/**\n * Sets component data on an entity. Always calls the setter observable even if entity already has the component.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const setComponent = (\n  world: World,\n  eid: EntityId,\n  component: ComponentRef,\n  data: any\n): void => {\n  addComponent(world, eid, set(component, data));\n};\n\n/**\n * Adds a single component to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef | ComponentSetter} componentOrSet - Component to add or set.\n * @returns {boolean} True if component was added, false if it already existed.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, eid: EntityId, componentOrSet: ComponentRef | ComponentSetter): boolean => {\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\n\t}\n\t\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\n\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\n\n\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\tconst componentData = ctx.componentMap.get(component)!\n\t\n\t// If entity already has component, just call setter and return false\n\tif (hasComponent(world, eid, component)) {\n\t\tif (data !== undefined) {\n\t\t\tcomponentData.setObservable.notify(eid, data)\n\t\t}\n\t\treturn false\n\t}\n\n\tconst { generationId, bitflag, queries } = componentData\n\n\tctx.entityMasks[generationId][eid] |= bitflag\n\n\tif (!hasComponent(world, eid, Prefab)) {\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\t}\n\tctx.entityComponents.get(eid)!.add(component)\n\n\t// Call setter AFTER component is added and onAdd callbacks have fired\n\tif (data !== undefined) {\n\t\tcomponentData.setObservable.notify(eid, data)\n\t}\n\tif (component[$isPairComponent]) {\n\t\tconst relation = component[$relation]\n\t\tconst target = component[$pairTarget]\n\n\t\t// Add both Wildcard pairs for relation and target\n\t\taddComponents(world, eid, Pair(relation, Wildcard), Pair(Wildcard, target))\n\n\t\t// For non-Wildcard targets, add Wildcard pair to track relation targets\n\t\tif (typeof target === 'number') {\n\t\t\t// Add Wildcard pair for target being a relation target\n\t\t\taddComponents(world, target, Pair(Wildcard, eid), Pair(Wildcard, relation))\n\t\t\t// Track entities with relations for autoRemoveSubject\n\t\t\tctx.entitiesWithRelations.add(target)\n\t\t\tctx.entitiesWithRelations.add(eid)\n\t\t}\n\n\t\t// add target to a set to make autoRemoveSubject checks faster\n\t\tctx.entitiesWithRelations.add(target)\n\n\t\tconst relationData = relation[$relationData]\n\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\n\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\n\t\t\t}\n\t\t}\n\n\t\tif (relation === IsA) {\n\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\n\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\trecursivelyInherit(ctx, world, eid, inherited)\n\t\t\t}\n\t\t}\n\n\t\t// Update hierarchy depth tracking for this relation\n\t\tupdateHierarchyDepth(world, relation, eid, typeof target === 'number' ? target : undefined)\n\t}\n\n\treturn true\n}\n\n/**\n * Adds multiple components to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {(ComponentRef | ComponentSetter)[] | ComponentRef | ComponentSetter} components - Components to add or set (array or spread args).\n * @throws {Error} If the entity does not exist in the world.\n */\nexport function addComponents(world: World, eid: EntityId, components: (ComponentRef | ComponentSetter)[]): void;\nexport function addComponents(world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void;\nexport function addComponents(world: World, eid: EntityId, ...args: any[]): void {\n\tconst components = Array.isArray(args[0]) ? args[0] : args\n\tcomponents.forEach((componentOrSet: ComponentRef | ComponentSetter) => {\n\t\taddComponent(world, eid, componentOrSet)\n\t})\n}\n\n/**\n * Removes one or more components from an entity.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(component => {\n\t\tif (!hasComponent(world, eid, component)) return\n\n\t\tconst componentNode = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentNode\n\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\n\t\tctx.entityComponents.get(eid)!.delete(component)\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst target = component[$pairTarget]\n\t\t\tconst relation = component[$relation]\n\t\t\t\n\t\t\t// Invalidate hierarchy depth tracking for this relation\n\t\t\tinvalidateHierarchyDepth(world, relation, eid)\n\t\t\t\n\t\t\t// Remove Wildcard pair from subject\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\t// Remove Wildcard pairs from target (if target is an entity)\n\t\t\tif (typeof target === 'number' && entityExists(world, target)) {\n\t\t\t\tremoveComponent(world, target, Pair(Wildcard, eid))\n\t\t\t\tremoveComponent(world, target, Pair(Wildcard, relation))\n\t\t\t}\n\n\t\t\t// Remove relation Wildcard pair if no other targets\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\n\t\t\tif (otherTargets.length === 0) {\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for removeComponent.\n */\nexport const removeComponents = removeComponent\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tquery,\n\tnoCommit,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport type EntityId = number\n\nexport const Prefab = {}\nexport const addPrefab = (world: World): EntityId => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, eid, Prefab)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): EntityId => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, child, ChildOf(parent))\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n\t\tif (ctx.entitiesWithRelations.has(currentEid)) {\n\t\t\tfor (const subject of query(world, [Wildcard(currentEid)], noCommit)) {\n\t\t\t\tif (!entityExists(world, subject)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const component of ctx.entityComponents.get(subject)!) {\n\t\t\t\t\tif (!component[$isPairComponent]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst relation = component[$relation]\n\t\t\t\t\tconst relationData = relation[$relationData]\n\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\n\n\t\t\t\t\tif (component[$pairTarget] === currentEid) {\n\t\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, component))\n\t\t\t\t\t\tif (relationData.autoRemoveSubject) {\n\t\t\t\t\t\t\tremovalQueue.push(subject)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationData.onTargetRemoved) {\n\t\t\t\t\t\t\tcomponentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.entitiesWithRelations.delete(currentEid)\n\t\t}\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error(`getEntityComponents: entity id is undefined.`)\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error(`getEntityComponents: entity ${eid} does not exist in the world.`)\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "type Func = (...args: any) => any\nexport const pipe = <T extends Func, U extends Func, R extends Func>\n    (...functions: [T, ...U[], R]): ((...args: Parameters<T>) => ReturnType<R>) => {\n    return (...args: Parameters<T>): ReturnType<R> => \n        functions.reduce((result, fn) => [fn(...result)], args as any)[0]\n}\n"],
  "mappings": "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",
  "names": ["onRemove", "query", "query", "eid", "query"]
}
