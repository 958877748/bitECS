{
  "version": 3,
  "sources": ["../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/SparseSet.ts", "../../src/core/utils/Observer.ts", "../../src/core/Relation.ts", "../../src/core/Hierarchy.ts", "../../src/core/Query.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/core/utils/pipe.ts", "../../src/core/index.ts"],
  "sourcesContent": ["export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n    /** Flag indicating if versioning is enabled. */\n    versioning: boolean\n    /** Number of bits used for versioning. */\n    versionBits: number\n    /** Bit mask for entity ID. */\n    entityMask: number\n    /** Bit shift for version. */\n    versionShift: number\n    /** Bit mask for version. */\n    versionMask: number\n}\n\n/**\n * Extracts the entity ID from a versioned entity ID by stripping off the version.\n * @param {EntityIndex} index - The EntityIndex containing the masks.\n * @param {number} id - The versioned entity ID.\n * @returns {number} The entity ID without the version.\n */\nexport const getId = (index: EntityIndex, id: number): number => id & index.entityMask;\n\n/**\n * Extracts the version from an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The version.\n */\nexport const getVersion = (index: EntityIndex, id: number): number => \n    (id >>> index.versionShift) & ((1 << index.versionBits) - 1);\n\n/**\n * Increments the version of an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The new entity ID with incremented version.\n */\nexport const incrementVersion = (index: EntityIndex, id: number): number => {\n    const currentVersion = getVersion(index, id);\n    const newVersion = (currentVersion + 1) & ((1 << index.versionBits) - 1);\n    return (id & index.entityMask) | (newVersion << index.versionShift);\n}\n\n/**\n * Creates configuration options for entity ID recycling with versioning.\n * @param {number} [versionBits] - Optional number of bits to use for version numbers. Defaults to 8 if not specified.\n * @returns {object} Configuration object with versioning enabled and specified version bits.\n */\nexport const withVersioning = (versionBits?: number) => ({\n    versioning: true,\n    versionBits\n})\n\n/**\n * Creates and initializes a new EntityIndex.\n * @param {object|function} [options] - Optional configuration object from withVersioning() or withVersioning function.\n * @param {boolean} options.versioning - Flag to enable versioning for recycled IDs.\n * @param {number} options.versionBits - Number of bits to use for versioning (default: 8).\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (options?: ReturnType<typeof withVersioning> | typeof withVersioning): EntityIndex => {\n    const config = options \n        ? typeof options === 'function' \n            ? options()\n            : options\n        : { versioning: false, versionBits: 8 }\n\n    const versionBits = config.versionBits ?? 8\n    const versioning = config.versioning ?? false\n    \n    const entityBits = 32 - versionBits\n    const entityMask = (1 << entityBits) - 1\n    const versionShift = entityBits\n    const versionMask = ((1 << versionBits) - 1) << versionShift\n\n    return {\n        aliveCount: 0,\n        dense: [],\n        sparse: [],\n        maxId: 0,\n        versioning,\n        versionBits,\n        entityMask,\n        versionShift,\n        versionMask\n    }\n}\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount];\n        const entityId = recycledId;\n        index.sparse[entityId] = index.aliveCount;\n        index.aliveCount++;\n        return recycledId;\n    }\n\n    // Create new id\n    const id = ++index.maxId;\n    index.dense.push(id);\n    index.sparse[id] = index.aliveCount;\n    index.aliveCount++;\n\n    return id;\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const denseIndex = index.sparse[id];\n    if (denseIndex === undefined || denseIndex >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return;\n    }\n\n    const lastIndex = index.aliveCount - 1;\n    const lastId = index.dense[lastIndex];\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex;\n    index.dense[denseIndex] = lastId;\n\n    // Update the removed entity's record\n    index.sparse[id] = lastIndex; // Set to lastIndex instead of undefined\n    index.dense[lastIndex] = id; // Keep the original id, don't strip version\n\n    // Version the ID if enabled\n    if (index.versioning) {\n        const newId = incrementVersion(index, id);\n        index.dense[lastIndex] = newId;\n    }\n\n    index.aliveCount--;\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const entityId = getId(index, id);\n    const denseIndex = index.sparse[entityId];\n    return denseIndex !== undefined && denseIndex < index.aliveCount && index.dense[denseIndex] === id;\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query, QueryResult } from './Query'\nimport { EntityId } from './Entity'\nimport { type SparseSet } from './utils/SparseSet'\n\nexport const $internal = Symbol.for('bitecs_internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<EntityId, Set<ComponentRef>>\n    bitflag: number\n    componentMap: Map<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n    entitiesWithRelations: Set<EntityId>\n    hierarchyData: Map<ComponentRef, {\n        depths: Uint32Array\n        dirty: SparseSet\n        depthToEntities: Map<number, SparseSet>\n        maxDepth: number\n    }>\n    hierarchyActiveRelations: Set<ComponentRef>\n    hierarchyQueryCache: Map<ComponentRef, { hash: string, result: QueryResult }>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \n    defineHiddenProperty(context || {} as T, $internal, {\n        entityIndex: entityIndex || createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new Map(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n        entitiesWithRelations: new Set(),\n        // Initialize hierarchy tracking\n        hierarchyData: new Map(),\n        hierarchyActiveRelations: new Set(),\n        hierarchyQueryCache: new Map(),\n}) as World<T>\n\n/**\n * Creates a new world with various configurations.\n * @template T\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\n * @returns {World<T>} The created world.\n */\n\n// TODO: middleware\n\nexport function createWorld<T extends object = {}>(\n    ...args: Array<EntityIndex | T>\n): World<T> {\n    let entityIndex: EntityIndex | undefined\n    let context: T | undefined\n\n    args.forEach(arg => {\n        if (typeof arg === 'object' && 'dense' in arg && 'sparse' in arg && 'aliveCount' in arg) {\n            entityIndex = arg as EntityIndex\n        } else if (typeof arg === 'object') {\n            context = arg as T\n        }\n    })\n\n    return createBaseWorld<T>(context, entityIndex)\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    ctx.entitiesWithRelations = new Set()\n    ctx.hierarchyData = new Map()\n    ctx.hierarchyActiveRelations = new Set()\n    ctx.hierarchyQueryCache = new Map()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World): readonly EntityId[] => Array.from((world as InternalWorld)[$internal].entityComponents.keys())\n", "export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n    sort: (compareFn?: (a: number, b: number) => number) => void\n}\n\nexport const createSparseSet = (): SparseSet => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\tconst sort = (compareFn?: (a: number, b: number) => number) => {\n\t\tdense.sort(compareFn)\n\t\tfor (let i = 0; i < dense.length; i++) {\n\t\t\tsparse[dense[i]] = i\n\t\t}\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t\tsort,\n\t}\n}\n\nconst SharedArrayBufferOrArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(new SharedArrayBufferOrArrayBuffer(initialCapacity * 4))\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(new SharedArrayBufferOrArrayBuffer(dense.length * 2 * 4))\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\tconst sort = (compareFn?: (a: number, b: number) => number) => {\n\t\t// Create temporary array for sorting\n\t\tconst temp = Array.from(dense.subarray(0, length))\n\t\ttemp.sort(compareFn)\n\t\t\n\t\t// Copy back to dense array\n\t\tfor (let i = 0; i < temp.length; i++) {\n\t\t\tdense[i] = temp[i]\n\t\t}\n\t\t\n\t\t// rebuild sparse mapping\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tsparse[dense[i]] = i\n\t\t}\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t\tsort,\n\t}\n}", "import { EntityId } from \"../Entity\"\n\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: EntityId, ...args: any[])  => void | object\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n  const notify = (entity: EntityId, ...args: any[]) => {\n    return Array.from(observers).reduce((acc, listener) => {\n      const result = listener(entity, ...args)\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\n    }, {})\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { getEntityComponents, World } from '.'\nimport { EntityId } from './Entity'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number} target - The target entity ID.\n */\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol.for('bitecs-relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol.for('bitecs-pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol.for('bitecs-isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol.for('bitecs-relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: (eid: EntityId) => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = data.initStore ? data.initStore(target) : {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: (eid: EntityId) => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n    return relation\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>): number[] => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard && !isRelation(c[$pairTarget])) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n\n/**\n * Symbol used to mark a relation as a wildcard relation\n */\nexport const $wildcard = Symbol.for('bitecs-wildcard')\n\n/**\n * Creates a wildcard relation that matches any target.\n * @template T\n * @returns {Relation<T>} The created wildcard relation.\n */\nexport function createWildcardRelation<T>(): Relation<T> {\n    const relation = createBaseRelation<T>()\n    Object.defineProperty(relation, $wildcard, {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: false\n    })\n    return relation\n}\n\n/**\n * Gets the singleton wildcard instance.\n * @returns {Relation<any>} The global wildcard relation instance.\n */\nexport function getWildcard(): Relation<any> {\n    const GLOBAL_WILDCARD = Symbol.for('bitecs-global-wildcard')\n    \n    if (!(globalThis as any)[GLOBAL_WILDCARD]) {\n        (globalThis as any)[GLOBAL_WILDCARD] = createWildcardRelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_WILDCARD]\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard = getWildcard()\n\n/**\n * Creates an IsA relation.\n * @template T\n * @returns {Relation<T>} The created IsA relation.\n */\nexport function createIsARelation<T>(): Relation<T> {\n    return createBaseRelation<T>()\n}\n\n/**\n * Gets the singleton IsA instance.\n * @returns {Relation<any>} The global IsA relation instance.\n */\nexport function getIsA(): Relation<any> {\n    const GLOBAL_ISA = Symbol.for('bitecs-global-isa')\n    \n    if (!(globalThis as any)[GLOBAL_ISA]) {\n        (globalThis as any)[GLOBAL_ISA] = createIsARelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_ISA]\n}\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA = getIsA()\n\n/**\n * Checks if a relation is a wildcard relation.\n * @param {any} relation - The relation to check.\n * @returns {boolean} True if the relation is a wildcard relation, false otherwise.\n */\nexport function isWildcard(relation: any): boolean {\n    if (!relation) return false\n    const symbols = Object.getOwnPropertySymbols(relation)\n    return symbols.includes($wildcard)\n}\n\n/**\n * Checks if a component is a relation.\n * @param {any} component - The component to check.\n * @returns {boolean} True if the component is a relation, false otherwise.\n */\nexport function isRelation(component: any): boolean {\n    if (!component) return false\n    const symbols = Object.getOwnPropertySymbols(component)\n    return symbols.includes($relationData)\n}\n", "import { World, InternalWorld, $internal } from './World'\nimport { EntityId } from './Entity'\nimport { ComponentRef } from './Component'\nimport { getRelationTargets, Wildcard, Pair } from './Relation'\nimport { query, queryHash, queryInternal, type QueryResult } from './Query'\nimport { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\n\n// Constants\nconst MAX_HIERARCHY_DEPTH = 64 // Prevent stack overflow in deep hierarchies\nconst INVALID_DEPTH = 0xFFFFFFFF // 32-bit max value indicates uncomputed depth\nconst DEFAULT_BUFFER_GROWTH = 1024 // Growth increment for depth arrays\n\ntype HierarchyData = {\n    depths: Uint32Array\n    dirty: SparseSet\n    depthToEntities: Map<number, SparseSet>\n    maxDepth: number\n}\n\n/**\n * Grows the depths array to accommodate a specific entity\n */\nfunction growDepthsArray(hierarchyData: HierarchyData, entity: EntityId): Uint32Array {\n    const { depths } = hierarchyData\n    if (entity < depths.length) return depths\n    \n    const newSize = Math.max(entity + 1, depths.length * 2, depths.length + DEFAULT_BUFFER_GROWTH)\n    const newDepths = new Uint32Array(newSize)\n    newDepths.fill(INVALID_DEPTH)\n    newDepths.set(depths)\n    hierarchyData.depths = newDepths\n    return newDepths\n}\n\n/**\n * Updates the depthToEntities cache when an entity's depth changes\n */\nfunction updateDepthCache(hierarchyData: HierarchyData, entity: EntityId, newDepth: number, oldDepth?: number): void {\n    const { depthToEntities } = hierarchyData\n    \n    // Remove from old depth cache if exists\n    if (oldDepth !== undefined && oldDepth !== INVALID_DEPTH) {\n        const oldSet = depthToEntities.get(oldDepth)\n        if (oldSet) {\n            oldSet.remove(entity)\n            if (oldSet.dense.length === 0) depthToEntities.delete(oldDepth)\n        }\n    }\n    \n    // Add to new depth cache (skip INVALID_DEPTH)\n    if (newDepth !== INVALID_DEPTH) {\n        if (!depthToEntities.has(newDepth)) depthToEntities.set(newDepth, createUint32SparseSet())\n        depthToEntities.get(newDepth)!.add(entity)\n    }\n}\n\n/**\n * Updates max depth if the new depth is greater\n */\nfunction updateMaxDepth(hierarchyData: HierarchyData, depth: number): void {\n    if (depth > hierarchyData.maxDepth) {\n        hierarchyData.maxDepth = depth\n    }\n}\n\n/**\n * Sets entity depth and updates all related caches\n */\nfunction setEntityDepth(hierarchyData: HierarchyData, entity: EntityId, newDepth: number, oldDepth?: number): void {\n    hierarchyData.depths[entity] = newDepth\n    updateDepthCache(hierarchyData, entity, newDepth, oldDepth)\n    updateMaxDepth(hierarchyData, newDepth)\n}\n\n/**\n * Invalidates hierarchy query cache for a relation\n */\nfunction invalidateQueryCache(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.hierarchyQueryCache.delete(relation)\n}\n\n/**\n * Gets hierarchy data for a relation, activating tracking if needed\n */\nfunction getHierarchyData(world: World, relation: ComponentRef): HierarchyData {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        ctx.hierarchyActiveRelations.add(relation)\n        \n        // Initialize tracking for this relation\n        ensureDepthTracking(world, relation)\n        \n        // Populate depths for all existing entities and their targets\n        populateExistingDepths(world, relation)\n    }\n    \n    return ctx.hierarchyData.get(relation)!\n}\n\n/**\n * Populates depth calculations for all existing entities with this relation\n */\nfunction populateExistingDepths(world: World, relation: ComponentRef): void {\n    const entitiesWithRelation = query(world, [Pair(relation, Wildcard)])\n    \n    // Calculate depths for entities with this relation\n    for (const entity of entitiesWithRelation) {\n        getEntityDepth(world, relation, entity)\n    }\n    \n    // Calculate depths for all relation targets (avoid extra allocation)\n    const processedTargets = new Set<EntityId>()\n    for (const entity of entitiesWithRelation) {\n        for (const target of getRelationTargets(world, entity, relation)) {\n            if (!processedTargets.has(target)) {\n                processedTargets.add(target)\n                getEntityDepth(world, relation, target)\n            }\n        }\n    }\n}\n\n/**\n * Ensures depth tracking is initialized for a relation. This must be called before\n * using hierarchy features for a specific relation component.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component to initialize tracking for.\n */\nexport function ensureDepthTracking(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    if (!ctx.hierarchyData.has(relation)) {\n        const initialSize = Math.max(DEFAULT_BUFFER_GROWTH, ctx.entityIndex.dense.length * 2)\n        const depthArray = new Uint32Array(initialSize)\n        depthArray.fill(INVALID_DEPTH)\n        \n        ctx.hierarchyData.set(relation, {\n            depths: depthArray,\n            dirty: createSparseSet(),\n            depthToEntities: new Map(),\n            maxDepth: 0\n        })\n    }\n}\n\n/**\n * Calculates the hierarchy depth of an entity for a given relation. Depth is measured\n * as the distance from the root entities (entities with no parent relations).\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component to calculate depth for.\n * @param {EntityId} entity - The entity ID to calculate depth for.\n * @param {Set<EntityId>} [visited] - Internal set to track visited entities for cycle detection.\n * @returns {number} The hierarchy depth of the entity.\n */\nexport function calculateEntityDepth(world: World, relation: ComponentRef, entity: EntityId, visited = new Set<EntityId>()): number {\n    if (visited.has(entity)) return 0\n    visited.add(entity)\n    \n    const targets = getRelationTargets(world, entity, relation)\n    if (targets.length === 0) return 0\n    if (targets.length === 1) return getEntityDepthWithVisited(world, relation, targets[0], visited) + 1\n    \n    let minDepth = Infinity\n    for (const target of targets) {\n        const depth = getEntityDepthWithVisited(world, relation, target, visited)\n        if (depth < minDepth) {\n            minDepth = depth\n            if (minDepth === 0) break\n        }\n    }\n    return minDepth === Infinity ? 0 : minDepth + 1\n}\n\n/**\n * Internal helper to get entity depth with cycle detection\n */\nfunction getEntityDepthWithVisited(world: World, relation: ComponentRef, entity: EntityId, visited: Set<EntityId>): number {\n    const ctx = (world as InternalWorld)[$internal]\n    ensureDepthTracking(world, relation)\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    let { depths } = hierarchyData\n    \n    depths = growDepthsArray(hierarchyData, entity)\n    \n    if (depths[entity] === INVALID_DEPTH) {\n        const depth = calculateEntityDepth(world, relation, entity, visited)\n        setEntityDepth(hierarchyData, entity, depth)\n        return depth\n    }\n    \n    return depths[entity]\n}\n\n/**\n * Gets the cached depth of an entity, calculating if needed\n */\nfunction getEntityDepth(world: World, relation: ComponentRef, entity: EntityId): number {\n    return getEntityDepthWithVisited(world, relation, entity, new Set())\n}\n\n/**\n * Marks an entity and its children as needing depth recalculation. This is used\n * internally when hierarchy changes occur.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component.\n * @param {EntityId} parent - The parent entity ID.\n * @param {SparseSet} dirty - The set to mark dirty entities in.\n * @param {SparseSet} [visited] - Internal set to track visited entities for cycle detection.\n */\nexport function markChildrenDirty(world: World, relation: ComponentRef, parent: EntityId, dirty: SparseSet, visited = createSparseSet()): void {\n    if (visited.has(parent)) return\n    visited.add(parent)\n    \n    const children = query(world, [relation(parent)])\n    for (const child of children) {\n        dirty.add(child)\n        markChildrenDirty(world, relation, child, dirty, visited)\n    }\n}\n\n/**\n * Updates hierarchy depth when a relation is added. This function is called automatically\n * when components are added to maintain accurate depth tracking.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component.\n * @param {EntityId} entity - The entity ID that had a relation added.\n * @param {EntityId} [parent] - The parent entity ID in the relation.\n * @param {Set<EntityId>} [updating] - Internal set to track entities being updated.\n */\nexport function updateHierarchyDepth(\n    world: World, \n    relation: ComponentRef, \n    entity: EntityId, \n    parent?: EntityId,\n    updating = new Set<EntityId>()\n): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Skip if hierarchy tracking is not active for this relation\n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        return\n    }\n    ensureDepthTracking(world, relation)\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    \n    // Prevent recursive updates - entity already being updated in this call stack\n    if (updating.has(entity)) {\n        // Just mark as dirty for later processing\n        hierarchyData.dirty.add(entity)\n        return\n    }\n    \n    updating.add(entity)\n    \n    const { depths, dirty } = hierarchyData\n    \n    // Calculate new depth\n    const newDepth = parent !== undefined ? \n        getEntityDepth(world, relation, parent) + 1 : 0\n    \n    // Prevent excessive depth (cycle detection)\n    if (newDepth > MAX_HIERARCHY_DEPTH) {\n        return\n    }\n    \n    const oldDepth = depths[entity]\n    setEntityDepth(hierarchyData, entity, newDepth, oldDepth === INVALID_DEPTH ? undefined : oldDepth)\n    \n    // If depth changed, mark children as dirty for recalculation\n    if (oldDepth !== newDepth) {\n        markChildrenDirty(world, relation, entity, dirty, createSparseSet())\n        invalidateQueryCache(world, relation)\n    }\n}\n\n/**\n * Invalidates hierarchy depth when a relation is removed. This function is called automatically\n * when components are removed to maintain accurate depth tracking.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component.\n * @param {EntityId} entity - The entity ID that had a relation removed.\n */\nexport function invalidateHierarchyDepth(world: World, relation: ComponentRef, entity: EntityId): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Skip if hierarchy tracking is not active for this relation\n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        return\n    }\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    let { depths } = hierarchyData\n    \n    // Expand array if needed\n    depths = growDepthsArray(hierarchyData, entity)\n    \n    invalidateSubtree(world, relation, entity, depths, createSparseSet())\n    invalidateQueryCache(world, relation)\n}\n\n/**\n * Recursively invalidates an entire subtree\n */\nfunction invalidateSubtree(world: World, relation: ComponentRef, entity: EntityId, depths: Uint32Array, visited: SparseSet): void {\n    if (visited.has(entity)) return\n    visited.add(entity)\n    \n    const ctx = (world as InternalWorld)[$internal]\n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    \n    // Invalidate this entity and update cache\n    if (entity < depths.length) {\n        const oldDepth = depths[entity]\n        if (oldDepth !== INVALID_DEPTH) {\n            hierarchyData.depths[entity] = INVALID_DEPTH\n            updateDepthCache(hierarchyData, entity, INVALID_DEPTH, oldDepth)\n        }\n    }\n    \n    // Find and invalidate all children\n    const children = query(world, [relation(entity)])\n    for (const child of children) {\n        invalidateSubtree(world, relation, child, depths, visited)\n    }\n}\n\n/**\n * Processes all dirty depth calculations for a relation. This ensures all cached\n * depth values are up to date before performing hierarchy operations.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component to flush dirty depths for.\n */\nexport function flushDirtyDepths(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    const hierarchyData = ctx.hierarchyData.get(relation)\n    \n    if (!hierarchyData) return\n    \n    const { dirty, depths } = hierarchyData\n    \n    if (dirty.dense.length === 0) return\n    \n    // Simple approach: just calculate all dirty depths\n    for (const entity of dirty.dense) {\n        if (depths[entity] === INVALID_DEPTH) {\n            const newDepth = calculateEntityDepth(world, relation, entity)\n            setEntityDepth(hierarchyData, entity, newDepth)\n        }\n    }\n    \n    dirty.reset()\n}\n\n/**\n * Query entities in hierarchical order (depth-based ordering). Returns entities grouped by depth:\n * all depth 0, then depth 1, then depth 2, etc. This ensures parents always come before their children.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @param {ComponentRef[]} components - Additional components to filter by.\n * @param {Object} [options] - Query options.\n * @param {boolean} [options.buffered] - Whether to return results as Uint32Array instead of number[].\n * @returns {QueryResult} Array or Uint32Array of entity IDs in hierarchical order.\n */\nexport function queryHierarchy(world: World, relation: ComponentRef, components: ComponentRef[], options: { buffered?: boolean } = {}): QueryResult {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Ensure hierarchy is active\n    getHierarchyData(world, relation)\n    \n    // Check cache for this query\n    const queryKey = queryHash(world, [relation, ...components])\n    const cached = ctx.hierarchyQueryCache.get(relation)\n    \n    if (cached && cached.hash === queryKey) {\n        return cached.result\n    }\n    \n    // Update any dirty depths before sorting\n    flushDirtyDepths(world, relation)\n    \n    // Ensure query is cached using existing infrastructure, then get Query object\n    queryInternal(world, components, options)\n    const queryObj = ctx.queriesHashMap.get(queryHash(world, components))!\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    const { depths } = hierarchyData\n    \n    // Sort the query's sparse set in place - no allocation needed!\n    queryObj.sort((a, b) => {\n        const depthA = depths[a]\n        const depthB = depths[b]\n        return depthA !== depthB ? depthA - depthB : a - b\n    })\n    \n    // Cache this result (dense is already the correct type)\n    const result = options.buffered ? queryObj.dense as Readonly<Uint32Array> : queryObj.dense as readonly EntityId[]\n    ctx.hierarchyQueryCache.set(relation, { hash: queryKey, result: result as QueryResult })\n    \n    return result\n}\n\n/**\n * Get all entities at a specific depth level in the hierarchy.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @param {number} depth - The specific depth level to query (0 = root level).\n * @param {Object} [options] - Query options.\n * @param {boolean} [options.buffered] - Whether to return results as Uint32Array instead of number[].\n * @returns {QueryResult} Array or Uint32Array of entity IDs at the specified depth.\n */\nexport function queryHierarchyDepth(world: World, relation: ComponentRef, depth: number, options: { buffered?: boolean } = {}): QueryResult {\n    // Ensure hierarchy is active and get data\n    const hierarchyData = getHierarchyData(world, relation)\n    flushDirtyDepths(world, relation)\n    \n    const entitiesAtDepth = hierarchyData.depthToEntities.get(depth)\n    \n    if (entitiesAtDepth) {\n        return options.buffered ? entitiesAtDepth.dense as Readonly<Uint32Array> : entitiesAtDepth.dense as readonly EntityId[]\n    }\n    \n    return options.buffered ? new Uint32Array(0) as Readonly<Uint32Array> : [] as readonly EntityId[]\n}\n\n/**\n * Get the hierarchy depth of a specific entity for a given relation.\n * @param {World} world - The world object.\n * @param {EntityId} entity - The entity ID to get depth for.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @returns {number} The depth of the entity (0 = root level, higher numbers = deeper).\n */\nexport function getHierarchyDepth(world: World, entity: EntityId, relation: ComponentRef): number {\n    getHierarchyData(world, relation)\n    return getEntityDepthWithVisited(world, relation, entity, new Set())\n}\n\n/**\n * Get the maximum depth in the hierarchy for a given relation.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @returns {number} The maximum depth found in the hierarchy.\n */\nexport function getMaxHierarchyDepth(world: World, relation: ComponentRef): number {\n    const hierarchyData = getHierarchyData(world, relation)\n    return hierarchyData.maxDepth\n}", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { EntityId, Prefab } from './Entity'\nimport { queryHierarchy, queryHierarchyDepth } from './Hierarchy'\n\n/**\n * @typedef {Readonly<Uint32Array> | readonly EntityId[]} QueryResult\n * @description The result of a query as a readonly array of entity IDs.\n */\nexport type QueryResult = Readonly<Uint32Array> | readonly EntityId[]\n\n/**\n * @typedef {Object} QueryOptions\n * @description Options for configuring query behavior.\n * @property {boolean} [commit=true] - Whether to commit pending entity removals before querying.\n * @property {boolean} [buffered=false] - Whether to return results as Uint32Array instead of number[].\n */\nexport interface QueryOptions {\n\tcommit?: boolean\n\tbuffered?: boolean\n}\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS using original blazing-fast bitmask evaluation.\n * @property {ComponentRef[]} allComponents - All components referenced in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Record<number, number>} masks - Bitmasks for each component generation.\n * @property {Record<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Record<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Record<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: Record<number, number>\n\torMasks: Record<number, number>\n\tnotMasks: Record<number, number>\n\thasMasks: Record<number, number>\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n\tqueues: Record<any, any>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n/**\n * Symbol for query operator type.\n * @type {Symbol}\n */\nexport const $opType = Symbol.for('bitecs-opType')\n\n/**\n * Symbol for query operator terms.\n * @type {Symbol}\n */\nexport const $opTerms = Symbol.for('bitecs-opTerms')\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opTerms] - The components involved in the operation.\n */\nexport type OpReturnType = {\n\t[$opType]: string\n\t[$opTerms]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator | HierarchyTerm} QueryTerm\n * @description A term in a query, either a component reference, query operator, or hierarchy term.\n */\nexport type QueryTerm = ComponentRef | QueryOperator | HierarchyTerm\n\n\nconst createOp = (type: string) => (...components: ComponentRef[]) => ({ [$opType]: type, [$opTerms]: components })\n\nexport const Or: QueryOperator = createOp('Or')\nexport const And: QueryOperator = createOp('And')\nexport const Not: QueryOperator = createOp('Not')\nexport const Any = Or\nexport const All = And\nexport const None = Not\n\n// NEW: Hierarchy combinator symbols\nexport const $hierarchyType = Symbol.for('bitecs-hierarchyType')\nexport const $hierarchyRel = Symbol.for('bitecs-hierarchyRel')\nexport const $hierarchyDepth = Symbol.for('bitecs-hierarchyDepth')\n\n/**\n * @typedef {Object} HierarchyTerm\n * @description Represents a hierarchy query term for topological ordering.\n * @property {symbol} [$hierarchyType] - Always 'Hierarchy'.\n * @property {ComponentRef} [$hierarchyRel] - The relation component for hierarchy.\n * @property {number} [$hierarchyDepth] - Optional depth limit.\n */\nexport type HierarchyTerm = {\n\t[$hierarchyType]: 'Hierarchy'\n\t[$hierarchyRel]: ComponentRef\n\t[$hierarchyDepth]?: number\n}\n\n/**\n * @function Hierarchy\n * @description Creates a hierarchy query term for topological ordering (parents before children).\n * @param {ComponentRef} relation - The relation component (e.g., ChildOf).\n * @param {number} [depth] - Optional depth limit.\n * @returns {HierarchyTerm} The hierarchy term.\n */\nexport const Hierarchy = (relation: ComponentRef, depth?: number): HierarchyTerm => ({\n\t[$hierarchyType]: 'Hierarchy',\n\t[$hierarchyRel]: relation,\n\t[$hierarchyDepth]: depth\n})\n\n/**\n * @function Cascade\n * @description Alias for Hierarchy - creates a hierarchy query term for topological ordering.\n * @param {ComponentRef} relation - The relation component (e.g., ChildOf).\n * @param {number} [depth] - Optional depth limit.\n * @returns {HierarchyTerm} The hierarchy term.\n */\nexport const Cascade = Hierarchy\n\n// Query modifier symbols\nexport const $modifierType = Symbol.for('bitecs-modifierType')\n\n/**\n * @typedef {Object} QueryModifier\n * @description Represents a query modifier that can be mixed into query terms.\n * @property {symbol} [$modifierType] - The type of modifier ('buffer' | 'nested').\n */\nexport type QueryModifier = {\n\t[$modifierType]: 'buffer' | 'nested'\n}\n\nexport const asBuffer: QueryModifier = { [$modifierType]: 'buffer' }\nexport const isNested: QueryModifier = { [$modifierType]: 'nested' }\nexport const noCommit = isNested\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...QueryTerm} terms - The query terms to observe.\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\n */\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\n\t[$opTerms]: QueryTerm[]\n}\n\nexport type ObservableHook = ReturnType<ObservableHookDef>\n\nconst createHook = (type: 'add' | 'remove' | 'set' | 'get') => (...terms: QueryTerm[]) => ({ [$opType]: type, [$opTerms]: terms })\nexport const onAdd: ObservableHookDef = createHook('add')\nexport const onRemove: ObservableHookDef = createHook('remove')\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({ [$opType]: 'set', [$opTerms]: [component] })\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({ [$opType]: 'get', [$opTerms]: [component] })\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ObservableHook} hook - The observable hook.\n * @param {function(number): any} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opTerms]: components } = hook\n\n\tif (type === 'add' || type === 'remove') {\n\t\tconst queryData = ctx.queriesHashMap.get(queryHash(world, components)) || registerQuery(world, components)\n\t\treturn queryData[type === 'add' ? 'addObservable' : 'removeObservable'].subscribe(callback)\n\t}\n\t\n\tif (type === 'set' || type === 'get') {\n\t\tif (components.length !== 1) throw new Error('Set and Get hooks can only observe a single component')\n\t\tconst componentData = ctx.componentMap.get(components[0]) || registerComponent(world, components[0])\n\t\treturn componentData[type === 'set' ? 'setObservable' : 'getObservable'].subscribe(callback)\n\t}\n\n\tthrow new Error(`Invalid hook type: ${type}`)\n}\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst getComponentId = (component: ComponentRef): number => {\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\t\treturn ctx.componentMap.get(component)!.id\n\t}\n\tconst termToString = (term: QueryTerm): string => \n\t\t$opType in term ? `${term[$opType].toLowerCase()}(${term[$opTerms].map(termToString).sort().join(',')})` : getComponentId(term).toString()\n\t\n\treturn terms.map(termToString).sort().join('-')\n}\n\n/**\n * @function registerQuery  \n * @description Registers a new query in the world using unified clause-mask compilation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\n\tconst queryComponents: ComponentRef[] = []\n\tconst collect = (term: QueryTerm) => {\n\t\tif ($opType in term) term[$opTerms].forEach(collect)\n\t\telse {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tqueryComponents.push(term)\n\t\t}\n\t}\n\tterms.forEach(collect)\n\t\n\t// Use original simple approach for blazing-fast simple queries\n\t// TODO: Add nested combinator support later if needed\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst addToArray = (arr: ComponentRef[], comps: ComponentRef[]) => {\n\t\tcomps.forEach(comp => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\tarr.push(comp)\n\t\t})\n\t}\n\t\n\tterms.forEach(term => {\n\t\tif ($opType in term) {\n\t\t\tconst { [$opType]: type, [$opTerms]: comps } = term\n\t\t\tif (type === 'Not') addToArray(notComponents, comps)\n\t\t\telse if (type === 'Or') addToArray(orComponents, comps)\n\t\t\telse if (type === 'And') addToArray(components, comps)\n\t\t\telse throw new Error(`Nested combinator ${type} not supported yet - use simple queries for best performance`)\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst allComponentsData = queryComponents.map(c => ctx.componentMap.get(c)!)\n\tconst generations = [...new Set(allComponentsData.map(c => c.generationId))]\n\tconst reduceBitflags = (a: Record<number, number>, c: ComponentData) => (a[c.generationId] = (a[c.generationId] || 0) | c.bitflag, a)\n\t\n\tconst masks = components.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponentsData.reduce(reduceBitflags, {})\n\n\tconst query = Object.assign(options.buffered ? createUint32SparseSet() : createSparseSet(), {\n\t\tallComponents: queryComponents, orComponents, notComponents, masks, notMasks, orMasks, hasMasks, generations,\n\t\ttoRemove: createSparseSet(), addObservable: createObservable(), removeObservable: createObservable(), queues: {}\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponentsData.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, eid, Prefab)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n\n\n/**\n * @function queryInternal\n * @description Internal implementation for nested queries.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function queryInternal(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\n\treturn options.buffered ? queryData.dense as Readonly<Uint32Array> : queryData.dense as readonly EntityId[]\n}\n\n/**\n * @function query\n * @description Performs a unified query operation with configurable options.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {...QueryModifier} modifiers - Query modifiers (asBuffer, isNested, etc.).\n * @returns {QueryResult} The result of the query.\n */\nexport function query(world: World, terms: QueryTerm[], ...modifiers: (QueryModifier | QueryOptions)[]): QueryResult {\n\tconst hierarchyTerm = terms.find(term => term && typeof term === 'object' && $hierarchyType in term) as HierarchyTerm | undefined\n\tconst regularTerms = terms.filter(term => !(term && typeof term === 'object' && $hierarchyType in term))\n\t\n\tlet buffered = false, commit = true\n\tconst hasModifiers = modifiers.some(m => m && typeof m === 'object' && $modifierType in m)\n\t\n\tfor (const modifier of modifiers) {\n\t\tif (hasModifiers && modifier && typeof modifier === 'object' && $modifierType in modifier) {\n\t\t\tconst mod = modifier as QueryModifier\n\t\t\tif (mod[$modifierType] === 'buffer') buffered = true\n\t\t\tif (mod[$modifierType] === 'nested') commit = false\n\t\t} else if (!hasModifiers) {\n\t\t\tconst opts = modifier as QueryOptions\n\t\t\tif (opts.buffered !== undefined) buffered = opts.buffered\n\t\t\tif (opts.commit !== undefined) commit = opts.commit\n\t\t}\n\t}\n\n\tif (hierarchyTerm) {\n\t\tconst { [$hierarchyRel]: relation, [$hierarchyDepth]: depth } = hierarchyTerm\n\t\treturn depth !== undefined ? queryHierarchyDepth(world, relation, depth, { buffered }) : queryHierarchy(world, relation, regularTerms, { buffered })\n\t}\n\n\tif (commit) commitRemovals(world)\n\treturn queryInternal(world, regularTerms, { buffered })\n}\n\n\n\n/**\n * @function queryCheckEntity\n * @description Original blazing-fast query evaluation using simple bitmasks.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tlet hasOrMatch = Object.keys(orMasks).length === 0\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) !== 0) {\n\t\t\thasOrMatch = true\n\t\t}\n\t}\n\n\treturn hasOrMatch\n}\n\n\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport {\n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World, WorldContext } from './World'\nimport { updateHierarchyDepth, invalidateHierarchyDepth } from './Hierarchy'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n\tgetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable(),\n\t\tgetObservable: createObservable(),\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to check for.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n/**\n * Retrieves the data associated with a component for a specific entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to retrieve data for.\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\n */\nexport const getComponent = (world: World, eid: EntityId, component: ComponentRef): any => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\treturn undefined\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\treturn undefined\n\t}\n\n\t// Notify observers that this component is being accessed\n\treturn componentData.getObservable.notify(eid)\n}\n\n/**\n * Helper function to set component data.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\n */\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\n\tcomponent,\n\tdata\n})\n\n/**\n * Recursvely inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n * @param {boolean} isFirstSuper - Whether this is the first super in the inheritance chain.\n */\nconst recursivelyInherit = (ctx: WorldContext, world: World, baseEid: EntityId, inheritedEid: EntityId, visited = new Set<EntityId>()): void => {\n\t// Guard against circular inheritance\n\tif (visited.has(inheritedEid)) return\n\tvisited.add(inheritedEid)\n\t\n\t// Add IsA relation first\n\taddComponent(world, baseEid, IsA(inheritedEid))\n\t\n\t// Copy components and their data from this level\n\t// This needs to happen before recursing to ancestors so closer ancestors take precedence\n\tfor (const component of getEntityComponents(world, inheritedEid)) {\n\t\t// TODO: inherit reference vs copy\n\t\tif (component === Prefab) continue\n\t\t\n\t\t// Only add component if entity doesn't already have it\n\t\t// This ensures closer ancestors take precedence\n\t\tif (!hasComponent(world, baseEid, component)) {\n\t\t\taddComponent(world, baseEid, component)\n\t\t\t\n\t\t\tconst componentData = ctx.componentMap.get(component)\n\t\t\tif (componentData?.setObservable) {\n\t\t\t\tconst data = getComponent(world, inheritedEid, component)\n\t\t\t\tcomponentData.setObservable.notify(baseEid, data)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Then recursively inherit from ancestors\n\t// This ensures more distant ancestors don't override closer ones\n\tfor (const parentEid of getRelationTargets(world, inheritedEid, IsA)) {\n\t\trecursivelyInherit(ctx, world, baseEid, parentEid, visited)\n\t}\n}\n\n/**\n * Represents a component with data to be set on an entity.\n */\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\n\n/**\n * Sets component data on an entity. Always calls the setter observable even if entity already has the component.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const setComponent = (\n  world: World,\n  eid: EntityId,\n  component: ComponentRef,\n  data: any\n): void => {\n  addComponent(world, eid, set(component, data));\n};\n\n/**\n * Adds a single component to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef | ComponentSetter} componentOrSet - Component to add or set.\n * @returns {boolean} True if component was added, false if it already existed.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, eid: EntityId, componentOrSet: ComponentRef | ComponentSetter): boolean => {\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\n\t}\n\t\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\n\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\n\n\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\tconst componentData = ctx.componentMap.get(component)!\n\t\n\t// If entity already has component, just call setter and return false\n\tif (hasComponent(world, eid, component)) {\n\t\tif (data !== undefined) {\n\t\t\tcomponentData.setObservable.notify(eid, data)\n\t\t}\n\t\treturn false\n\t}\n\n\tconst { generationId, bitflag, queries } = componentData\n\n\tctx.entityMasks[generationId][eid] |= bitflag\n\n\tif (!hasComponent(world, eid, Prefab)) {\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\t}\n\tctx.entityComponents.get(eid)!.add(component)\n\n\t// Call setter AFTER component is added and onAdd callbacks have fired\n\tif (data !== undefined) {\n\t\tcomponentData.setObservable.notify(eid, data)\n\t}\n\tif (component[$isPairComponent]) {\n\t\tconst relation = component[$relation]\n\t\tconst target = component[$pairTarget]\n\n\t\t// Add both Wildcard pairs for relation and target\n\t\taddComponents(world, eid, Pair(relation, Wildcard), Pair(Wildcard, target))\n\n\t\t// For non-Wildcard targets, add Wildcard pair to track relation targets\n\t\tif (typeof target === 'number') {\n\t\t\t// Add Wildcard pair for target being a relation target\n\t\t\taddComponents(world, target, Pair(Wildcard, eid), Pair(Wildcard, relation))\n\t\t\t// Track entities with relations for autoRemoveSubject\n\t\t\tctx.entitiesWithRelations.add(target)\n\t\t\tctx.entitiesWithRelations.add(eid)\n\t\t}\n\n\t\t// add target to a set to make autoRemoveSubject checks faster\n\t\tctx.entitiesWithRelations.add(target)\n\n\t\tconst relationData = relation[$relationData]\n\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\n\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\n\t\t\t}\n\t\t}\n\n\t\tif (relation === IsA) {\n\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\n\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\trecursivelyInherit(ctx, world, eid, inherited)\n\t\t\t}\n\t\t}\n\n\t\t// Update hierarchy depth tracking for this relation\n\t\tupdateHierarchyDepth(world, relation, eid, typeof target === 'number' ? target : undefined)\n\t}\n\n\treturn true\n}\n\n/**\n * Adds multiple components to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {(ComponentRef | ComponentSetter)[] | ComponentRef | ComponentSetter} components - Components to add or set (array or spread args).\n * @throws {Error} If the entity does not exist in the world.\n */\nexport function addComponents(world: World, eid: EntityId, components: (ComponentRef | ComponentSetter)[]): void;\nexport function addComponents(world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void;\nexport function addComponents(world: World, eid: EntityId, ...args: any[]): void {\n\tconst components = Array.isArray(args[0]) ? args[0] : args\n\tcomponents.forEach((componentOrSet: ComponentRef | ComponentSetter) => {\n\t\taddComponent(world, eid, componentOrSet)\n\t})\n}\n\n/**\n * Removes one or more components from an entity.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(component => {\n\t\tif (!hasComponent(world, eid, component)) return\n\n\t\tconst componentNode = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentNode\n\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\n\t\tctx.entityComponents.get(eid)!.delete(component)\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst target = component[$pairTarget]\n\t\t\tconst relation = component[$relation]\n\t\t\t\n\t\t\t// Invalidate hierarchy depth tracking for this relation\n\t\t\tinvalidateHierarchyDepth(world, relation, eid)\n\t\t\t\n\t\t\t// Remove Wildcard pair from subject\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\t// Remove Wildcard pairs from target (if target is an entity)\n\t\t\tif (typeof target === 'number' && entityExists(world, target)) {\n\t\t\t\tremoveComponent(world, target, Pair(Wildcard, eid))\n\t\t\t\tremoveComponent(world, target, Pair(Wildcard, relation))\n\t\t\t}\n\n\t\t\t// Remove relation Wildcard pair if no other targets\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\n\t\t\tif (otherTargets.length === 0) {\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Removes one or more components from an entity. This is an alias for removeComponent.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponents = removeComponent\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tquery,\n\tnoCommit,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport type EntityId = number\n\nexport const Prefab = {}\n\n/**\n * Creates a new prefab entity in the world. Prefabs are special entities marked with the Prefab component\n * that are excluded from normal queries and can be used as templates for creating other entities.\n * @param {World} world - The world object to create the prefab in.\n * @returns {EntityId} The entity ID of the created prefab.\n */\nexport const addPrefab = (world: World): EntityId => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, eid, Prefab)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): EntityId => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, child, ChildOf(parent))\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n\t\tif (ctx.entitiesWithRelations.has(currentEid)) {\n\t\t\tfor (const subject of query(world, [Wildcard(currentEid)], noCommit)) {\n\t\t\t\tif (!entityExists(world, subject)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const component of ctx.entityComponents.get(subject)!) {\n\t\t\t\t\tif (!component[$isPairComponent]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst relation = component[$relation]\n\t\t\t\t\tconst relationData = relation[$relationData]\n\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\n\n\t\t\t\t\tif (component[$pairTarget] === currentEid) {\n\t\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, component))\n\t\t\t\t\t\tif (relationData.autoRemoveSubject) {\n\t\t\t\t\t\t\tremovalQueue.push(subject)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationData.onTargetRemoved) {\n\t\t\t\t\t\t\tcomponentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.entitiesWithRelations.delete(currentEid)\n\t\t}\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error(`getEntityComponents: entity id is undefined.`)\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error(`getEntityComponents: entity ${eid} does not exist in the world.`)\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "type Func = (...args: any) => any\nexport const pipe = <T extends Func, U extends Func, R extends Func>\n    (...functions: [T, ...U[], R]): ((...args: Parameters<T>) => ReturnType<R>) => {\n    return (...args: Parameters<T>): ReturnType<R> => \n        functions.reduce((result, fn) => [fn(...result)], args as any)[0]\n}\n", "export {\n\tcreateWorld,\n\tresetWorld,\n\tdeleteWorld,\n\tgetWorldComponents,\n\tgetAllEntities,\n\t$internal,\n} from './World'\n\nexport type {\n\tWorld,\n\tInternalWorld,\n\tWorldContext\n} from './World'\n\nexport {\n\taddEntity,\n\tremoveEntity,\n\tgetEntityComponents,\n\tentityExists,\n\tPrefab,\n\taddPrefab,\n} from './Entity'\n\nexport type {\n\tEntityId,\n} from './Entity'\n\nexport { \n\tcreateEntityIndex,\n\tgetId,\n\tgetVersion,\n\twithVersioning,\n} from './EntityIndex'\n\nexport {\n\tregisterComponent,\n\tregisterComponents,\n\thasComponent,\n\taddComponent,\n\taddComponents,\n\tsetComponent,\n\tremoveComponent,\n\tremoveComponents,\n\tgetComponent,\n\tset\n} from './Component'\n\nexport type {\n\tComponentRef,\n\tComponentData\n} from './Component'\n\nexport {\n\tcommitRemovals,\n\tremoveQuery,\n\tregisterQuery,\n\tquery,\n\tobserve,\n\tonAdd,\n\tonRemove,\n\tOr,\n\tAnd,\n\tNot,\n\tAny,\n\tAll,\n\tNone,\n\tonGet,\n\tonSet,\n\tHierarchy,\n\tCascade,\n\tasBuffer,\n\tisNested,\n\tnoCommit,\n} from './Query'\n\nexport type {\n\tObservableHookDef,\n\tObservableHook,\n\tQueryResult,\n\tQuery,\n\tQueryOperatorType,\n\tOpReturnType,\n\tQueryOperator,\n\tQueryTerm,\n\tQueryOptions,\n\tHierarchyTerm,\n\tQueryModifier,\n} from './Query'\n\nexport { pipe } from './utils/pipe'\n\nexport {\n\twithAutoRemoveSubject,\n\twithOnTargetRemoved,\n\twithStore,\n\tcreateRelation,\n\tgetRelationTargets,\n\tWildcard,\n\tIsA,\n\tPair,\n\tisRelation,\n\tisWildcard,\n} from './Relation'\n\nexport type {\n\tOnTargetRemovedCallback,\n\tRelation,\n\tRelationTarget,\n} from './Relation'\n\nexport {\n\tgetHierarchyDepth,\n\tgetMaxHierarchyDepth,\n} from './Hierarchy'\n"],
  "mappings": "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",
  "names": ["_a", "_b", "query", "subject", "component", "_i"]
}
