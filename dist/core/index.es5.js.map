{
  "version": 3,
  "sources": ["../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/utils/SparseSet.ts", "../../src/core/utils/Observer.ts", "../../src/core/Relation.ts", "../../src/core/Hierarchy.ts", "../../src/core/Query.ts", "../../src/core/Component.ts", "../../src/core/Entity.ts", "../../src/core/utils/pipe.ts", "../../src/core/index.ts"],
  "sourcesContent": ["export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n    /** Flag indicating if versioning is enabled. */\n    versioning: boolean\n    /** Number of bits used for versioning. */\n    versionBits: number\n    /** Bit mask for entity ID. */\n    entityMask: number\n    /** Bit shift for version. */\n    versionShift: number\n    /** Bit mask for version. */\n    versionMask: number\n}\n\n/**\n * Extracts the entity ID from a versioned entity ID by stripping off the version.\n * @param {EntityIndex} index - The EntityIndex containing the masks.\n * @param {number} id - The versioned entity ID.\n * @returns {number} The entity ID without the version.\n */\nexport const getId = (index: EntityIndex, id: number): number => id & index.entityMask;\n\n/**\n * Extracts the version from an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The version.\n */\nexport const getVersion = (index: EntityIndex, id: number): number => \n    (id >>> index.versionShift) & ((1 << index.versionBits) - 1);\n\n/**\n * Increments the version of an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The new entity ID with incremented version.\n */\nexport const incrementVersion = (index: EntityIndex, id: number): number => {\n    const currentVersion = getVersion(index, id);\n    const newVersion = (currentVersion + 1) & ((1 << index.versionBits) - 1);\n    return (id & index.entityMask) | (newVersion << index.versionShift);\n}\n\n/**\n * Creates configuration options for entity ID recycling with versioning.\n * @param {number} [versionBits] - Optional number of bits to use for version numbers. Defaults to 8 if not specified.\n * @returns {object} Configuration object with versioning enabled and specified version bits.\n */\nexport const withVersioning = (versionBits?: number) => ({\n    versioning: true,\n    versionBits\n})\n\n/**\n * Creates and initializes a new EntityIndex.\n * @param {object|function} [options] - Optional configuration object from withVersioning() or withVersioning function.\n * @param {boolean} options.versioning - Flag to enable versioning for recycled IDs.\n * @param {number} options.versionBits - Number of bits to use for versioning (default: 8).\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (options?: ReturnType<typeof withVersioning> | typeof withVersioning): EntityIndex => {\n    const config = options \n        ? typeof options === 'function' \n            ? options()\n            : options\n        : { versioning: false, versionBits: 8 }\n\n    const versionBits = config.versionBits ?? 8\n    const versioning = config.versioning ?? false\n    \n    const entityBits = 32 - versionBits\n    const entityMask = (1 << entityBits) - 1\n    const versionShift = entityBits\n    const versionMask = ((1 << versionBits) - 1) << versionShift\n\n    return {\n        aliveCount: 0,\n        dense: [],\n        sparse: [],\n        maxId: 0,\n        versioning,\n        versionBits,\n        entityMask,\n        versionShift,\n        versionMask\n    }\n}\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount];\n        const entityId = recycledId;\n        index.sparse[entityId] = index.aliveCount;\n        index.aliveCount++;\n        return recycledId;\n    }\n\n    // Create new id\n    const id = ++index.maxId;\n    index.dense.push(id);\n    index.sparse[id] = index.aliveCount;\n    index.aliveCount++;\n\n    return id;\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const denseIndex = index.sparse[id];\n    if (denseIndex === undefined || denseIndex >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return;\n    }\n\n    const lastIndex = index.aliveCount - 1;\n    const lastId = index.dense[lastIndex];\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex;\n    index.dense[denseIndex] = lastId;\n\n    // Update the removed entity's record\n    index.sparse[id] = lastIndex; // Set to lastIndex instead of undefined\n    index.dense[lastIndex] = id; // Keep the original id, don't strip version\n\n    // Version the ID if enabled\n    if (index.versioning) {\n        const newId = incrementVersion(index, id);\n        index.dense[lastIndex] = newId;\n    }\n\n    index.aliveCount--;\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const entityId = getId(index, id);\n    const denseIndex = index.sparse[entityId];\n    return denseIndex !== undefined && denseIndex < index.aliveCount && index.dense[denseIndex] === id;\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query, QueryResult } from './Query'\nimport { EntityId } from './Entity'\nimport { type SparseSet } from './utils/SparseSet'\n\nexport const $internal = Symbol.for('bitecs_internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<EntityId, Set<ComponentRef>>\n    bitflag: number\n    componentMap: Map<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n    entitiesWithRelations: Set<EntityId>\n    hierarchyData: Map<ComponentRef, {\n        depths: Uint32Array\n        dirty: SparseSet\n        depthToEntities: Map<number, SparseSet>\n        maxDepth: number\n    }>\n    hierarchyActiveRelations: Set<ComponentRef>\n    hierarchyQueryCache: Map<ComponentRef, { hash: string, result: QueryResult }>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \n    defineHiddenProperty(context || {} as T, $internal, {\n        entityIndex: entityIndex || createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new Map(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n        entitiesWithRelations: new Set(),\n        // Initialize hierarchy tracking\n        hierarchyData: new Map(),\n        hierarchyActiveRelations: new Set(),\n        hierarchyQueryCache: new Map(),\n}) as World<T>\n\n/**\n * Creates a new world with various configurations.\n * @template T\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\n * @returns {World<T>} The created world.\n */\n\n// TODO: middleware\n\nexport function createWorld<T extends object = {}>(\n    ...args: Array<EntityIndex | T>\n): World<T> {\n    let entityIndex: EntityIndex | undefined\n    let context: T | undefined\n\n    args.forEach(arg => {\n        if (typeof arg === 'object' && 'dense' in arg && 'sparse' in arg && 'aliveCount' in arg) {\n            entityIndex = arg as EntityIndex\n        } else if (typeof arg === 'object') {\n            context = arg as T\n        }\n    })\n\n    return createBaseWorld<T>(context, entityIndex)\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    ctx.entitiesWithRelations = new Set()\n    ctx.hierarchyData = new Map()\n    ctx.hierarchyActiveRelations = new Set()\n    ctx.hierarchyQueryCache = new Map()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World): readonly EntityId[] => Array.from((world as InternalWorld)[$internal].entityComponents.keys())\n", "export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n    sort: (compareFn?: (a: number, b: number) => number) => void\n}\n\nexport const createSparseSet = (): SparseSet => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\tconst sort = (compareFn?: (a: number, b: number) => number) => {\n\t\tdense.sort(compareFn)\n\t\tfor (let i = 0; i < dense.length; i++) {\n\t\t\tsparse[dense[i]] = i\n\t\t}\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t\tsort,\n\t}\n}\n\nconst SharedArrayBufferOrArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(new SharedArrayBufferOrArrayBuffer(initialCapacity * 4))\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(new SharedArrayBufferOrArrayBuffer(dense.length * 2 * 4))\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\tconst sort = (compareFn?: (a: number, b: number) => number) => {\n\t\t// Create temporary array for sorting\n\t\tconst temp = Array.from(dense.subarray(0, length))\n\t\ttemp.sort(compareFn)\n\t\t\n\t\t// Copy back to dense array\n\t\tfor (let i = 0; i < temp.length; i++) {\n\t\t\tdense[i] = temp[i]\n\t\t}\n\t\t\n\t\t// rebuild sparse mapping\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tsparse[dense[i]] = i\n\t\t}\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t\tsort,\n\t}\n}", "import { EntityId } from \"../Entity\"\n\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: EntityId, ...args: any[])  => void | object\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n  const notify = (entity: EntityId, ...args: any[]) => {\n    return Array.from(observers).reduce((acc, listener) => {\n      const result = listener(entity, ...args)\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\n    }, {})\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { getEntityComponents, World } from '.'\nimport { EntityId } from './Entity'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number} target - The target entity ID.\n */\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol.for('bitecs-relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol.for('bitecs-pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol.for('bitecs-isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol.for('bitecs-relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: (eid: EntityId) => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = data.initStore ? data.initStore(target) : {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: (eid: EntityId) => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n    return relation\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>): number[] => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard && !isRelation(c[$pairTarget])) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n\n/**\n * Symbol used to mark a relation as a wildcard relation\n */\nexport const $wildcard = Symbol.for('bitecs-wildcard')\n\n/**\n * Creates a wildcard relation that matches any target.\n * @template T\n * @returns {Relation<T>} The created wildcard relation.\n */\nexport function createWildcardRelation<T>(): Relation<T> {\n    const relation = createBaseRelation<T>()\n    Object.defineProperty(relation, $wildcard, {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: false\n    })\n    return relation\n}\n\n/**\n * Gets the singleton wildcard instance.\n * @returns {Relation<any>} The global wildcard relation instance.\n */\nexport function getWildcard(): Relation<any> {\n    const GLOBAL_WILDCARD = Symbol.for('bitecs-global-wildcard')\n    \n    if (!(globalThis as any)[GLOBAL_WILDCARD]) {\n        (globalThis as any)[GLOBAL_WILDCARD] = createWildcardRelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_WILDCARD]\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard = getWildcard()\n\n/**\n * Creates an IsA relation.\n * @template T\n * @returns {Relation<T>} The created IsA relation.\n */\nexport function createIsARelation<T>(): Relation<T> {\n    return createBaseRelation<T>()\n}\n\n/**\n * Gets the singleton IsA instance.\n * @returns {Relation<any>} The global IsA relation instance.\n */\nexport function getIsA(): Relation<any> {\n    const GLOBAL_ISA = Symbol.for('bitecs-global-isa')\n    \n    if (!(globalThis as any)[GLOBAL_ISA]) {\n        (globalThis as any)[GLOBAL_ISA] = createIsARelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_ISA]\n}\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA = getIsA()\n\n/**\n * Checks if a relation is a wildcard relation.\n * @param {any} relation - The relation to check.\n * @returns {boolean} True if the relation is a wildcard relation, false otherwise.\n */\nexport function isWildcard(relation: any): boolean {\n    if (!relation) return false\n    const symbols = Object.getOwnPropertySymbols(relation)\n    return symbols.includes($wildcard)\n}\n\n/**\n * Checks if a component is a relation.\n * @param {any} component - The component to check.\n * @returns {boolean} True if the component is a relation, false otherwise.\n */\nexport function isRelation(component: any): boolean {\n    if (!component) return false\n    const symbols = Object.getOwnPropertySymbols(component)\n    return symbols.includes($relationData)\n}\n", "import { World, InternalWorld, $internal } from './World'\nimport { EntityId } from './Entity'\nimport { ComponentRef } from './Component'\nimport { getRelationTargets, Wildcard, Pair } from './Relation'\nimport { query, queryHash, queryInternal, type QueryResult } from './Query'\nimport { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\n\n// Constants\nconst MAX_HIERARCHY_DEPTH = 64 // Prevent stack overflow in deep hierarchies\nconst INVALID_DEPTH = 0xFFFFFFFF // 32-bit max value indicates uncomputed depth\nconst DEFAULT_BUFFER_GROWTH = 1024 // Growth increment for depth arrays\n\ntype HierarchyData = {\n    depths: Uint32Array\n    dirty: SparseSet\n    depthToEntities: Map<number, SparseSet>\n    maxDepth: number\n}\n\n/**\n * Grows the depths array to accommodate a specific entity\n */\nfunction growDepthsArray(hierarchyData: HierarchyData, entity: EntityId): Uint32Array {\n    const { depths } = hierarchyData\n    if (entity < depths.length) return depths\n    \n    const newSize = Math.max(entity + 1, depths.length * 2, depths.length + DEFAULT_BUFFER_GROWTH)\n    const newDepths = new Uint32Array(newSize)\n    newDepths.fill(INVALID_DEPTH)\n    newDepths.set(depths)\n    hierarchyData.depths = newDepths\n    return newDepths\n}\n\n/**\n * Updates the depthToEntities cache when an entity's depth changes\n */\nfunction updateDepthCache(hierarchyData: HierarchyData, entity: EntityId, newDepth: number, oldDepth?: number): void {\n    const { depthToEntities } = hierarchyData\n    \n    // Remove from old depth cache if exists\n    if (oldDepth !== undefined && oldDepth !== INVALID_DEPTH) {\n        const oldSet = depthToEntities.get(oldDepth)\n        if (oldSet) {\n            oldSet.remove(entity)\n            if (oldSet.dense.length === 0) depthToEntities.delete(oldDepth)\n        }\n    }\n    \n    // Add to new depth cache (skip INVALID_DEPTH)\n    if (newDepth !== INVALID_DEPTH) {\n        if (!depthToEntities.has(newDepth)) depthToEntities.set(newDepth, createUint32SparseSet())\n        depthToEntities.get(newDepth)!.add(entity)\n    }\n}\n\n/**\n * Updates max depth if the new depth is greater\n */\nfunction updateMaxDepth(hierarchyData: HierarchyData, depth: number): void {\n    if (depth > hierarchyData.maxDepth) {\n        hierarchyData.maxDepth = depth\n    }\n}\n\n/**\n * Sets entity depth and updates all related caches\n */\nfunction setEntityDepth(hierarchyData: HierarchyData, entity: EntityId, newDepth: number, oldDepth?: number): void {\n    hierarchyData.depths[entity] = newDepth\n    updateDepthCache(hierarchyData, entity, newDepth, oldDepth)\n    updateMaxDepth(hierarchyData, newDepth)\n}\n\n/**\n * Invalidates hierarchy query cache for a relation\n */\nfunction invalidateQueryCache(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.hierarchyQueryCache.delete(relation)\n}\n\n/**\n * Gets hierarchy data for a relation, activating tracking if needed\n */\nfunction getHierarchyData(world: World, relation: ComponentRef): HierarchyData {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        ctx.hierarchyActiveRelations.add(relation)\n        \n        // Initialize tracking for this relation\n        ensureDepthTracking(world, relation)\n        \n        // Populate depths for all existing entities and their targets\n        populateExistingDepths(world, relation)\n    }\n    \n    return ctx.hierarchyData.get(relation)!\n}\n\n/**\n * Populates depth calculations for all existing entities with this relation\n */\nfunction populateExistingDepths(world: World, relation: ComponentRef): void {\n    const entitiesWithRelation = query(world, [Pair(relation, Wildcard)])\n    \n    // Calculate depths for entities with this relation\n    for (const entity of entitiesWithRelation) {\n        getEntityDepth(world, relation, entity)\n    }\n    \n    // Calculate depths for all relation targets (avoid extra allocation)\n    const processedTargets = new Set<EntityId>()\n    for (const entity of entitiesWithRelation) {\n        for (const target of getRelationTargets(world, entity, relation)) {\n            if (!processedTargets.has(target)) {\n                processedTargets.add(target)\n                getEntityDepth(world, relation, target)\n            }\n        }\n    }\n}\n\n/**\n * Ensures depth tracking is initialized for a relation. This must be called before\n * using hierarchy features for a specific relation component.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component to initialize tracking for.\n */\nexport function ensureDepthTracking(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    if (!ctx.hierarchyData.has(relation)) {\n        const initialSize = Math.max(DEFAULT_BUFFER_GROWTH, ctx.entityIndex.dense.length * 2)\n        const depthArray = new Uint32Array(initialSize)\n        depthArray.fill(INVALID_DEPTH)\n        \n        ctx.hierarchyData.set(relation, {\n            depths: depthArray,\n            dirty: createSparseSet(),\n            depthToEntities: new Map(),\n            maxDepth: 0\n        })\n    }\n}\n\n/**\n * Calculates the hierarchy depth of an entity for a given relation. Depth is measured\n * as the distance from the root entities (entities with no parent relations).\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component to calculate depth for.\n * @param {EntityId} entity - The entity ID to calculate depth for.\n * @param {Set<EntityId>} [visited] - Internal set to track visited entities for cycle detection.\n * @returns {number} The hierarchy depth of the entity.\n */\nexport function calculateEntityDepth(world: World, relation: ComponentRef, entity: EntityId, visited = new Set<EntityId>()): number {\n    if (visited.has(entity)) return 0\n    visited.add(entity)\n    \n    const targets = getRelationTargets(world, entity, relation)\n    if (targets.length === 0) return 0\n    if (targets.length === 1) return getEntityDepthWithVisited(world, relation, targets[0], visited) + 1\n    \n    let minDepth = Infinity\n    for (const target of targets) {\n        const depth = getEntityDepthWithVisited(world, relation, target, visited)\n        if (depth < minDepth) {\n            minDepth = depth\n            if (minDepth === 0) break\n        }\n    }\n    return minDepth === Infinity ? 0 : minDepth + 1\n}\n\n/**\n * Internal helper to get entity depth with cycle detection\n */\nfunction getEntityDepthWithVisited(world: World, relation: ComponentRef, entity: EntityId, visited: Set<EntityId>): number {\n    const ctx = (world as InternalWorld)[$internal]\n    ensureDepthTracking(world, relation)\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    let { depths } = hierarchyData\n    \n    depths = growDepthsArray(hierarchyData, entity)\n    \n    if (depths[entity] === INVALID_DEPTH) {\n        const depth = calculateEntityDepth(world, relation, entity, visited)\n        setEntityDepth(hierarchyData, entity, depth)\n        return depth\n    }\n    \n    return depths[entity]\n}\n\n/**\n * Gets the cached depth of an entity, calculating if needed\n */\nfunction getEntityDepth(world: World, relation: ComponentRef, entity: EntityId): number {\n    return getEntityDepthWithVisited(world, relation, entity, new Set())\n}\n\n/**\n * Marks an entity and its children as needing depth recalculation. This is used\n * internally when hierarchy changes occur.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component.\n * @param {EntityId} parent - The parent entity ID.\n * @param {SparseSet} dirty - The set to mark dirty entities in.\n * @param {SparseSet} [visited] - Internal set to track visited entities for cycle detection.\n */\nexport function markChildrenDirty(world: World, relation: ComponentRef, parent: EntityId, dirty: SparseSet, visited = createSparseSet()): void {\n    if (visited.has(parent)) return\n    visited.add(parent)\n    \n    const children = query(world, [relation(parent)])\n    for (const child of children) {\n        dirty.add(child)\n        markChildrenDirty(world, relation, child, dirty, visited)\n    }\n}\n\n/**\n * Updates hierarchy depth when a relation is added. This function is called automatically\n * when components are added to maintain accurate depth tracking.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component.\n * @param {EntityId} entity - The entity ID that had a relation added.\n * @param {EntityId} [parent] - The parent entity ID in the relation.\n * @param {Set<EntityId>} [updating] - Internal set to track entities being updated.\n */\nexport function updateHierarchyDepth(\n    world: World, \n    relation: ComponentRef, \n    entity: EntityId, \n    parent?: EntityId,\n    updating = new Set<EntityId>()\n): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Skip if hierarchy tracking is not active for this relation\n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        return\n    }\n    ensureDepthTracking(world, relation)\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    \n    // Prevent recursive updates - entity already being updated in this call stack\n    if (updating.has(entity)) {\n        // Just mark as dirty for later processing\n        hierarchyData.dirty.add(entity)\n        return\n    }\n    \n    updating.add(entity)\n    \n    const { depths, dirty } = hierarchyData\n    \n    // Calculate new depth\n    const newDepth = parent !== undefined ? \n        getEntityDepth(world, relation, parent) + 1 : 0\n    \n    // Prevent excessive depth (cycle detection)\n    if (newDepth > MAX_HIERARCHY_DEPTH) {\n        return\n    }\n    \n    const oldDepth = depths[entity]\n    setEntityDepth(hierarchyData, entity, newDepth, oldDepth === INVALID_DEPTH ? undefined : oldDepth)\n    \n    // If depth changed, mark children as dirty for recalculation\n    if (oldDepth !== newDepth) {\n        markChildrenDirty(world, relation, entity, dirty, createSparseSet())\n        invalidateQueryCache(world, relation)\n    }\n}\n\n/**\n * Invalidates hierarchy depth when a relation is removed. This function is called automatically\n * when components are removed to maintain accurate depth tracking.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component.\n * @param {EntityId} entity - The entity ID that had a relation removed.\n */\nexport function invalidateHierarchyDepth(world: World, relation: ComponentRef, entity: EntityId): void {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Skip if hierarchy tracking is not active for this relation\n    if (!ctx.hierarchyActiveRelations.has(relation)) {\n        return\n    }\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    let { depths } = hierarchyData\n    \n    // Expand array if needed\n    depths = growDepthsArray(hierarchyData, entity)\n    \n    invalidateSubtree(world, relation, entity, depths, createSparseSet())\n    invalidateQueryCache(world, relation)\n}\n\n/**\n * Recursively invalidates an entire subtree\n */\nfunction invalidateSubtree(world: World, relation: ComponentRef, entity: EntityId, depths: Uint32Array, visited: SparseSet): void {\n    if (visited.has(entity)) return\n    visited.add(entity)\n    \n    const ctx = (world as InternalWorld)[$internal]\n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    \n    // Invalidate this entity and update cache\n    if (entity < depths.length) {\n        const oldDepth = depths[entity]\n        if (oldDepth !== INVALID_DEPTH) {\n            hierarchyData.depths[entity] = INVALID_DEPTH\n            updateDepthCache(hierarchyData, entity, INVALID_DEPTH, oldDepth)\n        }\n    }\n    \n    // Find and invalidate all children\n    const children = query(world, [relation(entity)])\n    for (const child of children) {\n        invalidateSubtree(world, relation, child, depths, visited)\n    }\n}\n\n/**\n * Processes all dirty depth calculations for a relation. This ensures all cached\n * depth values are up to date before performing hierarchy operations.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component to flush dirty depths for.\n */\nexport function flushDirtyDepths(world: World, relation: ComponentRef): void {\n    const ctx = (world as InternalWorld)[$internal]\n    const hierarchyData = ctx.hierarchyData.get(relation)\n    \n    if (!hierarchyData) return\n    \n    const { dirty, depths } = hierarchyData\n    \n    if (dirty.dense.length === 0) return\n    \n    // Simple approach: just calculate all dirty depths\n    for (const entity of dirty.dense) {\n        if (depths[entity] === INVALID_DEPTH) {\n            const newDepth = calculateEntityDepth(world, relation, entity)\n            setEntityDepth(hierarchyData, entity, newDepth)\n        }\n    }\n    \n    dirty.reset()\n}\n\n/**\n * Query entities in hierarchical order (depth-based ordering). Returns entities grouped by depth:\n * all depth 0, then depth 1, then depth 2, etc. This ensures parents always come before their children.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @param {ComponentRef[]} components - Additional components to filter by.\n * @param {Object} [options] - Query options.\n * @param {boolean} [options.buffered] - Whether to return results as Uint32Array instead of number[].\n * @returns {QueryResult} Array or Uint32Array of entity IDs in hierarchical order.\n */\nexport function queryHierarchy(world: World, relation: ComponentRef, components: ComponentRef[], options: { buffered?: boolean } = {}): QueryResult {\n    const ctx = (world as InternalWorld)[$internal]\n    \n    // Ensure hierarchy is active\n    getHierarchyData(world, relation)\n    \n    // Check cache for this query\n    const queryKey = queryHash(world, [relation, ...components])\n    const cached = ctx.hierarchyQueryCache.get(relation)\n    \n    if (cached && cached.hash === queryKey) {\n        return cached.result\n    }\n    \n    // Update any dirty depths before sorting\n    flushDirtyDepths(world, relation)\n    \n    // Ensure query is cached using existing infrastructure, then get Query object\n    queryInternal(world, components, options)\n    const queryObj = ctx.queriesHashMap.get(queryHash(world, components))!\n    \n    const hierarchyData = ctx.hierarchyData.get(relation)!\n    const { depths } = hierarchyData\n    \n    // Sort the query's sparse set in place - no allocation needed!\n    queryObj.sort((a, b) => {\n        const depthA = depths[a]\n        const depthB = depths[b]\n        return depthA !== depthB ? depthA - depthB : a - b\n    })\n    \n    // Cache this result (dense is already the correct type)\n    const result = options.buffered ? queryObj.dense as Readonly<Uint32Array> : queryObj.dense as readonly EntityId[]\n    ctx.hierarchyQueryCache.set(relation, { hash: queryKey, result: result as QueryResult })\n    \n    return result\n}\n\n/**\n * Get all entities at a specific depth level in the hierarchy.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @param {number} depth - The specific depth level to query (0 = root level).\n * @param {Object} [options] - Query options.\n * @param {boolean} [options.buffered] - Whether to return results as Uint32Array instead of number[].\n * @returns {QueryResult} Array or Uint32Array of entity IDs at the specified depth.\n */\nexport function queryHierarchyDepth(world: World, relation: ComponentRef, depth: number, options: { buffered?: boolean } = {}): QueryResult {\n    // Ensure hierarchy is active and get data\n    const hierarchyData = getHierarchyData(world, relation)\n    flushDirtyDepths(world, relation)\n    \n    const entitiesAtDepth = hierarchyData.depthToEntities.get(depth)\n    \n    if (entitiesAtDepth) {\n        return options.buffered ? entitiesAtDepth.dense as Readonly<Uint32Array> : entitiesAtDepth.dense as readonly EntityId[]\n    }\n    \n    return options.buffered ? new Uint32Array(0) as Readonly<Uint32Array> : [] as readonly EntityId[]\n}\n\n/**\n * Get the hierarchy depth of a specific entity for a given relation.\n * @param {World} world - The world object.\n * @param {EntityId} entity - The entity ID to get depth for.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @returns {number} The depth of the entity (0 = root level, higher numbers = deeper).\n */\nexport function getHierarchyDepth(world: World, entity: EntityId, relation: ComponentRef): number {\n    getHierarchyData(world, relation)\n    return getEntityDepthWithVisited(world, relation, entity, new Set())\n}\n\n/**\n * Get the maximum depth in the hierarchy for a given relation.\n * @param {World} world - The world object.\n * @param {ComponentRef} relation - The relation component that defines the hierarchy.\n * @returns {number} The maximum depth found in the hierarchy.\n */\nexport function getMaxHierarchyDepth(world: World, relation: ComponentRef): number {\n    const hierarchyData = getHierarchyData(world, relation)\n    return hierarchyData.maxDepth\n}", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { EntityId, Prefab } from './Entity'\nimport { queryHierarchy, queryHierarchyDepth } from './Hierarchy'\n\n/**\n * @typedef {Readonly<Uint32Array> | readonly EntityId[]} QueryResult\n * @description The result of a query as a readonly array of entity IDs.\n */\nexport type QueryResult = Readonly<Uint32Array> | readonly EntityId[]\n\n/**\n * @typedef {Object} QueryOptions\n * @description Options for configuring query behavior.\n * @property {boolean} [commit=true] - Whether to commit pending entity removals before querying.\n * @property {boolean} [buffered=false] - Whether to return results as Uint32Array instead of number[].\n */\nexport interface QueryOptions {\n\tcommit?: boolean\n\tbuffered?: boolean\n}\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS using original blazing-fast bitmask evaluation.\n * @property {ComponentRef[]} allComponents - All components referenced in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Record<number, number>} masks - Bitmasks for each component generation.\n * @property {Record<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Record<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Record<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: Record<number, number>\n\torMasks: Record<number, number>\n\tnotMasks: Record<number, number>\n\thasMasks: Record<number, number>\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n\tqueues: Record<any, any>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n/**\n * Symbol for query operator type.\n * @type {Symbol}\n */\nexport const $opType = Symbol.for('bitecs-opType')\n\n/**\n * Symbol for query operator terms.\n * @type {Symbol}\n */\nexport const $opTerms = Symbol.for('bitecs-opTerms')\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opTerms] - The components involved in the operation.\n */\nexport type OpReturnType = {\n\t[$opType]: string\n\t[$opTerms]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator | HierarchyTerm} QueryTerm\n * @description A term in a query, either a component reference, query operator, or hierarchy term.\n */\nexport type QueryTerm = ComponentRef | QueryOperator | HierarchyTerm\n\n\nconst createOp = (type: string) => (...components: ComponentRef[]) => ({ [$opType]: type, [$opTerms]: components })\n\nexport const Or: QueryOperator = createOp('Or')\nexport const And: QueryOperator = createOp('And')\nexport const Not: QueryOperator = createOp('Not')\nexport const Any = Or\nexport const All = And\nexport const None = Not\n\n// NEW: Hierarchy combinator symbols\nexport const $hierarchyType = Symbol.for('bitecs-hierarchyType')\nexport const $hierarchyRel = Symbol.for('bitecs-hierarchyRel')\nexport const $hierarchyDepth = Symbol.for('bitecs-hierarchyDepth')\n\n/**\n * @typedef {Object} HierarchyTerm\n * @description Represents a hierarchy query term for topological ordering.\n * @property {symbol} [$hierarchyType] - Always 'Hierarchy'.\n * @property {ComponentRef} [$hierarchyRel] - The relation component for hierarchy.\n * @property {number} [$hierarchyDepth] - Optional depth limit.\n */\nexport type HierarchyTerm = {\n\t[$hierarchyType]: 'Hierarchy'\n\t[$hierarchyRel]: ComponentRef\n\t[$hierarchyDepth]?: number\n}\n\n/**\n * @function Hierarchy\n * @description Creates a hierarchy query term for topological ordering (parents before children).\n * @param {ComponentRef} relation - The relation component (e.g., ChildOf).\n * @param {number} [depth] - Optional depth limit.\n * @returns {HierarchyTerm} The hierarchy term.\n */\nexport const Hierarchy = (relation: ComponentRef, depth?: number): HierarchyTerm => ({\n\t[$hierarchyType]: 'Hierarchy',\n\t[$hierarchyRel]: relation,\n\t[$hierarchyDepth]: depth\n})\n\n/**\n * @function Cascade\n * @description Alias for Hierarchy - creates a hierarchy query term for topological ordering.\n * @param {ComponentRef} relation - The relation component (e.g., ChildOf).\n * @param {number} [depth] - Optional depth limit.\n * @returns {HierarchyTerm} The hierarchy term.\n */\nexport const Cascade = Hierarchy\n\n// Query modifier symbols\nexport const $modifierType = Symbol.for('bitecs-modifierType')\n\n/**\n * @typedef {Object} QueryModifier\n * @description Represents a query modifier that can be mixed into query terms.\n * @property {symbol} [$modifierType] - The type of modifier ('buffer' | 'nested').\n */\nexport type QueryModifier = {\n\t[$modifierType]: 'buffer' | 'nested'\n}\n\nexport const asBuffer: QueryModifier = { [$modifierType]: 'buffer' }\nexport const isNested: QueryModifier = { [$modifierType]: 'nested' }\nexport const noCommit = isNested\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...QueryTerm} terms - The query terms to observe.\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\n */\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\n\t[$opTerms]: QueryTerm[]\n}\n\nexport type ObservableHook = ReturnType<ObservableHookDef>\n\nconst createHook = (type: 'add' | 'remove' | 'set' | 'get') => (...terms: QueryTerm[]) => ({ [$opType]: type, [$opTerms]: terms })\nexport const onAdd: ObservableHookDef = createHook('add')\nexport const onRemove: ObservableHookDef = createHook('remove')\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({ [$opType]: 'set', [$opTerms]: [component] })\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({ [$opType]: 'get', [$opTerms]: [component] })\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ObservableHook} hook - The observable hook.\n * @param {function(number): any} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opTerms]: components } = hook\n\n\tif (type === 'add' || type === 'remove') {\n\t\tconst queryData = ctx.queriesHashMap.get(queryHash(world, components)) || registerQuery(world, components)\n\t\treturn queryData[type === 'add' ? 'addObservable' : 'removeObservable'].subscribe(callback)\n\t}\n\t\n\tif (type === 'set' || type === 'get') {\n\t\tif (components.length !== 1) throw new Error('Set and Get hooks can only observe a single component')\n\t\tconst componentData = ctx.componentMap.get(components[0]) || registerComponent(world, components[0])\n\t\treturn componentData[type === 'set' ? 'setObservable' : 'getObservable'].subscribe(callback)\n\t}\n\n\tthrow new Error(`Invalid hook type: ${type}`)\n}\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst getComponentId = (component: ComponentRef): number => {\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\t\treturn ctx.componentMap.get(component)!.id\n\t}\n\tconst termToString = (term: QueryTerm): string => \n\t\t$opType in term ? `${term[$opType].toLowerCase()}(${term[$opTerms].map(termToString).sort().join(',')})` : getComponentId(term).toString()\n\t\n\treturn terms.map(termToString).sort().join('-')\n}\n\n/**\n * @function registerQuery  \n * @description Registers a new query in the world using unified clause-mask compilation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\n\tconst queryComponents: ComponentRef[] = []\n\tconst collect = (term: QueryTerm) => {\n\t\tif ($opType in term) term[$opTerms].forEach(collect)\n\t\telse {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tqueryComponents.push(term)\n\t\t}\n\t}\n\tterms.forEach(collect)\n\t\n\t// Use original simple approach for blazing-fast simple queries\n\t// TODO: Add nested combinator support later if needed\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst addToArray = (arr: ComponentRef[], comps: ComponentRef[]) => {\n\t\tcomps.forEach(comp => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\tarr.push(comp)\n\t\t})\n\t}\n\t\n\tterms.forEach(term => {\n\t\tif ($opType in term) {\n\t\t\tconst { [$opType]: type, [$opTerms]: comps } = term\n\t\t\tif (type === 'Not') addToArray(notComponents, comps)\n\t\t\telse if (type === 'Or') addToArray(orComponents, comps)\n\t\t\telse if (type === 'And') addToArray(components, comps)\n\t\t\telse throw new Error(`Nested combinator ${type} not supported yet - use simple queries for best performance`)\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst allComponentsData = queryComponents.map(c => ctx.componentMap.get(c)!)\n\tconst generations = [...new Set(allComponentsData.map(c => c.generationId))]\n\tconst reduceBitflags = (a: Record<number, number>, c: ComponentData) => (a[c.generationId] = (a[c.generationId] || 0) | c.bitflag, a)\n\t\n\tconst masks = components.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(c => ctx.componentMap.get(c)!).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponentsData.reduce(reduceBitflags, {})\n\n\tconst query = Object.assign(options.buffered ? createUint32SparseSet() : createSparseSet(), {\n\t\tallComponents: queryComponents, orComponents, notComponents, masks, notMasks, orMasks, hasMasks, generations,\n\t\ttoRemove: createSparseSet(), addObservable: createObservable(), removeObservable: createObservable(), queues: {}\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponentsData.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, eid, Prefab)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n\n\n/**\n * @function queryInternal\n * @description Internal implementation for nested queries.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function queryInternal(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\n\treturn options.buffered ? queryData.dense as Readonly<Uint32Array> : queryData.dense as readonly EntityId[]\n}\n\n/**\n * @function query\n * @description Performs a unified query operation with configurable options.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {...QueryModifier} modifiers - Query modifiers (asBuffer, isNested, etc.).\n * @returns {QueryResult} The result of the query.\n */\nexport function query(world: World, terms: QueryTerm[], ...modifiers: (QueryModifier | QueryOptions)[]): QueryResult {\n\tconst hierarchyTerm = terms.find(term => term && typeof term === 'object' && $hierarchyType in term) as HierarchyTerm | undefined\n\tconst regularTerms = terms.filter(term => !(term && typeof term === 'object' && $hierarchyType in term))\n\t\n\tlet buffered = false, commit = true\n\tconst hasModifiers = modifiers.some(m => m && typeof m === 'object' && $modifierType in m)\n\t\n\tfor (const modifier of modifiers) {\n\t\tif (hasModifiers && modifier && typeof modifier === 'object' && $modifierType in modifier) {\n\t\t\tconst mod = modifier as QueryModifier\n\t\t\tif (mod[$modifierType] === 'buffer') buffered = true\n\t\t\tif (mod[$modifierType] === 'nested') commit = false\n\t\t} else if (!hasModifiers) {\n\t\t\tconst opts = modifier as QueryOptions\n\t\t\tif (opts.buffered !== undefined) buffered = opts.buffered\n\t\t\tif (opts.commit !== undefined) commit = opts.commit\n\t\t}\n\t}\n\n\tif (hierarchyTerm) {\n\t\tconst { [$hierarchyRel]: relation, [$hierarchyDepth]: depth } = hierarchyTerm\n\t\treturn depth !== undefined ? queryHierarchyDepth(world, relation, depth, { buffered }) : queryHierarchy(world, relation, regularTerms, { buffered })\n\t}\n\n\tif (commit) commitRemovals(world)\n\treturn queryInternal(world, regularTerms, { buffered })\n}\n\n\n\n/**\n * @function queryCheckEntity\n * @description Original blazing-fast query evaluation using simple bitmasks.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tlet hasOrMatch = Object.keys(orMasks).length === 0\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) !== 0) {\n\t\t\thasOrMatch = true\n\t\t}\n\t}\n\n\treturn hasOrMatch\n}\n\n\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport {\n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World, WorldContext } from './World'\nimport { updateHierarchyDepth, invalidateHierarchyDepth } from './Hierarchy'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n\tgetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable(),\n\t\tgetObservable: createObservable(),\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to check for.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n/**\n * Retrieves the data associated with a component for a specific entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to retrieve data for.\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\n */\nexport const getComponent = (world: World, eid: EntityId, component: ComponentRef): any => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\treturn undefined\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\treturn undefined\n\t}\n\n\t// Notify observers that this component is being accessed\n\treturn componentData.getObservable.notify(eid)\n}\n\n/**\n * Helper function to set component data.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\n */\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\n\tcomponent,\n\tdata\n})\n\n/**\n * Recursvely inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n * @param {boolean} isFirstSuper - Whether this is the first super in the inheritance chain.\n */\nconst recursivelyInherit = (ctx: WorldContext, world: World, baseEid: EntityId, inheritedEid: EntityId, visited = new Set<EntityId>()): void => {\n\t// Guard against circular inheritance\n\tif (visited.has(inheritedEid)) return\n\tvisited.add(inheritedEid)\n\t\n\t// Add IsA relation first\n\taddComponent(world, baseEid, IsA(inheritedEid))\n\t\n\t// Copy components and their data from this level\n\t// This needs to happen before recursing to ancestors so closer ancestors take precedence\n\tfor (const component of getEntityComponents(world, inheritedEid)) {\n\t\t// TODO: inherit reference vs copy\n\t\tif (component === Prefab) continue\n\t\t\n\t\t// Only add component if entity doesn't already have it\n\t\t// This ensures closer ancestors take precedence\n\t\tif (!hasComponent(world, baseEid, component)) {\n\t\t\taddComponent(world, baseEid, component)\n\t\t\t\n\t\t\tconst componentData = ctx.componentMap.get(component)\n\t\t\tif (componentData?.setObservable) {\n\t\t\t\tconst data = getComponent(world, inheritedEid, component)\n\t\t\t\tcomponentData.setObservable.notify(baseEid, data)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Then recursively inherit from ancestors\n\t// This ensures more distant ancestors don't override closer ones\n\tfor (const parentEid of getRelationTargets(world, inheritedEid, IsA)) {\n\t\trecursivelyInherit(ctx, world, baseEid, parentEid, visited)\n\t}\n}\n\n/**\n * Represents a component with data to be set on an entity.\n */\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\n\n/**\n * Sets component data on an entity. Always calls the setter observable even if entity already has the component.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const setComponent = (\n  world: World,\n  eid: EntityId,\n  component: ComponentRef,\n  data: any\n): void => {\n  addComponent(world, eid, set(component, data));\n};\n\n/**\n * Adds a single component to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef | ComponentSetter} componentOrSet - Component to add or set.\n * @returns {boolean} True if component was added, false if it already existed.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, eid: EntityId, componentOrSet: ComponentRef | ComponentSetter): boolean => {\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\n\t}\n\t\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\n\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\n\n\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\tconst componentData = ctx.componentMap.get(component)!\n\t\n\t// If entity already has component, just call setter and return false\n\tif (hasComponent(world, eid, component)) {\n\t\tif (data !== undefined) {\n\t\t\tcomponentData.setObservable.notify(eid, data)\n\t\t}\n\t\treturn false\n\t}\n\n\tconst { generationId, bitflag, queries } = componentData\n\n\tctx.entityMasks[generationId][eid] |= bitflag\n\n\tif (!hasComponent(world, eid, Prefab)) {\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\t}\n\tctx.entityComponents.get(eid)!.add(component)\n\n\t// Call setter AFTER component is added and onAdd callbacks have fired\n\tif (data !== undefined) {\n\t\tcomponentData.setObservable.notify(eid, data)\n\t}\n\tif (component[$isPairComponent]) {\n\t\tconst relation = component[$relation]\n\t\tconst target = component[$pairTarget]\n\n\t\t// Add both Wildcard pairs for relation and target\n\t\taddComponents(world, eid, Pair(relation, Wildcard), Pair(Wildcard, target))\n\n\t\t// For non-Wildcard targets, add Wildcard pair to track relation targets\n\t\tif (typeof target === 'number') {\n\t\t\t// Add Wildcard pair for target being a relation target\n\t\t\taddComponents(world, target, Pair(Wildcard, eid), Pair(Wildcard, relation))\n\t\t\t// Track entities with relations for autoRemoveSubject\n\t\t\tctx.entitiesWithRelations.add(target)\n\t\t\tctx.entitiesWithRelations.add(eid)\n\t\t}\n\n\t\t// add target to a set to make autoRemoveSubject checks faster\n\t\tctx.entitiesWithRelations.add(target)\n\n\t\tconst relationData = relation[$relationData]\n\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\n\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\n\t\t\t}\n\t\t}\n\n\t\tif (relation === IsA) {\n\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\n\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\trecursivelyInherit(ctx, world, eid, inherited)\n\t\t\t}\n\t\t}\n\n\t\t// Update hierarchy depth tracking for this relation\n\t\tupdateHierarchyDepth(world, relation, eid, typeof target === 'number' ? target : undefined)\n\t}\n\n\treturn true\n}\n\n/**\n * Adds multiple components to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {(ComponentRef | ComponentSetter)[] | ComponentRef | ComponentSetter} components - Components to add or set (array or spread args).\n * @throws {Error} If the entity does not exist in the world.\n */\nexport function addComponents(world: World, eid: EntityId, components: (ComponentRef | ComponentSetter)[]): void;\nexport function addComponents(world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void;\nexport function addComponents(world: World, eid: EntityId, ...args: any[]): void {\n\tconst components = Array.isArray(args[0]) ? args[0] : args\n\tcomponents.forEach((componentOrSet: ComponentRef | ComponentSetter) => {\n\t\taddComponent(world, eid, componentOrSet)\n\t})\n}\n\n/**\n * Removes one or more components from an entity.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(component => {\n\t\tif (!hasComponent(world, eid, component)) return\n\n\t\tconst componentNode = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentNode\n\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\n\t\tctx.entityComponents.get(eid)!.delete(component)\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst target = component[$pairTarget]\n\t\t\tconst relation = component[$relation]\n\t\t\t\n\t\t\t// Invalidate hierarchy depth tracking for this relation\n\t\t\tinvalidateHierarchyDepth(world, relation, eid)\n\t\t\t\n\t\t\t// Remove Wildcard pair from subject\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\t// Remove Wildcard pairs from target (if target is an entity)\n\t\t\tif (typeof target === 'number' && entityExists(world, target)) {\n\t\t\t\tremoveComponent(world, target, Pair(Wildcard, eid))\n\t\t\t\tremoveComponent(world, target, Pair(Wildcard, relation))\n\t\t\t}\n\n\t\t\t// Remove relation Wildcard pair if no other targets\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\n\t\t\tif (otherTargets.length === 0) {\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Removes one or more components from an entity. This is an alias for removeComponent.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponents = removeComponent\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tquery,\n\tnoCommit,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport type EntityId = number\n\nexport const Prefab = {}\n\n/**\n * Creates a new prefab entity in the world. Prefabs are special entities marked with the Prefab component\n * that are excluded from normal queries and can be used as templates for creating other entities.\n * @param {World} world - The world object to create the prefab in.\n * @returns {EntityId} The entity ID of the created prefab.\n */\nexport const addPrefab = (world: World): EntityId => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, eid, Prefab)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): EntityId => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, child, ChildOf(parent))\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n\t\tif (ctx.entitiesWithRelations.has(currentEid)) {\n\t\t\tfor (const subject of query(world, [Wildcard(currentEid)], noCommit)) {\n\t\t\t\tif (!entityExists(world, subject)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const component of ctx.entityComponents.get(subject)!) {\n\t\t\t\t\tif (!component[$isPairComponent]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst relation = component[$relation]\n\t\t\t\t\tconst relationData = relation[$relationData]\n\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\n\n\t\t\t\t\tif (component[$pairTarget] === currentEid) {\n\t\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, component))\n\t\t\t\t\t\tif (relationData.autoRemoveSubject) {\n\t\t\t\t\t\t\tremovalQueue.push(subject)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationData.onTargetRemoved) {\n\t\t\t\t\t\t\tcomponentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.entitiesWithRelations.delete(currentEid)\n\t\t}\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error(`getEntityComponents: entity id is undefined.`)\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error(`getEntityComponents: entity ${eid} does not exist in the world.`)\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "type Func = (...args: any) => any\nexport const pipe = <T extends Func, U extends Func, R extends Func>\n    (...functions: [T, ...U[], R]): ((...args: Parameters<T>) => ReturnType<R>) => {\n    return (...args: Parameters<T>): ReturnType<R> => \n        functions.reduce((result, fn) => [fn(...result)], args as any)[0]\n}\n", "export {\n\tcreateWorld,\n\tresetWorld,\n\tdeleteWorld,\n\tgetWorldComponents,\n\tgetAllEntities,\n\t$internal,\n} from './World'\n\nexport type {\n\tWorld,\n\tInternalWorld,\n\tWorldContext\n} from './World'\n\nexport {\n\taddEntity,\n\tremoveEntity,\n\tgetEntityComponents,\n\tentityExists,\n\tPrefab,\n\taddPrefab,\n} from './Entity'\n\nexport type {\n\tEntityId,\n} from './Entity'\n\nexport { \n\tcreateEntityIndex,\n\tgetId,\n\tgetVersion,\n\twithVersioning,\n} from './EntityIndex'\n\nexport {\n\tregisterComponent,\n\tregisterComponents,\n\thasComponent,\n\taddComponent,\n\taddComponents,\n\tsetComponent,\n\tremoveComponent,\n\tremoveComponents,\n\tgetComponent,\n\tset\n} from './Component'\n\nexport type {\n\tComponentRef,\n\tComponentData\n} from './Component'\n\nexport {\n\tcommitRemovals,\n\tremoveQuery,\n\tregisterQuery,\n\tquery,\n\tobserve,\n\tonAdd,\n\tonRemove,\n\tOr,\n\tAnd,\n\tNot,\n\tAny,\n\tAll,\n\tNone,\n\tonGet,\n\tonSet,\n\tHierarchy,\n\tCascade,\n\tasBuffer,\n\tisNested,\n\tnoCommit,\n} from './Query'\n\nexport type {\n\tObservableHookDef,\n\tObservableHook,\n\tQueryResult,\n\tQuery,\n\tQueryOperatorType,\n\tOpReturnType,\n\tQueryOperator,\n\tQueryTerm,\n\tQueryOptions,\n\tHierarchyTerm,\n\tQueryModifier,\n} from './Query'\n\nexport { pipe } from './utils/pipe'\n\nexport {\n\twithAutoRemoveSubject,\n\twithOnTargetRemoved,\n\twithStore,\n\tcreateRelation,\n\tgetRelationTargets,\n\tWildcard,\n\tIsA,\n\tPair,\n\tisRelation,\n\tisWildcard,\n} from './Relation'\n\nexport type {\n\tOnTargetRemovedCallback,\n\tRelation,\n\tRelationTarget,\n} from './Relation'\n\nexport {\n\tgetHierarchyDepth,\n\tgetMaxHierarchyDepth,\n} from './Hierarchy'\n"],
  "mappings": "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",
  "names": ["defineHiddenProperty", "obj", "key", "value", "exports", "defineHiddenProperties", "kv", "descriptors", "a", "k", "_a", "__assign", "getId", "index", "id", "exports", "getVersion", "incrementVersion", "currentVersion", "newVersion", "withVersioning", "versionBits", "createEntityIndex", "options", "config", "_a", "versioning", "_b", "entityBits", "entityMask", "versionShift", "versionMask", "addEntityId", "recycledId", "entityId", "removeEntityId", "denseIndex", "lastIndex", "lastId", "newId", "isEntityIdAlive", "exports", "createWorld", "defineHiddenProperty_1", "EntityIndex_1", "createBaseWorld", "context", "entityIndex", "args", "_i", "arg", "resetWorld", "world", "ctx", "deleteWorld", "getWorldComponents", "getAllEntities", "createSparseSet", "dense", "sparse", "has", "val", "add", "remove", "index", "swapped", "reset", "sort", "compareFn", "i", "exports", "SharedArrayBufferOrArrayBuffer", "createUint32SparseSet", "initialCapacity", "length", "newDense", "temp", "createObservable", "observers", "subscribe", "observer", "notify", "entity", "args", "_i", "acc", "listener", "result", "__spreadArray", "__read", "__assign", "exports", "exports", "createRelation", "createWildcardRelation", "getWildcard", "createIsARelation", "getIsA", "isWildcard", "isRelation", "_1", "defineHiddenProperty_1", "createBaseRelation", "data", "relation", "target", "normalizedTarget", "component", "withStore", "createStore", "ctx", "makeExclusive", "withAutoRemoveSubject", "withOnTargetRemoved", "onRemove", "Pair", "getRelationTargets", "world", "eid", "components", "targets", "components_1", "__values", "components_1_1", "args", "_i", "_a", "store", "exclusive", "autoRemoveSubject", "onTargetRemoved", "modifiers", "acc", "modifier", "GLOBAL_WILDCARD", "GLOBAL_ISA", "symbols", "exports", "ensureDepthTracking", "calculateEntityDepth", "markChildrenDirty", "updateHierarchyDepth", "invalidateHierarchyDepth", "flushDirtyDepths", "queryHierarchy", "queryHierarchyDepth", "getHierarchyDepth", "getMaxHierarchyDepth", "World_1", "Relation_1", "Query_1", "SparseSet_1", "MAX_HIERARCHY_DEPTH", "INVALID_DEPTH", "DEFAULT_BUFFER_GROWTH", "growDepthsArray", "hierarchyData", "entity", "depths", "newSize", "newDepths", "updateDepthCache", "newDepth", "oldDepth", "depthToEntities", "oldSet", "updateMaxDepth", "depth", "setEntityDepth", "invalidateQueryCache", "world", "relation", "ctx", "getHierarchyData", "populateExistingDepths", "entitiesWithRelation", "entitiesWithRelation_1", "__values", "entitiesWithRelation_1_1", "getEntityDepth", "processedTargets", "entitiesWithRelation_2", "entitiesWithRelation_2_1", "_d", "e_3", "_e", "target", "initialSize", "depthArray", "visited", "targets", "getEntityDepthWithVisited", "minDepth", "targets_1", "targets_1_1", "parent", "dirty", "children", "children_1", "children_1_1", "child", "updating", "invalidateSubtree", "children_2", "children_2_1", "_b", "_c", "components", "options", "queryKey", "__spreadArray", "__read", "cached", "queryObj", "a", "b", "depthA", "depthB", "result", "entitiesAtDepth", "exports", "observe", "queryInternal", "query", "queryCheckEntity", "SparseSet_1", "Component_1", "World_1", "Observer_1", "Entity_1", "Hierarchy_1", "createOp", "type", "components", "_i", "_a", "Hierarchy", "relation", "depth", "_b", "createHook", "terms", "onSet", "component", "onGet", "world", "hook", "callback", "ctx", "_c", "queryData", "componentData", "queryHash", "getComponentId", "termToString", "term", "registerQuery", "options", "hash", "queryComponents", "collect", "notComponents", "orComponents", "addToArray", "arr", "comps", "comp", "allComponentsData", "c", "generations", "__spreadArray", "__read", "reduceBitflags", "a", "masks", "notMasks", "orMasks", "hasMasks", "entityIndex", "i", "eid", "match", "modifiers", "hierarchyTerm", "regularTerms", "buffered", "commit", "hasModifiers", "m", "modifiers_1", "__values", "modifiers_1_1", "modifier", "mod", "opts", "_d", "hasOrMatch", "generationId", "qMask", "qNotMask", "qOrMask", "eMask", "queryCheckComponent", "bitflag", "mask", "queryAddEntity", "queryCommitRemovals", "commitRemovals", "queryRemoveEntity", "has", "removeQuery", "exports", "addComponents", "Entity_1", "Query_1", "Relation_1", "Observer_1", "World_1", "Hierarchy_1", "registerComponent", "world", "component", "ctx", "queries", "data", "registerComponents", "components", "hasComponent", "eid", "registeredComponent", "generationId", "bitflag", "mask", "getComponent", "componentData", "set", "recursivelyInherit", "baseEid", "inheritedEid", "visited", "_c", "__values", "_d", "_e", "_f", "parentEid", "setComponent", "addComponent", "componentOrSet", "queryData", "match", "relation", "target", "relationData", "oldTarget", "inheritedTargets", "inheritedTargets_1", "inheritedTargets_1_1", "inherited", "args", "_i", "removeComponent", "componentNode", "otherTargets", "Component_1", "Query_1", "Relation_1", "EntityIndex_1", "World_1", "exports", "addPrefab", "world", "eid", "addEntity", "ctx", "q", "match", "removeEntity", "removalQueue", "processedEntities", "currentEid", "componentRemovalQueue", "subject", "component", "relation", "relationData", "_k", "e_5", "__values", "_l", "_e", "e_1", "_f", "componentRemovalQueue_1", "e_2", "componentRemovalQueue_1_1", "removeOperation", "removalQueue_1", "e_3", "removalQueue_1_1", "eid_1", "_g", "e_4", "_h", "query_1", "i", "getEntityComponents", "entityExists", "pipe", "functions", "_i", "args", "result", "fn", "__spreadArray", "__read", "exports", "World_1", "exports", "Entity_1", "EntityIndex_1", "Component_1", "Query_1", "pipe_1", "Relation_1", "Hierarchy_1"]
}
