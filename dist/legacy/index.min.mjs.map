{
  "version": 3,
  "sources": ["../../src/legacy/index.ts", "../../src/serialization/ObserverSerializer.ts", "../../src/serialization/SoASerializer.ts", "../../src/legacy/serialization.ts"],
  "sourcesContent": ["import {\n  ComponentRef,\n  observe,\n  onAdd,\n  onRemove,\n  query,\n  EntityId,\n  addComponent as ecsAddComponent,\n  hasComponent as ecsHasComponent,\n  removeComponent as ecsRemoveComponent\n} from 'bitecs'\n\nexport interface IWorld { }\n\nexport type ComponentProp = TypedArray | Array<TypedArray>\n\nexport interface IComponentProp {\n}\n\nexport interface IComponent {\n}\n\nexport type Component = IComponent | ComponentType<ISchema>\n\nexport type QueryModifier = (c: IComponent[]) => IComponent | QueryModifier\n\nexport type Query<W extends IWorld = IWorld> = (world: W, clearDiff?: Boolean) => number[]\n\nexport const $modifier = Symbol(\"$modifier\")\n\nfunction modifier(c, mod) {\n  const inner = () => [c, mod]\n  inner[$modifier] = true\n  return inner\n}\n\nexport const Not = (c: Component | ISchema): QueryModifier => modifier(c, 'not')\nexport const Or = (c: Component | ISchema): QueryModifier => modifier(c, 'or')\nexport const Changed = (c: Component | ISchema): QueryModifier => modifier(c, 'changed')\n\nexport function defineQuery<W extends IWorld = IWorld>(components: (Component | QueryModifier)[]): Query<W> {\n  const queryFn = (world: IWorld) => query(world, components)\n  queryFn.components = components\n  return queryFn as unknown as Query<W>\n}\n\nexport function enterQuery<W extends IWorld = IWorld>(queryFn: Query<W>): Query<W> {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: W) => {\n    if (!initSet.has(world)) {\n      observe(world, onAdd(...(queryFn as any).components), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport function exitQuery<W extends IWorld = IWorld>(queryFn: Query<W>): Query<W> {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: W) => {\n    if (!initSet.has(world)) {\n      observe(world, onRemove(...(queryFn as any).components), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const addComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsAddComponent(world, eid, component)\n\nexport const hasComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsHasComponent(world, eid, component)\n\nexport const removeComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsRemoveComponent(world, eid, component)\n\nexport interface ISchema {\n  [key: string]: Type | ListType | ISchema\n}\n\nexport type Type =\n  | 'i8'\n  | 'ui8'\n  | 'ui8c'\n  | 'i16'\n  | 'ui16'\n  | 'i32'\n  | 'ui32'\n  | 'f32'\n  | 'f64'\n  | 'eid'\n\nexport type ListType = readonly [Type, number];\n\nexport const Types = {\n  i8: 'i8' as Type,\n  ui8: 'ui8' as Type,\n  ui8c: 'ui8c' as Type,\n  i16: 'i16' as Type,\n  ui16: 'ui16' as Type,\n  i32: 'i32' as Type,\n  ui32: 'ui32' as Type,\n  f32: 'f32' as Type,\n  f64: 'f64' as Type,\n  eid: 'eid' as Type\n};\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n\nexport type ArrayByType = {\n  'i8': Int8Array;\n  'ui8': Uint8Array;\n  'ui8c': Uint8ClampedArray;\n  'i16': Int16Array;\n  'ui16': Uint16Array;\n  'i32': Int32Array;\n  'ui32': Uint32Array;\n  'f32': Float32Array;\n  'f64': Float64Array;\n  'eid': Uint32Array;\n}\n\n// ... existing code ...\n\nconst arrayByTypeMap: { [key in Type]: any } = {\n  'i8': Int8Array,\n  'ui8': Uint8Array,\n  'ui8c': Uint8ClampedArray,\n  'i16': Int16Array,\n  'ui16': Uint16Array,\n  'i32': Int32Array,\n  'ui32': Uint32Array,\n  'f32': Float32Array,\n  'f64': Float64Array,\n  'eid': Uint32Array,\n};\n\nexport type ComponentType<T extends ISchema> = {\n  [key in keyof T]:\n  T[key] extends Type\n  ? ArrayByType[T[key]]\n  : T[key] extends [infer RT, number]\n  ? RT extends Type\n  ? Array<ArrayByType[RT]>\n  : unknown\n  : T[key] extends ISchema\n  ? ComponentType<T[key]>\n  : unknown;\n};\n\nexport const defineComponent = <T extends ISchema>(schema: T, max: number = 1e5): ComponentType<T> => {\n  const createSoA = <U extends ISchema>(schema: U, max: number): ComponentType<U> => {\n    const component = {} as ComponentType<U>\n    for (const key in schema) {\n      if (Array.isArray(schema[key])) {\n        const [type, length] = schema[key] as [Type, number]\n        component[key] = Array.from({ length }, () => new arrayByTypeMap[type](max)) as any\n      } else if (typeof schema[key] === 'object') {\n        component[key] = createSoA(schema[key] as ISchema, max) as any\n      } else {\n        const type = schema[key] as Type;\n        const TypeConstructor = arrayByTypeMap[type];\n        if (TypeConstructor) {\n          component[key] = new TypeConstructor(max) as any;\n        } else {\n          throw new Error(`Unsupported type: ${schema[key]}`);\n        }\n      }\n    }\n    return component\n  }\n  return createSoA(schema, max)\n}\n\nexport * from './serialization'", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n    entityExists,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    EntityId\n} from 'bitecs'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3,\n    AddRelation = 4,\n    RemoveRelation = 5,\n}\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32 } from './SoASerializer'\n\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            dataView.setFloat64(offset, value)\n            return offset + 8\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr) {\n                arr[eid] = dataView.getUint32(offset)\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number, number?, any?][] = []\n    const relationTargets = new Map<number, Map<number, number>>()\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n        relationTargets.delete(eid)\n    })\n\n    components.forEach((component, i) => {\n        if (isRelation(component)) {\n            observe(world, onAdd(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targets = getRelationTargets(world, eid, component)\n                for (const target of targets) {\n                    if (!relationTargets.has(eid)) {\n                        relationTargets.set(eid, new Map())\n                    }\n                    relationTargets.get(eid).set(i, target)\n                    const relationData = component(target)\n                    queue.push([eid, OperationType.AddRelation, i, target, relationData])\n                }\n            })\n\n            observe(world, onRemove(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targetMap = relationTargets.get(eid)\n                if (targetMap) {\n                    const target = targetMap.get(i)\n                    if (target !== undefined) {\n                        queue.push([eid, OperationType.RemoveRelation, i, target])\n                        targetMap.delete(i)\n                        if (targetMap.size === 0) {\n                            relationTargets.delete(eid)\n                        }\n                    }\n                }\n            })\n        } else {\n            observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.AddComponent, i])\n            })\n\n            observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.RemoveComponent, i])\n            })\n        }\n    })\n    \n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId, targetId, relationData] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            if (type === OperationType.AddComponent || \n                type === OperationType.RemoveComponent || \n                type === OperationType.AddRelation ||\n                type === OperationType.RemoveRelation) {\n                dataView.setUint8(offset, componentId)\n                offset += 1\n                \n                if (type === OperationType.AddRelation || type === OperationType.RemoveRelation) {\n                    dataView.setUint32(offset, targetId)\n                    offset += 4\n                    \n                    if (type === OperationType.AddRelation && relationData) {\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                    }\n                }\n            }\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], constructorMapping?: Map<number, number>) => {\n    let entityIdMapping = constructorMapping || new Map<number, number>()\n    \n    return (packet: ArrayBuffer, overrideMapping?: Map<number, number>) => {\n        // Allow overriding the mapping for this call\n        const currentMapping = overrideMapping || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            let componentId = -1\n            let targetId = -1\n            \n            if (operationType === OperationType.AddComponent || \n                operationType === OperationType.RemoveComponent ||\n                operationType === OperationType.AddRelation ||\n                operationType === OperationType.RemoveRelation) {\n                componentId = dataView.getUint8(offset)\n                offset += 1\n                \n                if (operationType === OperationType.AddRelation || operationType === OperationType.RemoveRelation) {\n                    targetId = dataView.getUint32(offset)\n                    offset += 4\n                }\n            }\n\n            const component = components[componentId]\n            let worldEntityId = currentMapping.get(packetEntityId)\n\n            if (operationType === OperationType.AddEntity) {\n                if (worldEntityId === undefined) {\n                    worldEntityId = addEntity(world)\n                    currentMapping.set(packetEntityId, worldEntityId)\n                    addComponent(world, worldEntityId, networkedTag)\n                } else {\n                    // TODO: figure out if this should ignore, throw, warn, or if the observer serializer should maybe do a snapshot on first call?\n                    // throw new Error(`Entity with ID ${packetEntityId} already exists in the mapping.`)\n                    console.warn(`Attempted to deserialize addEntity with ID ${packetEntityId}, but it has already been deserialzied and exists in the mapping.`)\n                }\n            } else if (worldEntityId !== undefined && entityExists(world, worldEntityId)) {\n                if (operationType === OperationType.RemoveEntity) {\n                    removeEntity(world, worldEntityId)\n                    currentMapping.delete(packetEntityId)\n                } else if (operationType === OperationType.AddComponent) {\n                    addComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.RemoveComponent) {\n                    removeComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.AddRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        const relationComponent = component(worldTargetId)\n                        addComponent(world, worldEntityId, relationComponent)\n                        offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset)\n                    }\n                } else if (operationType === OperationType.RemoveRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        removeComponent(world, worldEntityId, component(worldTargetId))\n                    }\n                }\n            }\n        }\n\n        return currentMapping\n    }\n}\n", "\n/**\n * Symbols representing different data types for serialization.\n */\nexport const $u8 = Symbol.for('bitecs-u8'), $i8 = Symbol.for('bitecs-i8'), $u16 = Symbol.for('bitecs-u16'), $i16 = Symbol.for('bitecs-i16'),\n    $u32 = Symbol.for('bitecs-u32'), $i32 = Symbol.for('bitecs-i32'), $f32 = Symbol.for('bitecs-f32'), $f64 = Symbol.for('bitecs-f64'),\n    $str = Symbol.for('bitecs-str'),\n    $arr = Symbol.for('bitecs-arr')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64 | typeof $str\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = ((number[] | string[]) & { [key: symbol]: true }) | TypedArray\n\n/**\n * Type representing a component reference, which is a record mapping string keys to either\n * a PrimitiveBrand (number array with type symbol), TypedArray, or ArrayType values.\n * Used to define the structure of components that can be serialized.\n */\nexport type ComponentRef = Record<string, PrimitiveBrand | TypedArray | ArrayType<any>>\n\nexport type ArrayType<T> = T[] & { [$arr]: TypeSymbol | TypeFunction | ArrayType<any> }\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: any[] = []): PrimitiveBrand =>\n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64),\n            str = typeTagForSerialization($str)\n\n/**\n * Mapping from type functions to their corresponding symbols.\n */\nconst functionToSymbolMap = new Map([\n    [u8, $u8], [i8, $i8], [u16, $u16], [i16, $i16],\n    [u32, $u32], [i32, $i32], [f32, $f32], [f64, $f64],\n    [str, $str]\n])\n\n/**\n * Type representing a type function.\n */\ntype TypeFunction = typeof u8 | typeof i8 | typeof u16 | typeof i16 | typeof u32 | typeof i32 | typeof f32 | typeof f64 | typeof str\n\n/**\n * Object containing setter functions for each data type.\n */\nexport const typeSetters: Record<TypeSymbol, (view: DataView, offset: number, value: any) => number> = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; },\n    [$str]: (view: DataView, offset: number, value: string) => {\n        const enc = textEncoder\n        const bytes = enc.encode(value)\n        let written = 0\n        written += typeSetters[$u32](view, offset + written, bytes.length)\n        new Uint8Array(view.buffer, view.byteOffset + offset + written, bytes.length).set(bytes)\n        written += bytes.length\n        return written\n    }\n} as Record<TypeSymbol, (view: DataView, offset: number, value: any) => number>\n\n/**\n * Object containing getter functions for each data type.\n */\nexport const typeGetters: Record<TypeSymbol, (view: DataView, offset: number) => { value: any, size: number }> = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 }),\n    [$str]: (view: DataView, offset: number) => {\n        const { value: len, size: lenSize } = typeGetters[$u32](view, offset)\n        const bytes = new Uint8Array(view.buffer, view.byteOffset + offset + lenSize, len)\n        const dec = textDecoder\n        const strValue = dec.decode(bytes)\n        return { value: strValue, size: lenSize + len }\n    }\n} as Record<TypeSymbol, (view: DataView, offset: number) => { value: any, size: number }>\n\n/**\n * Resolves a type (symbol, function, or array type) to its corresponding symbol.\n */\nfunction resolveTypeToSymbol(type: TypeSymbol | TypeFunction | ArrayType<any>): TypeSymbol {\n    if (typeof type === 'symbol') {\n        return type\n    }\n    if (typeof type === 'function') {\n        const symbol = functionToSymbolMap.get(type as TypeFunction) as TypeSymbol | undefined\n        if (symbol) return symbol\n        throw new Error(`Unknown type function: ${type}`)\n    }\n    if (isArrayType(type)) {\n        return resolveTypeToSymbol(type[$arr])\n    }\n    // Default fallback\n    return $f32\n}\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const array = <T extends any[] = any[]>(type: TypeSymbol | TypeFunction | ArrayType<any> = f32): ArrayType<T> => {\n    const arr = [] as any[];\n\n    Object.defineProperty(arr, $arr, { value: type, enumerable: false, writable: false, configurable: false })\n\n    return arr as ArrayType<T>;\n}\n\n/**\n * Checks if a value is a TypedArray, branded array, or ArrayType\n */\nfunction isTypedArrayOrBranded(arr: any): arr is PrimitiveBrand | TypedArray | ArrayType<any> {\n    return arr && (\n        ArrayBuffer.isView(arr) || \n        (Array.isArray(arr) && typeof arr === 'object')\n    )\n}\n\n/**\n * Gets the type symbol for an array\n */\nexport function getTypeForArray(arr: PrimitiveBrand | TypedArray | ArrayType<any>): TypeSymbol {\n    // Check for ArrayType first\n    if (isArrayType(arr)) {\n        return resolveTypeToSymbol(arr[$arr])\n    }\n    // Check for branded arrays\n    for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64, $str] as TypeSymbol[]) {\n        if (symbol in arr) return symbol\n    }\n    // Then check TypedArrays\n    if (arr instanceof Int8Array) return $i8\n    if (arr instanceof Uint8Array) return $u8\n    if (arr instanceof Int16Array) return $i16\n    if (arr instanceof Uint16Array) return $u16\n    if (arr instanceof Int32Array) return $i32\n    if (arr instanceof Uint32Array) return $u32\n    if (arr instanceof Float32Array) return $f32\n    return $f64\n}\n\n/**\n * Checks if a value is an array type\n */\nexport function isArrayType(value: any): value is ArrayType<any> {\n    return Array.isArray(value) && $arr in value\n}\n\n/**\n * Gets the element type information for an array type\n */\nexport function getArrayElementType(arrayType: ArrayType<any>): TypeSymbol | TypeFunction | ArrayType<any> {\n    return arrayType[$arr]\n}\n\n/**\n * Serializes an array value to a DataView\n */\nexport function serializeArrayValue(\n    elementType: ArrayType<any> | TypeSymbol | TypeFunction,\n    value: any[],\n    view: DataView,\n    offset: number\n): number {\n    let bytesWritten = 0\n\n    const isArrayDefined = Array.isArray(value) ? 1 : 0\n    bytesWritten += typeSetters[$u8](view, offset, isArrayDefined)\n\n    if (!isArrayDefined) {\n        return bytesWritten\n    }\n\n    bytesWritten += typeSetters[$u32](view, offset + bytesWritten, value.length)\n\n    // Write each element\n    for (let i = 0; i < value.length; i++) {\n        const element = value[i]\n        if (isArrayType(elementType)) {\n            bytesWritten += serializeArrayValue(getArrayElementType(elementType), element, view, offset + bytesWritten)\n        } else {\n            // Primitive type - resolve to symbol\n            const symbol = resolveTypeToSymbol(elementType)\n            bytesWritten += typeSetters[symbol](view, offset + bytesWritten, element)\n        }\n    }\n\n    return bytesWritten\n}\n\n\nexport function deserializeArrayValue(\n    elementType: ArrayType<any> | TypeSymbol | TypeFunction,\n    view: DataView,\n    offset: number\n) {\n    let bytesRead = 0\n\n    const isArrayResult = typeGetters[$u8](view, offset + bytesRead)\n    bytesRead += isArrayResult.size\n    if (!isArrayResult.value) {\n        return { size: bytesRead }\n    }\n\n    const arrayLengthResult = typeGetters[$u32](view, offset + bytesRead)\n    bytesRead += arrayLengthResult.size;\n\n    const arr = new Array(arrayLengthResult.value) as any;\n    for (let i = 0; i < arr.length; i++) {\n        if (isArrayType(elementType)) {\n            const { value, size } = deserializeArrayValue(getArrayElementType(elementType), view, offset + bytesRead)\n            bytesRead += size\n            if (Array.isArray(value)) {\n                arr[i] = value\n            }\n        } else {\n            // Primitive type - resolve to symbol\n            const symbol = resolveTypeToSymbol(elementType)\n            const { value, size } = typeGetters[symbol](view, offset + bytesRead)\n            bytesRead += size\n            arr[i] = value\n        }\n    }\n\n    return { value: arr, size: bytesRead }\n}\n\n/**\n * Checks if an array type is a float type\n */\nconst isFloatType = (array: any) => {\n    const arrayType = getTypeForArray(array)\n    return arrayType === $f32 || arrayType === $f64\n}\n\n/**\n * Gets epsilon value for an array type (0 for non-floats)\n */\nconst getEpsilonForType = (array: any, epsilon: number) => \n    isFloatType(array) ? epsilon : 0\n\n/**\n * Gets or creates a shadow array for change detection\n */\nconst getShadow = (shadowMap: Map<any, any>, array: any) => {\n    let shadow = shadowMap.get(array)\n    if (!shadow) {\n        // Create shadow array with proper initialization\n        if (ArrayBuffer.isView(array)) {\n            // TypedArray\n            shadow = new (array.constructor as any)((array as any).length)\n        } else {\n            // Regular array (like f32([]) arrays) - initialize with zeros\n            shadow = new Array(array.length).fill(0)\n        }\n        shadowMap.set(array, shadow)\n    }\n    return shadow\n}\n\n/**\n * Checks if a value has changed and updates the shadow\n */\nconst hasChanged = (shadowMap: Map<any, any>, array: any, index: number, epsilon = 0.0001) => {\n    const shadow = getShadow(shadowMap, array)\n    const currentValue = array[index]\n    const actualEpsilon = getEpsilonForType(array, epsilon)\n    \n    const changed = actualEpsilon > 0\n        ? Math.abs(shadow[index] - currentValue) > actualEpsilon\n        : shadow[index] !== currentValue\n    \n    shadow[index] = currentValue\n    return changed\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @param {boolean} diff - Whether to use diff mode (only serialize changed values).\n * @param {Map} shadowMap - Map to store shadow copies for diff mode.\n * @param {number} epsilon - Epsilon for float comparison in diff mode.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>, diff = false, shadowMap?: Map<any, any>, epsilon = 0.0001) => {\n    // Handle direct array case\n    if (isTypedArrayOrBranded(component)) {\n        const type = getTypeForArray(component)\n        const setter = typeSetters[type]\n        return (view: DataView, offset: number, index: number, componentId: number) => {\n            if (diff && shadowMap) {\n                if (!hasChanged(shadowMap, component, index, epsilon)) return 0 // No change\n                \n                let bytesWritten = 0\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, componentId) // cid\n                bytesWritten += setter(view, offset + bytesWritten, component[index])\n                return bytesWritten\n            } else {\n                let bytesWritten = 0\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n                bytesWritten += setter(view, offset + bytesWritten, component[index])\n                return bytesWritten\n            }\n        }\n    }\n\n    // Handle component case\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        if (!isTypedArrayOrBranded(arr)) {\n            throw new Error(`Invalid array type for property ${prop}`)\n        }\n        return getTypeForArray(arr)\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number, componentId: number) => {\n        if (diff && shadowMap) {\n            let changeMask = 0\n            // First pass: check what changed and build mask\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                \n                if (hasChanged(shadowMap, componentProperty, index, epsilon)) {\n                    changeMask |= 1 << i\n                }\n            }\n            \n            if (changeMask === 0) return 0 // No changes for this component\n            \n            let bytesWritten = 0\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, componentId) // cid\n            \n            // Write mask\n            const maskSetter = props.length <= 8 ? typeSetters[$u8] : props.length <= 16 ? typeSetters[$u16] : typeSetters[$u32]\n            bytesWritten += maskSetter(view, offset + bytesWritten, changeMask)\n            \n            // Write only changed values (shadows already updated by hasChanged)\n            for (let i = 0; i < props.length; i++) {\n                if (changeMask & (1 << i)) {\n                    const componentProperty = component[props[i]]\n                    \n                    if (isArrayType(componentProperty)) {\n                        bytesWritten += serializeArrayValue(getArrayElementType(componentProperty), componentProperty[index], view, offset + bytesWritten)\n                    } else {\n                        bytesWritten += setters[i](view, offset + bytesWritten, componentProperty[index])\n                    }\n                }\n            }\n            return bytesWritten\n        } else {\n            let bytesWritten = 0\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                if (isArrayType(componentProperty)) {\n                    bytesWritten += serializeArrayValue(getArrayElementType(componentProperty), componentProperty[index], view, offset + bytesWritten)\n                } else {\n                    bytesWritten += setters[i](view, offset + bytesWritten, componentProperty[index])\n                }\n            }\n            return bytesWritten\n        }\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @param {boolean} diff - Whether to expect diff mode data with change masks.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>, diff = false) => {\n    // Handle direct array case\n    if (isTypedArrayOrBranded(component)) {\n        const type = getTypeForArray(component)\n        const getter = typeGetters[type]\n        return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n            let bytesRead = 0\n            const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset)\n            bytesRead += indexSize\n            const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n            \n            if (diff) {\n                // Skip cid (component ID)\n                const { size: cidSize } = typeGetters[$u32](view, offset + bytesRead)\n                bytesRead += cidSize\n            }\n            \n            const { value, size } = getter(view, offset + bytesRead)\n            component[index] = value\n            return bytesRead + size\n        }\n    }\n\n    // Handle component case\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        if (!isTypedArrayOrBranded(arr)) {\n            throw new Error(`Invalid array type for property ${prop}`)\n        }\n        return getTypeForArray(arr)\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        if (diff) {\n            // Skip cid (component ID)\n            const { size: cidSize } = typeGetters[$u32](view, offset + bytesRead)\n            bytesRead += cidSize\n            \n            const maskGetter = props.length <= 8 ? typeGetters[$u8] : props.length <= 16 ? typeGetters[$u16] : typeGetters[$u32]\n            const { value: changeMask, size: maskSize } = maskGetter(view, offset + bytesRead)\n            bytesRead += maskSize\n            \n            for (let i = 0; i < props.length; i++) {\n                if (changeMask & (1 << i)) {\n                    const componentProperty = component[props[i]]\n                    if (isArrayType(componentProperty)) {\n                        const { value, size } = deserializeArrayValue(getArrayElementType(componentProperty), view, offset + bytesRead)\n                        if (Array.isArray(value)){\n                            componentProperty[index] = value\n                        }\n                        bytesRead += size\n                    } else {\n                        const { value, size } = getters[i](view, offset + bytesRead)\n                        component[props[i]][index] = value\n                        bytesRead += size\n                    }\n                }\n            }\n        } else {\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                if (isArrayType(componentProperty)) {\n                    const { value, size } = deserializeArrayValue(getArrayElementType(componentProperty), view, offset + bytesRead)\n                    if (Array.isArray(value)){\n                        componentProperty[index] = value\n                    }\n                    bytesRead += size\n                } else {\n                    const { value, size } = getters[i](view, offset + bytesRead)\n                    component[props[i]][index] = value\n                    bytesRead += size\n                }\n            }\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Options for SoA serializer\n */\nexport type SoASerializerOptions = {\n    diff?: boolean\n    buffer?: ArrayBuffer\n    epsilon?: number\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {SoASerializerOptions} [options] - Serializer options.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: (ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>)[], options: SoASerializerOptions = {}) => {\n    const { \n        diff = false, \n        buffer = new ArrayBuffer(1024 * 1024 * 100), \n        epsilon = 0.0001 \n    } = options\n    const view = new DataView(buffer)\n    const shadowMap = diff ? new Map() : undefined\n    const componentSerializers = components.map(component => createComponentSerializer(component, diff, shadowMap, epsilon))\n    return (indices: number[] | readonly number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index, j) // Pass component ID\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Options for SoA deserializer\n */\nexport type SoADeserializerOptions = {\n    diff?: boolean\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @param {SoADeserializerOptions} [options] - Deserializer options.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: (ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>)[], options: SoADeserializerOptions = {}) => {\n    const { diff = false } = options\n    const componentDeserializers = components.map(component => createComponentDeserializer(component, diff))\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            if (diff) {\n                // Read eid, cid\n                const { value: originalEid, size: eidSize } = typeGetters[$u32](view, offset)\n                const { value: componentId, size: cidSize } = typeGetters[$u32](view, offset + eidSize)\n                \n                // Call component deserializer starting from eid position\n                offset += componentDeserializers[componentId](view, offset, entityIdMapping)\n            } else {\n                for (let i = 0; i < componentDeserializers.length; i++) {\n                    offset += componentDeserializers[i](view, offset, entityIdMapping)\n                }\n            }\n        }\n    }\n}\n", "\nimport { createObserverSerializer, createObserverDeserializer } from '../serialization/ObserverSerializer'\nimport { createSoASerializer, createSoADeserializer } from '../serialization/SoASerializer'\nimport { IWorld, Component, IComponentProp } from './index'\n\nexport type Serializer<W extends IWorld = IWorld> = (world: W, ents: number[]) => ArrayBuffer\nexport type Deserializer<W extends IWorld = IWorld> = (world: W, packet: ArrayBuffer, mode?: DESERIALIZE_MODE) => number[]\n\nexport function defineSerializer<W extends IWorld = IWorld>(components: Component[] | IComponentProp[], maxBytes?: number): Serializer<W> {\n  const initSet = new WeakSet<W>();\n  let serializeObservations: () => ArrayBuffer, serializeData: (indices: number[]) => ArrayBuffer;\n  return (world: W, ents: number[]) => {\n    if (!initSet.has(world)) {\n      initSet.add(world);\n      serializeObservations = createObserverSerializer(world, components[0], components);\n      serializeData = createSoASerializer(components as Component[]);\n    }\n    const observerData = serializeObservations();\n    const soaData = serializeData(ents);\n    // Combine observer and soa data into a single ArrayBuffer\n    const combinedData = new ArrayBuffer(observerData.byteLength + soaData.byteLength);\n    const combinedView = new Uint8Array(combinedData);\n    combinedView.set(new Uint8Array(observerData), 0);\n    combinedView.set(new Uint8Array(soaData), observerData.byteLength);\n    return combinedData;\n  }\n}\n\nexport function defineDeserializer<W extends IWorld = IWorld>(components: Component[] | IComponentProp[]): Deserializer<W> {\n  const initSet = new WeakSet<W>();\n  let deserializeObservations: any, deserializeData: any\n  return (world: W, packet: ArrayBuffer, mode: any): number[] => {\n    if (!initSet.has(world)) {\n      initSet.add(world);\n      deserializeObservations = createObserverDeserializer(world, components[0], components);\n      deserializeData = createSoADeserializer(components);\n    }\n    const observerDataLength = deserializeObservations(packet, mode);\n    const soaData = packet.slice(observerDataLength);\n    return deserializeData(soaData, mode);\n  }\n}\n\nexport enum DESERIALIZE_MODE {\n    REPLACE,\n    APPEND,\n    MAP\n}"],
  "mappings": "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",
  "names": ["observe", "onAdd", "onRemove", "query", "ecsAddComponent", "ecsHasComponent", "ecsRemoveComponent", "addComponent", "removeComponent", "addEntity", "removeEntity", "observe", "onAdd", "onRemove", "entityExists", "isRelation", "getRelationTargets", "Wildcard", "$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "$str", "$arr", "typeTagForSerialization", "symbol", "a", "u8", "i8", "u16", "i16", "u32", "i32", "f32", "f64", "str", "functionToSymbolMap", "typeSetters", "view", "offset", "value", "bytes", "textEncoder", "written", "typeGetters", "len", "lenSize", "textDecoder", "resolveTypeToSymbol", "type", "isArrayType", "isTypedArrayOrBranded", "arr", "getTypeForArray", "isArrayType", "resolveTypeToSymbol", "$arr", "symbol", "$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "$str", "value", "getArrayElementType", "arrayType", "serializeArrayValue", "elementType", "view", "offset", "bytesWritten", "isArrayDefined", "typeSetters", "i", "element", "deserializeArrayValue", "bytesRead", "isArrayResult", "typeGetters", "arrayLengthResult", "size", "isFloatType", "array", "getEpsilonForType", "epsilon", "getShadow", "shadowMap", "shadow", "hasChanged", "index", "currentValue", "actualEpsilon", "changed", "createComponentSerializer", "component", "diff", "type", "setter", "componentId", "props", "setters", "prop", "changeMask", "componentProperty", "maskSetter", "createComponentDeserializer", "getter", "entityIdMapping", "originalIndex", "indexSize", "cidSize", "getters", "maskGetter", "maskSize", "createSoASerializer", "components", "options", "buffer", "componentSerializers", "indices", "j", "createSoADeserializer", "componentDeserializers", "packet", "originalEid", "eidSize", "serializeRelationData", "data", "eid", "dataView", "offset", "value", "keys", "key", "arr", "$i8", "$u8", "$i16", "$u16", "$i32", "$u32", "$f32", "deserializeRelationData", "createObserverSerializer", "world", "networkedTag", "components", "buffer", "queue", "relationTargets", "observe", "onAdd", "onRemove", "component", "i", "isRelation", "Wildcard", "targets", "getRelationTargets", "target", "relationData", "targetMap", "entityId", "type", "componentId", "targetId", "createObserverDeserializer", "constructorMapping", "entityIdMapping", "packet", "overrideMapping", "currentMapping", "packetEntityId", "operationType", "worldEntityId", "addEntity", "addComponent", "entityExists", "removeEntity", "removeComponent", "worldTargetId", "relationComponent", "defineSerializer", "components", "maxBytes", "initSet", "serializeObservations", "serializeData", "world", "ents", "createObserverSerializer", "createSoASerializer", "observerData", "soaData", "combinedData", "combinedView", "defineDeserializer", "deserializeObservations", "deserializeData", "packet", "mode", "createObserverDeserializer", "createSoADeserializer", "observerDataLength", "DESERIALIZE_MODE", "$modifier", "modifier", "c", "mod", "inner", "Not", "Or", "Changed", "defineQuery", "components", "queryFn", "world", "query", "enterQuery", "queue", "initSet", "observe", "onAdd", "eid", "results", "exitQuery", "onRemove", "addComponent", "component", "ecsAddComponent", "hasComponent", "ecsHasComponent", "removeComponent", "ecsRemoveComponent", "Types", "arrayByTypeMap", "defineComponent", "schema", "max", "createSoA", "key", "type", "length", "TypeConstructor"]
}
