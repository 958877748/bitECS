{
  "version": 3,
  "sources": ["../../src/legacy/index.ts"],
  "sourcesContent": ["import { ComponentRef, QueryTerm, World, observe, onAdd, onRemove, query, EntityId } from '../core'\nimport { \n  addComponent as ecsAddComponent,\n  hasComponent as ecsHasComponent, \n  removeComponent as ecsRemoveComponent \n} from '../core'\n\nexport const defineQuery = (terms: QueryTerm[]) => {\n  const queryFn = (world: World) => query(world, terms)\n  queryFn.terms = terms\n  return queryFn\n}\n\nexport const enterQuery = (queryFn: ReturnType<typeof defineQuery>) => {\n  let queue: number[] = []\n  const initSet = new WeakSet<World>()\n  return (world: World) => {\n    if (!initSet.has(world)) {\n      observe(world, onAdd(...queryFn.terms), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const exitQuery = (queryFn: ReturnType<typeof defineQuery>) => {\n  let queue: number[] = []\n  const initSet = new WeakSet<World>()\n  return (world: World) => {\n    if (!initSet.has(world)) {\n      observe(world, onRemove(...queryFn.terms), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const addComponent = (world: World, component: ComponentRef, eid: EntityId) =>\n  ecsAddComponent(world, eid, component)\n\nexport const hasComponent = (world: World, component: ComponentRef, eid: EntityId) =>\n  ecsHasComponent(world, eid, component)\n\nexport const removeComponent = (world: World, component: ComponentRef, eid: EntityId) =>\n  ecsRemoveComponent(world, eid, component)\n\nexport type Schema = { [key: string]: Schema | PrimitiveType | [PrimitiveType, number] }\n\nexport type PrimitiveType = 'f32' | 'i32' | 'u32' | 'f64' | 'i8' | 'u8' | 'i16' | 'u16';\n\nexport const Types = {\n  f32: 'f32' as PrimitiveType,\n  i32: 'i32' as PrimitiveType,\n  u32: 'u32' as PrimitiveType,\n  f64: 'f64' as PrimitiveType,\n  i8: 'i8' as PrimitiveType,\n  u8: 'u8' as PrimitiveType,\n  i16: 'i16' as PrimitiveType,\n  u16: 'u16' as PrimitiveType\n};\n\ntype ArrayByType = {\n  'f32': Float32Array,\n  'i32': Int32Array,\n  'u32': Uint32Array,\n  'f64': Float64Array,\n  'i8': Int8Array,\n  'u8': Uint8Array,\n  'i16': Int16Array,\n  'u16': Uint16Array\n};\n\nconst arrayByTypeMap: { [key in PrimitiveType]: any } = {\n  'f32': Float32Array,\n  'i32': Int32Array,\n  'u32': Uint32Array,\n  'f64': Float64Array,\n  'i8': Int8Array,\n  'u8': Uint8Array,\n  'i16': Int16Array,\n  'u16': Uint16Array\n};\n\nexport type ComponentType<T extends Schema> = {\n  [key in keyof T]:\n    T[key] extends PrimitiveType\n    ? ArrayByType[T[key]]\n    : T[key] extends [infer RT, number]\n      ? RT extends PrimitiveType\n        ? ArrayByType[RT][]\n        : unknown\n      : T[key] extends Schema\n        ? ComponentType<T[key]>\n        : unknown;\n};\n\nexport const defineComponent = <T extends Schema>(schema: T, max: number = 1e5): ComponentType<T> => {\n  const createSoA = <U extends Schema>(schema: U, max: number): ComponentType<U> => {\n    const component = {} as ComponentType<U>\n    for (const key in schema) {\n      if (Array.isArray(schema[key])) {\n        const [type, length] = schema[key] as [PrimitiveType, number]\n        component[key] = Array.from({ length }, () => new arrayByTypeMap[type](max)) as any\n      } else if (typeof schema[key] === 'object') {\n        component[key] = createSoA(schema[key] as Schema, max) as any\n      } else {\n        const type = schema[key] as PrimitiveType;\n        const TypeConstructor = arrayByTypeMap[type];\n        if (TypeConstructor) {\n          component[key] = new TypeConstructor(max) as any;\n        } else {\n          throw new Error(`Unsupported type: ${schema[key]}`);\n        }\n      }\n    }\n    return component\n  }\n  return createSoA(schema, max)\n}"],
  "mappings": "AAAA,OAAyC,WAAAA,EAAS,SAAAC,EAAO,YAAAC,EAAU,SAAAC,MAAuB,UAC1F,OACE,gBAAgBC,EAChB,gBAAgBC,EAChB,mBAAmBC,MACd,UAEA,IAAMC,EAAeC,GAAuB,CACjD,IAAMC,EAAWC,GAAiBP,EAAMO,EAAOF,CAAK,EACpD,OAAAC,EAAQ,MAAQD,EACTC,CACT,EAEaE,EAAcF,GAA4C,CACrE,IAAIG,EAAkB,CAAC,EACjBC,EAAU,IAAI,QACpB,OAAQH,GAAiB,CAClBG,EAAQ,IAAIH,CAAK,IACpBV,EAAQU,EAAOT,EAAM,GAAGQ,EAAQ,KAAK,EAAIK,GAAkBF,EAAM,KAAKE,CAAG,CAAC,EAC1ED,EAAQ,IAAIH,CAAK,GAEnB,IAAMK,EAAUH,EAAM,MAAM,EAC5B,OAAAA,EAAM,OAAS,EACRG,CACT,CACF,EAEaC,EAAaP,GAA4C,CACpE,IAAIG,EAAkB,CAAC,EACjBC,EAAU,IAAI,QACpB,OAAQH,GAAiB,CAClBG,EAAQ,IAAIH,CAAK,IACpBV,EAAQU,EAAOR,EAAS,GAAGO,EAAQ,KAAK,EAAIK,GAAkBF,EAAM,KAAKE,CAAG,CAAC,EAC7ED,EAAQ,IAAIH,CAAK,GAEnB,IAAMK,EAAUH,EAAM,MAAM,EAC5B,OAAAA,EAAM,OAAS,EACRG,CACT,CACF,EAEaE,EAAe,CAACP,EAAcQ,EAAyBJ,IAClEV,EAAgBM,EAAOI,EAAKI,CAAS,EAE1BC,EAAe,CAACT,EAAcQ,EAAyBJ,IAClET,EAAgBK,EAAOI,EAAKI,CAAS,EAE1BE,EAAkB,CAACV,EAAcQ,EAAyBJ,IACrER,EAAmBI,EAAOI,EAAKI,CAAS,EAM7BG,EAAQ,CACnB,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,GAAI,KACJ,GAAI,KACJ,IAAK,MACL,IAAK,KACP,EAaMC,EAAkD,CACtD,IAAO,aACP,IAAO,WACP,IAAO,YACP,IAAO,aACP,GAAM,UACN,GAAM,WACN,IAAO,WACP,IAAO,WACT,EAeaC,EAAkB,CAAmBC,EAAWC,EAAc,MAA0B,CACnG,IAAMC,EAAY,CAAmBF,EAAWC,IAAkC,CAChF,IAAMP,EAAY,CAAC,EACnB,QAAWS,KAAOH,EAChB,GAAI,MAAM,QAAQA,EAAOG,CAAG,CAAC,EAAG,CAC9B,GAAM,CAACC,EAAMC,CAAM,EAAIL,EAAOG,CAAG,EACjCT,EAAUS,CAAG,EAAI,MAAM,KAAK,CAAE,OAAAE,CAAO,EAAG,IAAM,IAAIP,EAAeM,CAAI,EAAEH,CAAG,CAAC,CAC7E,SAAW,OAAOD,EAAOG,CAAG,GAAM,SAChCT,EAAUS,CAAG,EAAID,EAAUF,EAAOG,CAAG,EAAaF,CAAG,MAChD,CACL,IAAMG,EAAOJ,EAAOG,CAAG,EACjBG,EAAkBR,EAAeM,CAAI,EAC3C,GAAIE,EACFZ,EAAUS,CAAG,EAAI,IAAIG,EAAgBL,CAAG,MAExC,OAAM,IAAI,MAAM,qBAAqBD,EAAOG,CAAG,CAAC,EAAE,CAEtD,CAEF,OAAOT,CACT,EACA,OAAOQ,EAAUF,EAAQC,CAAG,CAC9B",
  "names": ["observe", "onAdd", "onRemove", "query", "ecsAddComponent", "ecsHasComponent", "ecsRemoveComponent", "defineQuery", "terms", "queryFn", "world", "enterQuery", "queue", "initSet", "eid", "results", "exitQuery", "addComponent", "component", "hasComponent", "removeComponent", "Types", "arrayByTypeMap", "defineComponent", "schema", "max", "createSoA", "key", "type", "length", "TypeConstructor"]
}
