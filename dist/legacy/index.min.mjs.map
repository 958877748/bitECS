{
  "version": 3,
  "sources": ["../../src/legacy/index.ts"],
  "sourcesContent": ["import { ComponentRef, QueryTerm, observe, onAdd, onRemove, query, EntityId } from '../core'\nimport {\n  addComponent as ecsAddComponent,\n  hasComponent as ecsHasComponent,\n  removeComponent as ecsRemoveComponent\n} from '../core'\n\nexport interface IWorld { }\n\nexport const defineQuery = (terms: QueryTerm[]) => {\n  const queryFn = (world: IWorld) => query(world, terms)\n  queryFn.terms = terms\n  return queryFn\n}\n\nexport const enterQuery = (queryFn: ReturnType<typeof defineQuery>) => {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: IWorld) => {\n    if (!initSet.has(world)) {\n      observe(world, onAdd(...queryFn.terms), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const exitQuery = (queryFn: ReturnType<typeof defineQuery>) => {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: IWorld) => {\n    if (!initSet.has(world)) {\n      observe(world, onRemove(...queryFn.terms), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const addComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsAddComponent(world, eid, component)\n\nexport const hasComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsHasComponent(world, eid, component)\n\nexport const removeComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsRemoveComponent(world, eid, component)\n\nexport interface ISchema {\n  [key: string]: Type | ListType | ISchema\n}\n\nexport type Type =\n  | 'i8'\n  | 'ui8'\n  | 'ui8c'\n  | 'i16'\n  | 'ui16'\n  | 'i32'\n  | 'ui32'\n  | 'f32'\n  | 'f64'\n  | 'eid'\n\nexport type ListType = readonly [Type, number];\n\nexport const Types = {\n  i8: 'i8' as Type,\n  ui8: 'ui8' as Type,\n  ui8c: 'ui8c' as Type,\n  i16: 'i16' as Type,\n  ui16: 'ui16' as Type,\n  i32: 'i32' as Type,\n  ui32: 'ui32' as Type,\n  f32: 'f32' as Type,\n  f64: 'f64' as Type,\n  eid: 'eid' as Type\n};\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n\nexport type ArrayByType = {\n  'i8': Int8Array;\n  'ui8': Uint8Array;\n  'ui8c': Uint8ClampedArray;\n  'i16': Int16Array;\n  'ui16': Uint16Array;\n  'i32': Int32Array;\n  'ui32': Uint32Array;\n  'f32': Float32Array;\n  'f64': Float64Array;\n  'eid': Uint32Array;\n}\n\n// ... existing code ...\n\nconst arrayByTypeMap: { [key in Type]: any } = {\n  'i8': Int8Array,\n  'ui8': Uint8Array,\n  'ui8c': Uint8ClampedArray,\n  'i16': Int16Array,\n  'ui16': Uint16Array,\n  'i32': Int32Array,\n  'ui32': Uint32Array,\n  'f32': Float32Array,\n  'f64': Float64Array,\n  'eid': Uint32Array,\n};\n\nexport type ComponentType<T extends ISchema> = {\n  [key in keyof T]:\n  T[key] extends Type\n  ? ArrayByType[T[key]]\n  : T[key] extends [infer RT, number]\n  ? RT extends Type\n  ? Array<ArrayByType[RT]>\n  : unknown\n  : T[key] extends ISchema\n  ? ComponentType<T[key]>\n  : unknown;\n};\n\nexport const defineComponent = <T extends ISchema>(schema: T, max: number = 1e5): ComponentType<T> => {\n  const createSoA = <U extends ISchema>(schema: U, max: number): ComponentType<U> => {\n    const component = {} as ComponentType<U>\n    for (const key in schema) {\n      if (Array.isArray(schema[key])) {\n        const [type, length] = schema[key] as [Type, number]\n        component[key] = Array.from({ length }, () => new arrayByTypeMap[type](max)) as any\n      } else if (typeof schema[key] === 'object') {\n        component[key] = createSoA(schema[key] as ISchema, max) as any\n      } else {\n        const type = schema[key] as Type;\n        const TypeConstructor = arrayByTypeMap[type];\n        if (TypeConstructor) {\n          component[key] = new TypeConstructor(max) as any;\n        } else {\n          throw new Error(`Unsupported type: ${schema[key]}`);\n        }\n      }\n    }\n    return component\n  }\n  return createSoA(schema, max)\n}"],
  "mappings": "AAAA,OAAkC,WAAAA,EAAS,SAAAC,EAAO,YAAAC,EAAU,SAAAC,MAAuB,UACnF,OACE,gBAAgBC,EAChB,gBAAgBC,EAChB,mBAAmBC,MACd,UAIA,IAAMC,EAAeC,GAAuB,CACjD,IAAMC,EAAWC,GAAkBP,EAAMO,EAAOF,CAAK,EACrD,OAAAC,EAAQ,MAAQD,EACTC,CACT,EAEaE,EAAcF,GAA4C,CACrE,IAAIG,EAAkB,CAAC,EACjBC,EAAU,IAAI,QACpB,OAAQH,GAAkB,CACnBG,EAAQ,IAAIH,CAAK,IACpBV,EAAQU,EAAOT,EAAM,GAAGQ,EAAQ,KAAK,EAAIK,GAAkBF,EAAM,KAAKE,CAAG,CAAC,EAC1ED,EAAQ,IAAIH,CAAK,GAEnB,IAAMK,EAAUH,EAAM,MAAM,EAC5B,OAAAA,EAAM,OAAS,EACRG,CACT,CACF,EAEaC,EAAaP,GAA4C,CACpE,IAAIG,EAAkB,CAAC,EACjBC,EAAU,IAAI,QACpB,OAAQH,GAAkB,CACnBG,EAAQ,IAAIH,CAAK,IACpBV,EAAQU,EAAOR,EAAS,GAAGO,EAAQ,KAAK,EAAIK,GAAkBF,EAAM,KAAKE,CAAG,CAAC,EAC7ED,EAAQ,IAAIH,CAAK,GAEnB,IAAMK,EAAUH,EAAM,MAAM,EAC5B,OAAAA,EAAM,OAAS,EACRG,CACT,CACF,EAEaE,EAAe,CAACP,EAAeQ,EAAyBJ,IACnEV,EAAgBM,EAAOI,EAAKI,CAAS,EAE1BC,EAAe,CAACT,EAAeQ,EAAyBJ,IACnET,EAAgBK,EAAOI,EAAKI,CAAS,EAE1BE,EAAkB,CAACV,EAAeQ,EAAyBJ,IACtER,EAAmBI,EAAOI,EAAKI,CAAS,EAoB7BG,EAAQ,CACnB,GAAI,KACJ,IAAK,MACL,KAAM,OACN,IAAK,MACL,KAAM,OACN,IAAK,MACL,KAAM,OACN,IAAK,MACL,IAAK,MACL,IAAK,KACP,EA4BMC,EAAyC,CAC7C,GAAM,UACN,IAAO,WACP,KAAQ,kBACR,IAAO,WACP,KAAQ,YACR,IAAO,WACP,KAAQ,YACR,IAAO,aACP,IAAO,aACP,IAAO,WACT,EAeaC,EAAkB,CAAoBC,EAAWC,EAAc,MAA0B,CACpG,IAAMC,EAAY,CAAoBF,EAAWC,IAAkC,CACjF,IAAMP,EAAY,CAAC,EACnB,QAAWS,KAAOH,EAChB,GAAI,MAAM,QAAQA,EAAOG,CAAG,CAAC,EAAG,CAC9B,GAAM,CAACC,EAAMC,CAAM,EAAIL,EAAOG,CAAG,EACjCT,EAAUS,CAAG,EAAI,MAAM,KAAK,CAAE,OAAAE,CAAO,EAAG,IAAM,IAAIP,EAAeM,CAAI,EAAEH,CAAG,CAAC,CAC7E,SAAW,OAAOD,EAAOG,CAAG,GAAM,SAChCT,EAAUS,CAAG,EAAID,EAAUF,EAAOG,CAAG,EAAcF,CAAG,MACjD,CACL,IAAMG,EAAOJ,EAAOG,CAAG,EACjBG,EAAkBR,EAAeM,CAAI,EAC3C,GAAIE,EACFZ,EAAUS,CAAG,EAAI,IAAIG,EAAgBL,CAAG,MAExC,OAAM,IAAI,MAAM,qBAAqBD,EAAOG,CAAG,CAAC,EAAE,CAEtD,CAEF,OAAOT,CACT,EACA,OAAOQ,EAAUF,EAAQC,CAAG,CAC9B",
  "names": ["observe", "onAdd", "onRemove", "query", "ecsAddComponent", "ecsHasComponent", "ecsRemoveComponent", "defineQuery", "terms", "queryFn", "world", "enterQuery", "queue", "initSet", "eid", "results", "exitQuery", "addComponent", "component", "hasComponent", "removeComponent", "Types", "arrayByTypeMap", "defineComponent", "schema", "max", "createSoA", "key", "type", "length", "TypeConstructor"]
}
