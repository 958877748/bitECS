import{observe as m,onAdd as u,onRemove as T,query as d}from"../core";import{addComponent as f,hasComponent as c,removeComponent as A}from"../core";var I=(...n)=>e=>d(e,n),S=(...n)=>{let e=[],r=new WeakSet;return t=>{r.has(t)||(m(t,u(...n),i=>e.push(i)),r.add(t));let y=e;return e=[],y}},U=(...n)=>{let e=[],r=new WeakSet;return t=>{r.has(t)||(m(t,T(...n),i=>e.push(i)),r.add(t));let y=e;return e=[],y}},W=(n,e,r)=>f(n,r,e),b=(n,e,r)=>c(n,r,e),h=(n,e,r)=>A(n,r,e),R={f32:"f32",i32:"i32",u32:"u32",f64:"f64",i8:"i8",u8:"u8",i16:"i16",u16:"u16"},s={f32:Float32Array,i32:Int32Array,u32:Uint32Array,f64:Float64Array,i8:Int8Array,u8:Uint8Array,i16:Int16Array,u16:Uint16Array},E=(n,e=1e5)=>{let r=(t,y)=>{let i={};for(let o in t)if(Array.isArray(t[o])){let[a,p]=t[o];i[o]=Array.from({length:p},()=>new s[a](y))}else if(typeof t[o]=="object")i[o]=r(t[o],y);else{let a=t[o],p=s[a];if(p)i[o]=new p(y);else throw new Error(`Unsupported type: ${t[o]}`)}return i};return r(n,e)};export{R as Types,W as addComponent,E as defineComponent,I as defineQuery,S as enterQuery,U as exitQuery,b as hasComponent,h as removeComponent};
//# sourceMappingURL=index.min.mjs.map
