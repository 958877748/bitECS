var W=(t,e,n)=>Object.defineProperty(t,e,{value:n,enumerable:!1,writable:!0,configurable:!0});var G=(t,e)=>{let n=t.sparse[e];return n!==void 0&&t.dense[n]===e};var l=Symbol("internal");var z=()=>{let t=[],e=[],n=a=>t[e[a]]===a;return{add:a=>{n(a)||(e[a]=t.push(a)-1)},remove:a=>{if(!n(a))return;let i=e[a],p=t.pop();p!==a&&(t[i]=p,e[p]=i)},has:n,sparse:e,dense:t,reset:()=>{t.length=0,e.length=0}}},ee=(t=1e3)=>{let e=[],n=0,o=new Uint32Array(t),r=p=>p<e.length&&e[p]<n&&o[e[p]]===p;return{add:p=>{if(!r(p)){if(n>=o.length){let m=new Uint32Array(o.length*2);m.set(o),o=m}o[n]=p,e[p]=n,n++}},remove:p=>{if(!r(p))return;n--;let m=e[p],u=o[n];o[m]=u,e[u]=m},has:r,sparse:e,get dense(){return new Uint32Array(o.buffer,0,n)},reset:()=>{n=0,e.length=0}}};var Q=()=>{let t=new Set;return{subscribe:o=>(t.add(o),()=>{t.delete(o)}),notify:(o,...r)=>Array.from(t).reduce((s,a)=>{let i=a(o,...r);return i&&typeof i=="object"?{...s,...i}:s},{})}};var R=Symbol("opType"),M=Symbol("opTerms"),V=(...t)=>({[R]:"add",[M]:t}),L=(...t)=>({[R]:"remove",[M]:t});function K(t,e,n){let o=t[l],{[R]:r,[M]:s}=e;if(r==="add"||r==="remove"){let a=J(t,s),i=o.queriesHashMap.get(a);return i||(i=U(t,s)),i[r==="add"?"addObservable":"removeObservable"].subscribe(n)}else if(r==="set"||r==="get"){if(s.length!==1)throw new Error("Set and Get hooks can only observe a single component");let a=s[0],i=o.componentMap.get(a);if(!i&&(C(t,a),!o.componentMap.get(a)))throw new Error(`Failed to register component ${a.name}`);return i[r==="set"?"setObservable":"getObservable"].subscribe(n)}throw new Error(`Invalid hook type: ${r}`)}var J=(t,e)=>{let n=t[l],o=s=>(n.componentMap.has(s)||C(t,s),n.componentMap.get(s).id),r=s=>{if(R in s){let i=s[M].map(o).sort((m,u)=>m-u);return`${s[R].toLowerCase()}(${i.join(",")})`}else return o(s).toString()};return e.map(r).sort().join("-")},U=(t,e,n={})=>{let o=t[l],r=J(t,e),s=[],a=[],i=[],p=(c,y)=>{c.forEach(N=>{o.componentMap.has(N)||C(t,N),y.push(N)})};e.forEach(c=>{R in c?c[R]==="Not"?p(c[M],a):c[R]==="Or"&&p(c[M],i):(o.componentMap.has(c)||C(t,c),s.push(c))});let m=c=>o.componentMap.get(c),u=s.concat(a.flat()).concat(i.flat()).map(m),d=n.buffered?ee():z(),x=z(),O=u.map(c=>c.generationId).reduce((c,y)=>(c.includes(y)||c.push(y),c),[]),f=(c,y)=>(c[y.generationId]||(c[y.generationId]=0),c[y.generationId]|=y.bitflag,c),B=s.map(m).reduce(f,{}),pe=a.map(m).reduce(f,{}),ce=i.map(m).reduce(f,{}),me=u.reduce(f,{}),ue=Q(),le=Q(),g=Object.assign(d,{components:s,notComponents:a,orComponents:i,allComponents:u,masks:B,notMasks:pe,orMasks:ce,hasMasks:me,generations:O,toRemove:x,addObservable:ue,removeObservable:le,queues:{}});o.queries.add(g),o.queriesHashMap.set(r,g),u.forEach(c=>{c.queries.add(g)}),a.length&&o.notQueries.add(g);let _=o.entityIndex;for(let c=0;c<_.aliveCount;c++){let y=_.dense[c];if(h(t,y,S))continue;$(t,g,y)&&q(g,y)}return g};function X(t,e,n={}){let o=t[l],r=J(t,e),s=o.queriesHashMap.get(r);return s?n.buffered&&!("buffer"in s.dense)&&(s=U(t,e,{buffered:!0})):s=U(t,e,n),s.dense}function Y(t,e){return te(t),X(t,e)}function $(t,e,n){let o=t[l],{masks:r,notMasks:s,orMasks:a,generations:i}=e;for(let p=0;p<i.length;p++){let m=i[p],u=r[m],d=s[m],x=a[m],O=o.entityMasks[m][n];if(d&&O&d||u&&(O&u)!==u||x&&!(O&x))return!1}return!0}var q=(t,e)=>{t.toRemove.remove(e),t.addObservable.notify(e),t.add(e)},ye=t=>{for(let e=0;e<t.toRemove.dense.length;e++){let n=t.toRemove.dense[e];t.remove(n)}t.toRemove.reset()},te=t=>{let e=t[l];e.dirtyQueries.size&&(e.dirtyQueries.forEach(ye),e.dirtyQueries.clear())},w=(t,e,n)=>{let o=t[l];!e.has(n)||e.toRemove.has(n)||(e.toRemove.add(n),o.dirtyQueries.add(e),e.removeObservable.notify(n))};var k=Symbol("relation"),I=Symbol("pairTarget"),j=Symbol("isPairComponent"),v=Symbol("relationData"),ne=()=>{let t={pairsMap:new Map,initStore:void 0,exclusiveRelation:!1,autoRemoveSubject:!1,onTargetRemoved:void 0},e=n=>{if(n===void 0)throw Error("Relation target is undefined");let o=n==="*"?b:n;if(!t.pairsMap.has(o)){let r=t.initStore?t.initStore():{};W(r,k,e),W(r,I,o),W(r,j,!0),t.pairsMap.set(o,r)}return t.pairsMap.get(o)};return W(e,v,t),e},oe=t=>e=>{let n=e[v];return n.initStore=t,e},fe=t=>{let e=t[v];return e.exclusiveRelation=!0,t},re=t=>{let e=t[v];return e.autoRemoveSubject=!0,t},se=t=>e=>{let n=e[v];return n.onTargetRemoved=t,e};var E=(t,e)=>{if(t===void 0)throw Error("Relation is undefined");return t(e)},b=Z(),A=Z(),D=(t,e,n)=>{let o=H(t,e),r=[];for(let s of o)s[k]===n&&s[I]!==b&&r.push(s[I]);return r};function Z(...t){if(t.length===1&&typeof t[0]=="object"){let{store:e,exclusive:n,autoRemoveSubject:o,onTargetRemoved:r}=t[0];return[e&&oe(e),n&&fe,o&&re,r&&se(r)].filter(Boolean).reduce((a,i)=>i(a),ne())}else return t.reduce((n,o)=>o(n),ne())}var C=(t,e)=>{if(!e)throw new Error("bitECS - Cannot register null or undefined component");let n=t[l],o=new Set,r={id:n.componentCount++,generationId:n.entityMasks.length-1,bitflag:n.bitflag,ref:e,queries:o,setObservable:Q(),getObservable:Q()};return n.componentMap.set(e,r),n.bitflag*=2,n.bitflag>=2**31&&(n.bitflag=1,n.entityMasks.push([])),r};var h=(t,e,n)=>{let o=t[l],r=o.componentMap.get(n);if(!r)return!1;let{generationId:s,bitflag:a}=r;return(o.entityMasks[s][e]&a)===a},ae=(t,e,n)=>{let r=t[l].componentMap.get(n);if(r&&h(t,e,n))return r.getObservable.notify(e)};var ie=(t,e,n)=>{let o=t[l];T(t,e,A(n));let r=H(t,n);for(let a of r){if(a===S)continue;T(t,e,a);let i=o.componentMap.get(a);if(i&&i.setObservable){let p=ae(t,n,a);i.setObservable.notify(e,p)}}let s=D(t,n,A);for(let a of s)ie(t,e,a)},T=(t,e,...n)=>{let o=t[l];if(!F(t,e))throw new Error(`Cannot add component - entity ${e} does not exist in the world.`);n.forEach(r=>{let s="component"in r?r.component:r,a="data"in r?r.data:void 0;if(o.componentMap.has(s)||C(t,s),h(t,e,s))return;let i=o.componentMap.get(s),{generationId:p,bitflag:m,queries:u}=i;if(o.entityMasks[p][e]|=m,h(t,e,S)||u.forEach(d=>{d.toRemove.remove(e),$(t,d,e)?q(d,e):w(t,d,e)}),o.entityComponents.get(e).add(s),a!==void 0&&i.setObservable.notify(e,a),s[j]){let d=s[k];T(t,e,E(d,b));let x=s[I];if(T(t,e,E(b,x)),d[v].exclusiveRelation===!0&&x!==b){let f=D(t,e,d)[0];f!=null&&f!==x&&P(t,e,d(f))}if(d===A){let f=D(t,e,A);for(let B of f)ie(t,e,B)}}})};var P=(t,e,...n)=>{let o=t[l];if(!F(t,e))throw new Error(`Cannot remove component - entity ${e} does not exist in the world.`);n.forEach(r=>{if(!h(t,e,r))return;let s=o.componentMap.get(r),{generationId:a,bitflag:i,queries:p}=s;if(o.entityMasks[a][e]&=~i,p.forEach(m=>{m.toRemove.remove(e),$(t,m,e)?q(m,e):w(t,m,e)}),o.entityComponents.get(e).delete(r),r[j]){let m=r[I];P(t,e,E(b,m));let u=r[k];D(t,e,u).length===0&&P(t,e,E(u,b))}})};var S={};var H=(t,e)=>{let n=t[l];if(e===void 0)throw new Error("bitECS - entity is undefined.");if(!G(n.entityIndex,e))throw new Error("bitECS - entity does not exist in the world.");return Array.from(n.entityComponents.get(e))},F=(t,e)=>G(t[l].entityIndex,e);var jt=(...t)=>e=>Y(e,t),Ht=(...t)=>{let e=[],n=new WeakSet;return o=>{n.has(o)||(K(o,V(...t),s=>e.push(s)),n.add(o));let r=e;return e=[],r}},Pt=(...t)=>{let e=[],n=new WeakSet;return o=>{n.has(o)||(K(o,L(...t),s=>e.push(s)),n.add(o));let r=e;return e=[],r}},Nt=(t,e,n)=>T(t,n,e);export{Nt as addComponent,jt as defineQuery,Ht as enterQuery,Pt as exitQuery};
//# sourceMappingURL=index.min.mjs.map
