import{observe as u,onAdd as T,onRemove as d,query as m}from"../core";import{addComponent as A,hasComponent as c,removeComponent as f}from"../core";var k=n=>{let e=r=>m(r,n);return e.terms=n,e},S=n=>{let e=[],r=new WeakSet;return t=>{r.has(t)||(u(t,T(...n.terms),o=>e.push(o)),r.add(t));let p=e.slice();return e.length=0,p}},h=n=>{let e=[],r=new WeakSet;return t=>{r.has(t)||(u(t,d(...n.terms),o=>e.push(o)),r.add(t));let p=e.slice();return e.length=0,p}},R=(n,e,r)=>A(n,r,e),W=(n,e,r)=>c(n,r,e),b=(n,e,r)=>f(n,r,e),E={i8:"i8",ui8:"ui8",ui8c:"ui8c",i16:"i16",ui16:"ui16",i32:"i32",ui32:"ui32",f32:"f32",f64:"f64",eid:"eid"},s={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},F=(n,e=1e5)=>{let r=(t,p)=>{let o={};for(let y in t)if(Array.isArray(t[y])){let[a,i]=t[y];o[y]=Array.from({length:i},()=>new s[a](p))}else if(typeof t[y]=="object")o[y]=r(t[y],p);else{let a=t[y],i=s[a];if(i)o[y]=new i(p);else throw new Error(`Unsupported type: ${t[y]}`)}return o};return r(n,e)};export{E as Types,R as addComponent,F as defineComponent,k as defineQuery,S as enterQuery,h as exitQuery,W as hasComponent,b as removeComponent};
//# sourceMappingURL=index.min.mjs.map
