var C=(t,e,n)=>Object.defineProperty(t,e,{value:n,enumerable:!1,writable:!0,configurable:!0});var z=(t,e)=>{let n=t.sparse[e];return n!==void 0&&t.dense[n]===e};var l=Symbol("internal");var G=()=>{let t=[],e=[],n=a=>t[e[a]]===a;return{add:a=>{n(a)||(e[a]=t.push(a)-1)},remove:a=>{if(!n(a))return;let i=e[a],p=t.pop();p!==a&&(t[i]=p,e[p]=i)},has:n,sparse:e,dense:t,reset:()=>{t.length=0,e.length=0}}},ee=(t=1e3)=>{let e=[],n=0,o=new Uint32Array(t),r=p=>p<e.length&&e[p]<n&&o[e[p]]===p;return{add:p=>{if(!r(p)){if(n>=o.length){let m=new Uint32Array(o.length*2);m.set(o),o=m}o[n]=p,e[p]=n,n++}},remove:p=>{if(!r(p))return;n--;let m=e[p],d=o[n];o[m]=d,e[d]=m},has:r,sparse:e,get dense(){return new Uint32Array(o.buffer,0,n)},reset:()=>{n=0,e.length=0}}};var M=()=>{let t=new Set;return{subscribe:o=>(t.add(o),()=>{t.delete(o)}),notify:(o,...r)=>Array.from(t).reduce((s,a)=>{let i=a(o,...r);return i&&typeof i=="object"?{...s,...i}:s},{})}};var R=Symbol("opType"),Q=Symbol("opTerms"),V=(...t)=>({[R]:"add",[Q]:t}),L=(...t)=>({[R]:"remove",[Q]:t});function U(t,e,n){let o=t[l],{[R]:r,[Q]:s}=e;if(r==="add"||r==="remove"){let a=J(t,s),i=o.queriesHashMap.get(a);return i||(i=w(t,s)),i[r==="add"?"addObservable":"removeObservable"].subscribe(n)}else if(r==="set"||r==="get"){if(s.length!==1)throw new Error("Set and Get hooks can only observe a single component");let a=s[0],i=o.componentMap.get(a);if(!i&&(h(t,a),!o.componentMap.get(a)))throw new Error(`Failed to register component ${a.name}`);return i[r==="set"?"setObservable":"getObservable"].subscribe(n)}throw new Error(`Invalid hook type: ${r}`)}var J=(t,e)=>{let n=t[l],o=s=>(n.componentMap.has(s)||h(t,s),n.componentMap.get(s).id),r=s=>{if(R in s){let i=s[Q].map(o).sort((m,d)=>m-d);return`${s[R].toLowerCase()}(${i.join(",")})`}else return o(s).toString()};return e.map(r).sort().join("-")},w=(t,e,n={})=>{let o=t[l],r=J(t,e),s=[],a=[],i=[],p=(c,y)=>{c.forEach(N=>{o.componentMap.has(N)||h(t,N),y.push(N)})};e.forEach(c=>{R in c?c[R]==="Not"?p(c[Q],a):c[R]==="Or"&&p(c[Q],i):(o.componentMap.has(c)||h(t,c),s.push(c))});let m=c=>o.componentMap.get(c),d=s.concat(a.flat()).concat(i.flat()).map(m),u=n.buffered?ee():G(),x=G(),O=d.map(c=>c.generationId).reduce((c,y)=>(c.includes(y)||c.push(y),c),[]),f=(c,y)=>(c[y.generationId]||(c[y.generationId]=0),c[y.generationId]|=y.bitflag,c),F=s.map(m).reduce(f,{}),pe=a.map(m).reduce(f,{}),ce=i.map(m).reduce(f,{}),me=d.reduce(f,{}),de=M(),le=M(),v=Object.assign(u,{components:s,notComponents:a,orComponents:i,allComponents:d,masks:F,notMasks:pe,orMasks:ce,hasMasks:me,generations:O,toRemove:x,addObservable:de,removeObservable:le,queues:{}});o.queries.add(v),o.queriesHashMap.set(r,v),d.forEach(c=>{c.queries.add(v)}),a.length&&o.notQueries.add(v);let _=o.entityIndex;for(let c=0;c<_.aliveCount;c++){let y=_.dense[c];if(I(t,y,S))continue;D(t,v,y)&&$(v,y)}return v};function X(t,e,n={}){let o=t[l],r=J(t,e),s=o.queriesHashMap.get(r);return s?n.buffered&&!("buffer"in s.dense)&&(s=w(t,e,{buffered:!0})):s=w(t,e,n),s.dense}function Y(t,e){return te(t),X(t,e)}function D(t,e,n){let o=t[l],{masks:r,notMasks:s,orMasks:a,generations:i}=e;for(let p=0;p<i.length;p++){let m=i[p],d=r[m],u=s[m],x=a[m],O=o.entityMasks[m][n];if(u&&O&u||d&&(O&d)!==d||x&&!(O&x))return!1}return!0}var $=(t,e)=>{t.toRemove.remove(e),t.addObservable.notify(e),t.add(e)},ye=t=>{for(let e=0;e<t.toRemove.dense.length;e++){let n=t.toRemove.dense[e];t.remove(n)}t.toRemove.reset()},te=t=>{let e=t[l];e.dirtyQueries.size&&(e.dirtyQueries.forEach(ye),e.dirtyQueries.clear())},K=(t,e,n)=>{let o=t[l];!e.has(n)||e.toRemove.has(n)||(e.toRemove.add(n),o.dirtyQueries.add(e),e.removeObservable.notify(n))};var k=Symbol("relation"),W=Symbol("pairTarget"),q=Symbol("isPairComponent"),T=Symbol("relationData"),ne=()=>{let t={pairsMap:new Map,initStore:void 0,exclusiveRelation:!1,autoRemoveSubject:!1,onTargetRemoved:void 0},e=n=>{if(n===void 0)throw Error("Relation target is undefined");let o=n==="*"?b:n;if(!t.pairsMap.has(o)){let r={};C(r,k,e),C(r,W,o),C(r,q,!0),t.pairsMap.set(o,r)}return t.pairsMap.get(o)};return C(e,T,t),e},oe=t=>e=>{let n=e[T];return n.initStore=t,o=>{if(o===void 0)throw Error("Relation target is undefined");let r=o==="*"?b:o;if(!n.pairsMap.has(r)){let s=t();C(s,T,{pairTarget:r,...n}),n.pairsMap.set(r,s)}return n.pairsMap.get(r)}},fe=t=>{let e=t[T];return e.exclusiveRelation=!0,t},re=t=>{let e=t[T];return e.autoRemoveSubject=!0,t},se=t=>e=>{let n=e[T];return n.onTargetRemoved=t,e};var E=(t,e)=>{if(t===void 0)throw Error("Relation is undefined");return t(e)},b=Z(),A=Z(),j=(t,e,n)=>{let o=H(t,e),r=[];for(let s of o)s[k]===n&&s[W]!==b&&r.push(s[W]);return r};function Z(...t){if(t.length===1&&typeof t[0]=="object"){let{store:e,exclusive:n,autoRemoveSubject:o,onTargetRemoved:r}=t[0];return[e&&oe(e),n&&fe,o&&re,r&&se(r)].filter(Boolean).reduce((a,i)=>i(a),ne())}else return t.reduce((n,o)=>o(n),ne())}var h=(t,e)=>{if(!e)throw new Error("bitECS - Cannot register null or undefined component");let n=t[l],o=new Set,r={id:n.componentCount++,generationId:n.entityMasks.length-1,bitflag:n.bitflag,ref:e,queries:o,setObservable:M(),getObservable:M()};return n.componentMap.set(e,r),n.bitflag*=2,n.bitflag>=2**31&&(n.bitflag=1,n.entityMasks.push([])),r};var I=(t,e,n)=>{let o=t[l],r=o.componentMap.get(n);if(!r)return!1;let{generationId:s,bitflag:a}=r;return(o.entityMasks[s][e]&a)===a},ae=(t,e,n)=>{let r=t[l].componentMap.get(n);if(r&&I(t,e,n))return r.getObservable.notify(e)};var ie=(t,e,n)=>{let o=t[l];g(t,e,A(n));let r=H(t,n);for(let a of r){if(a===S)continue;g(t,e,a);let i=o.componentMap.get(a);if(i&&i.setObservable){let p=ae(t,n,a);i.setObservable.notify(e,p)}}let s=j(t,n,A);for(let a of s)ie(t,e,a)},g=(t,e,...n)=>{let o=t[l];if(!B(t,e))throw new Error(`Cannot add component - entity ${e} does not exist in the world.`);n.forEach(r=>{let s="component"in r?r.component:r,a="data"in r?r.data:void 0;if(o.componentMap.has(s)||h(t,s),I(t,e,s))return;let i=o.componentMap.get(s),{generationId:p,bitflag:m,queries:d}=i;if(o.entityMasks[p][e]|=m,I(t,e,S)||d.forEach(u=>{u.toRemove.remove(e),D(t,u,e)?$(u,e):K(t,u,e)}),o.entityComponents.get(e).add(s),a!==void 0&&i.setObservable.notify(e,a),s[q]){let u=s[k];g(t,e,E(u,b));let x=s[W];if(g(t,e,E(b,x)),u[T].exclusiveRelation===!0&&x!==b){let f=j(t,e,u)[0];f!=null&&f!==x&&P(t,e,u(f))}if(u===A){let f=j(t,e,A);for(let F of f)ie(t,e,F)}}})};var P=(t,e,...n)=>{let o=t[l];if(!B(t,e))throw new Error(`Cannot remove component - entity ${e} does not exist in the world.`);n.forEach(r=>{if(!I(t,e,r))return;let s=o.componentMap.get(r),{generationId:a,bitflag:i,queries:p}=s;if(o.entityMasks[a][e]&=~i,p.forEach(m=>{m.toRemove.remove(e),D(t,m,e)?$(m,e):K(t,m,e)}),o.entityComponents.get(e).delete(r),r[q]){let m=r[W];P(t,e,E(b,m));let d=r[k];j(t,e,d).length===0&&P(t,e,E(d,b))}})};var S={};var H=(t,e)=>{let n=t[l];if(e===void 0)throw new Error("bitECS - entity is undefined.");if(!z(n.entityIndex,e))throw new Error("bitECS - entity does not exist in the world.");return Array.from(n.entityComponents.get(e))},B=(t,e)=>z(t[l].entityIndex,e);var Pt=(...t)=>e=>Y(e,t),Nt=(...t)=>{let e=[],n=new WeakSet;return o=>{n.has(o)||(U(o,V(...t),s=>e.push(s)),n.add(o));let r=e;return e=[],r}},wt=(...t)=>{let e=[],n=new WeakSet;return o=>{n.has(o)||(U(o,L(...t),s=>e.push(s)),n.add(o));let r=e;return e=[],r}},Ut=(t,e,n)=>g(t,n,e);export{Ut as addComponent,Pt as defineQuery,Nt as enterQuery,wt as exitQuery};
//# sourceMappingURL=index.min.mjs.map
