import{observe as m,onAdd as u,onRemove as T,query as d}from"../core";import{addComponent as f,hasComponent as c,removeComponent as A}from"../core";var I=r=>{let e=t=>d(t,r);return e.terms=r,e},S=r=>{let e=[],t=new WeakSet;return n=>{t.has(n)||(m(n,u(...r.terms),i=>e.push(i)),t.add(n));let y=e.slice();return e.length=0,y}},h=r=>{let e=[],t=new WeakSet;return n=>{t.has(n)||(m(n,T(...r.terms),i=>e.push(i)),t.add(n));let y=e.slice();return e.length=0,y}},R=(r,e,t)=>f(r,t,e),U=(r,e,t)=>c(r,t,e),W=(r,e,t)=>A(r,t,e),b={f32:"f32",i32:"i32",u32:"u32",f64:"f64",i8:"i8",u8:"u8",i16:"i16",u16:"u16"},a={f32:Float32Array,i32:Int32Array,u32:Uint32Array,f64:Float64Array,i8:Int8Array,u8:Uint8Array,i16:Int16Array,u16:Uint16Array},E=(r,e=1e5)=>{let t=(n,y)=>{let i={};for(let o in n)if(Array.isArray(n[o])){let[s,p]=n[o];i[o]=Array.from({length:p},()=>new a[s](y))}else if(typeof n[o]=="object")i[o]=t(n[o],y);else{let s=n[o],p=a[s];if(p)i[o]=new p(y);else throw new Error(`Unsupported type: ${n[o]}`)}return i};return t(r,e)};export{b as Types,R as addComponent,E as defineComponent,I as defineQuery,S as enterQuery,h as exitQuery,U as hasComponent,W as removeComponent};
//# sourceMappingURL=index.min.mjs.map
