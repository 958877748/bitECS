{
  "version": 3,
  "sources": ["../../src/legacy/index.ts", "../../src/serialization/ObserverSerializer.ts", "../../src/serialization/SoASerializer.ts", "../../src/legacy/serialization.ts"],
  "sourcesContent": ["import { ComponentRef, observe, onAdd, onRemove, query, EntityId } from '../core'\nimport {\n  addComponent as ecsAddComponent,\n  hasComponent as ecsHasComponent,\n  removeComponent as ecsRemoveComponent\n} from '../core'\n\nexport interface IWorld { }\n\nexport type ComponentProp = TypedArray | Array<TypedArray>\n\nexport interface IComponentProp {\n}\n\nexport interface IComponent {\n}\n\nexport type Component = IComponent | ComponentType<ISchema>\n\nexport type QueryModifier = (c: IComponent[]) => IComponent | QueryModifier\n\nexport type Query<W extends IWorld = IWorld> = (world: W, clearDiff?: Boolean) => number[]\n\nexport const $modifier = Symbol(\"$modifier\")\n\nfunction modifier(c, mod) {\n  const inner = () => [c, mod]\n  inner[$modifier] = true\n  return inner\n}\n\nexport const Not = (c: Component | ISchema): QueryModifier => modifier(c, 'not')\nexport const Or = (c: Component | ISchema): QueryModifier => modifier(c, 'or')\nexport const Changed = (c: Component | ISchema): QueryModifier => modifier(c, 'changed')\n\nexport function defineQuery<W extends IWorld = IWorld>(components: (Component | QueryModifier)[]): Query<W> {\n  const queryFn = (world: IWorld) => query(world, components)\n  queryFn.components = components\n  return queryFn as unknown as Query<W>\n}\n\nexport function enterQuery<W extends IWorld = IWorld>(queryFn: Query<W>): Query<W> {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: W) => {\n    if (!initSet.has(world)) {\n      observe(world, onAdd(...(queryFn as any).components), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport function exitQuery<W extends IWorld = IWorld>(queryFn: Query<W>): Query<W> {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: W) => {\n    if (!initSet.has(world)) {\n      observe(world, onRemove(...(queryFn as any).terms), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const addComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsAddComponent(world, eid, component)\n\nexport const hasComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsHasComponent(world, eid, component)\n\nexport const removeComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsRemoveComponent(world, eid, component)\n\nexport interface ISchema {\n  [key: string]: Type | ListType | ISchema\n}\n\nexport type Type =\n  | 'i8'\n  | 'ui8'\n  | 'ui8c'\n  | 'i16'\n  | 'ui16'\n  | 'i32'\n  | 'ui32'\n  | 'f32'\n  | 'f64'\n  | 'eid'\n\nexport type ListType = readonly [Type, number];\n\nexport const Types = {\n  i8: 'i8' as Type,\n  ui8: 'ui8' as Type,\n  ui8c: 'ui8c' as Type,\n  i16: 'i16' as Type,\n  ui16: 'ui16' as Type,\n  i32: 'i32' as Type,\n  ui32: 'ui32' as Type,\n  f32: 'f32' as Type,\n  f64: 'f64' as Type,\n  eid: 'eid' as Type\n};\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n\nexport type ArrayByType = {\n  'i8': Int8Array;\n  'ui8': Uint8Array;\n  'ui8c': Uint8ClampedArray;\n  'i16': Int16Array;\n  'ui16': Uint16Array;\n  'i32': Int32Array;\n  'ui32': Uint32Array;\n  'f32': Float32Array;\n  'f64': Float64Array;\n  'eid': Uint32Array;\n}\n\n// ... existing code ...\n\nconst arrayByTypeMap: { [key in Type]: any } = {\n  'i8': Int8Array,\n  'ui8': Uint8Array,\n  'ui8c': Uint8ClampedArray,\n  'i16': Int16Array,\n  'ui16': Uint16Array,\n  'i32': Int32Array,\n  'ui32': Uint32Array,\n  'f32': Float32Array,\n  'f64': Float64Array,\n  'eid': Uint32Array,\n};\n\nexport type ComponentType<T extends ISchema> = {\n  [key in keyof T]:\n  T[key] extends Type\n  ? ArrayByType[T[key]]\n  : T[key] extends [infer RT, number]\n  ? RT extends Type\n  ? Array<ArrayByType[RT]>\n  : unknown\n  : T[key] extends ISchema\n  ? ComponentType<T[key]>\n  : unknown;\n};\n\nexport const defineComponent = <T extends ISchema>(schema: T, max: number = 1e5): ComponentType<T> => {\n  const createSoA = <U extends ISchema>(schema: U, max: number): ComponentType<U> => {\n    const component = {} as ComponentType<U>\n    for (const key in schema) {\n      if (Array.isArray(schema[key])) {\n        const [type, length] = schema[key] as [Type, number]\n        component[key] = Array.from({ length }, () => new arrayByTypeMap[type](max)) as any\n      } else if (typeof schema[key] === 'object') {\n        component[key] = createSoA(schema[key] as ISchema, max) as any\n      } else {\n        const type = schema[key] as Type;\n        const TypeConstructor = arrayByTypeMap[type];\n        if (TypeConstructor) {\n          component[key] = new TypeConstructor(max) as any;\n        } else {\n          throw new Error(`Unsupported type: ${schema[key]}`);\n        }\n      }\n    }\n    return component\n  }\n  return createSoA(schema, max)\n}\n\nexport * from './serialization'", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n} from '../core'\nimport { EntityId } from '../core/Entity'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components to observe for changes.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the queued changes and returns a slice of the buffer.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number][] = []\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n    })\n\n    components.forEach((component, i) => {\n        observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n            queue.push([eid, OperationType.AddComponent, i])\n        })\n\n        observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n            queue.push([eid, OperationType.RemoveComponent, i])\n        })\n    })\n\n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            dataView.setUint8(offset, componentId)\n            offset += 1\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components that can be added or removed.\n * @returns {Function} A function that takes a serialized packet and an optional entity ID mapping, and applies the changes to the world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[]) => {\n    return (packet: ArrayBuffer, entityIdMapping: Map<number, number> = new Map()) => {\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            const componentId = dataView.getUint8(offset)\n            offset += 1\n\n            const component = components[componentId]\n\n            let worldEntityId = entityIdMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                entityIdMapping.set(packetEntityId, worldEntityId)\n            }\n            if (operationType === OperationType.AddEntity) {\n                addComponent(world, worldEntityId, networkedTag)\n            } else if (operationType === OperationType.RemoveEntity) {\n                removeEntity(world, worldEntityId)\n            } else if (operationType === OperationType.AddComponent) {\n                addComponent(world, worldEntityId, component)\n            } else if (operationType === OperationType.RemoveComponent) {\n                removeComponent(world, worldEntityId, component)\n            }\n        }\n\n        return entityIdMapping\n    }\n}\n", "import { ComponentRef } from \"../core\"\n\n/**\n * Symbols representing different data types for serialization.\n */\nconst $u8 = Symbol('u8'), $i8 = Symbol('i8'), $u16 = Symbol('u16'), $i16 = Symbol('i16'),\n    $u32 = Symbol('u32'), $i32 = Symbol('i32'), $f32 = Symbol('f32'), $f64 = Symbol('f64')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = (number[] & { [key: symbol]: true }) | TypedArray\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: number[] = []): PrimitiveBrand => \n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64)\n\n/**\n * Object containing setter functions for each data type.\n */\nconst typeSetters = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; }\n}\n\n/**\n * Object containing getter functions for each data type.\n */\nconst typeGetters = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 })\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number) => {\n        let bytesWritten = 0\n        // Write index first\n        bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index)\n        for (let i = 0; i < props.length; i++) {\n            bytesWritten += setters[i](view, offset + bytesWritten, component[props[i]][index])\n        }\n        return bytesWritten\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        for (let i = 0; i < props.length; i++) {\n            const { value, size } = getters[i](view, offset + bytesRead)\n            component[props[i]][index] = value\n            bytesRead += size\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {ArrayBuffer} [buffer] - The buffer to use for serialization.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: ComponentRef[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const view = new DataView(buffer)\n    const componentSerializers = components.map(createComponentSerializer)\n    return (indices: number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index)\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: ComponentRef[]) => {\n    const componentDeserializers = components.map(createComponentDeserializer)\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            for (let i = 0; i < componentDeserializers.length; i++) {\n                offset += componentDeserializers[i](view, offset, entityIdMapping)\n            }\n        }\n    }\n}\n", "\nimport { createObserverSerializer, createObserverDeserializer } from '../serialization/ObserverSerializer'\nimport { createSoASerializer, createSoADeserializer } from '../serialization/SoASerializer'\nimport { IWorld, Component, IComponentProp, query } from '../core'\n\nexport type Serializer<W extends IWorld = IWorld> = (target: W | number[]) => ArrayBuffer\nexport type Deserializer<W extends IWorld = IWorld> = (world: W, packet: ArrayBuffer, mode?: 'full' | 'partial') => number[]\n\nexport function defineSerializer<W extends IWorld = IWorld>(components: Component[] | IComponentProp[], maxBytes?: number): Serializer<W> {\n  const initSet = new WeakSet<Component[] | IComponentProp[]>();\n  let serializeObservations: () => ArrayBuffer, serializeData: (indices: number[]) => ArrayBuffer;\n  return (world: W | number[]) => {\n    if (!initSet.has(components)) {\n      initSet.add(components);\n      serializeObservations = createObserverSerializer(world, components[0], components);\n      serializeData = createSoASerializer(components as Component[]);\n    }\n    const observerData = serializeObservations();\n    const soaData = serializeData(query(world, components) as number[]);\n    // Combine observer and soa data into a single ArrayBuffer\n    const combinedData = new ArrayBuffer(observerData.byteLength + soaData.byteLength);\n    const combinedView = new Uint8Array(combinedData);\n    combinedView.set(new Uint8Array(observerData), 0);\n    combinedView.set(new Uint8Array(soaData), observerData.byteLength);\n    return combinedData;\n  }\n}\n\nexport function defineDeserializer<W extends IWorld = IWorld>(components: Component[] | IComponentProp[]): Deserializer<W> {\n  const initSet = new WeakSet<Component[] | IComponentProp[]>();\n  let deserializeObservations: any, deserializeData: any\n  return (world: W, packet: ArrayBuffer, mode: any): number[] => {\n    if (!initSet.has(components)) {\n      initSet.add(components);\n      deserializeObservations = createObserverDeserializer(world, components[0], components);\n      deserializeData = createSoADeserializer(components);\n    }\n    const observerDataLength = deserializeObservations(packet, mode);\n    const soaData = packet.slice(observerDataLength);\n    return deserializeData(soaData, mode);\n  }\n}\n"],
  "mappings": "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",
  "names": ["legacy_exports", "__export", "$modifier", "Changed", "Not", "Or", "Types", "addComponent", "defineComponent", "defineDeserializer", "defineQuery", "defineSerializer", "enterQuery", "exitQuery", "hasComponent", "removeComponent", "__toCommonJS", "import_core", "import_core", "createObserverSerializer", "world", "networkedTag", "components", "buffer", "dataView", "offset", "queue", "eid", "component", "i", "entityId", "type", "componentId", "createObserverDeserializer", "packet", "entityIdMapping", "packetEntityId", "operationType", "worldEntityId", "$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "typeTagForSerialization", "symbol", "a", "u8", "i8", "u16", "i16", "u32", "i32", "f32", "f64", "typeSetters", "view", "offset", "value", "typeGetters", "createComponentSerializer", "component", "props", "setters", "prop", "arr", "type", "index", "bytesWritten", "i", "createComponentDeserializer", "getters", "entityIdMapping", "bytesRead", "originalIndex", "indexSize", "size", "createSoASerializer", "components", "buffer", "componentSerializers", "indices", "j", "createSoADeserializer", "componentDeserializers", "packet", "import_core", "defineSerializer", "components", "maxBytes", "initSet", "serializeObservations", "serializeData", "world", "createObserverSerializer", "createSoASerializer", "observerData", "soaData", "combinedData", "combinedView", "defineDeserializer", "deserializeObservations", "deserializeData", "packet", "mode", "createObserverDeserializer", "createSoADeserializer", "observerDataLength", "$modifier", "modifier", "c", "mod", "inner", "Not", "Or", "Changed", "defineQuery", "components", "queryFn", "world", "enterQuery", "queue", "initSet", "eid", "results", "exitQuery", "addComponent", "component", "ecsAddComponent", "hasComponent", "ecsHasComponent", "removeComponent", "ecsRemoveComponent", "Types", "arrayByTypeMap", "defineComponent", "schema", "max", "createSoA", "key", "type", "length", "TypeConstructor"]
}
