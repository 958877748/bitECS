{
  "version": 3,
  "sources": ["../../src/core/utils/SparseSet.ts", "../../src/core/utils/defineHiddenProperty.ts", "../../src/core/EntityIndex.ts", "../../src/core/World.ts", "../../src/core/Relation.ts", "../../src/core/Entity.ts", "../../src/core/utils/Observer.ts", "../../src/core/Component.ts", "../../src/core/Query.ts", "../../src/serialization/ObserverSerializer.ts", "../../src/serialization/SoASerializer.ts", "../../src/legacy/serialization.ts", "../../src/legacy/index.ts"],
  "sourcesContent": ["export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n}\n\nexport const createSparseSet = () => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t}\n}\n\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(initialCapacity)\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(dense.length * 2)\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t}\n};", "export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n}\n\n/**\n * Creates and initializes a new EntityIndex.\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (): EntityIndex => ({\n    aliveCount: 0,\n    dense: [],\n    sparse: [],\n    maxId: 0,\n})\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount]\n        index.sparse[recycledId] = index.aliveCount\n        index.aliveCount++\n        return recycledId\n    }\n\n    // Create new id\n    const id = ++index.maxId\n    index.dense.push(id)\n    index.sparse[id] = index.aliveCount\n    index.aliveCount++\n\n    return id\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const record = index.sparse[id]\n    if (record === undefined || record >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return\n    }\n\n    const denseIndex = record\n    const lastIndex = index.aliveCount - 1\n    const lastId = index.dense[lastIndex]\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex\n    index.dense[denseIndex] = lastId\n\n    // Update the removed entity's record\n    index.sparse[id] = index.dense.length\n    index.dense[lastIndex] = id\n\n    index.aliveCount--\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const record = index.sparse[id]\n    return record !== undefined && index.dense[record] === id\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query } from './Query'\nimport { EntityId } from './Entity'\n\nexport const $internal = Symbol.for('bitecs_internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<EntityId, Set<ComponentRef>>\n    bitflag: number\n    componentMap: WeakMap<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \n    defineHiddenProperty(context || {} as T, $internal, {\n        entityIndex: entityIndex || createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new WeakMap(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n    }) as World<T>\n\n/**\n * Creates a new world with various configurations.\n * @template T\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\n * @returns {World<T>} The created world.\n */\nexport function createWorld<T extends object = {}>(\n    ...args: Array<EntityIndex | T>\n): World<T> {\n    let entityIndex: EntityIndex | undefined\n    let context: T | undefined\n\n    args.forEach(arg => {\n        if (typeof arg === 'object' && 'add' in arg && 'remove' in arg) {\n            entityIndex = arg as EntityIndex\n        } else if (typeof arg === 'object') {\n            context = arg as T\n        }\n    })\n\n    const world = createBaseWorld<T>(context, entityIndex)\n\n    if (entityIndex) {\n        world[$internal].entityIndex = entityIndex\n    }\n\n    return world\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World) => (world as InternalWorld)[$internal].entityIndex.dense.slice(0)\n", "import { getEntityComponents, World } from '.'\nimport { EntityId } from './Entity'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number} target - The target entity ID.\n */\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol('relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol('pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol('isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol('relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: () => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = data.initStore ? data.initStore() : {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: () => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n    return relation\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard: Relation<any> = createRelation()\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA: Relation<any> = createRelation()\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>) => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tinnerQuery,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport type EntityId = number\n\nexport const Prefab = {}\nexport const addPrefab = (world: World) => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, eid, Prefab)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): EntityId => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, Pair(ChildOf, parent), child)\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n        for (const subject of innerQuery(world, [Wildcard(currentEid)])) {\n            if (!entityExists(world, subject)) {\n                continue\n            }\n\n            for (const component of ctx.entityComponents.get(subject)!) {\n                if (!component[$isPairComponent]) {\n                    continue\n                }\n\n                const relation = component[$relation]\n                const relationData = relation[$relationData]\n                componentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\n\n                if (component[$pairTarget] === currentEid) {\n                    componentRemovalQueue.push(() => removeComponent(world, subject, component))\n                    if (relationData.autoRemoveSubject) {\n                        removalQueue.push(subject)\n                    }\n                    if (relationData.onTargetRemoved) {\n                        componentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n                    }\n                }\n            }\n        }\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error('bitECS - entity is undefined.')\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error('bitECS - entity does not exist in the world.')\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "import { EntityId } from \"../Entity\"\n\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: EntityId, ...args: any[])  => void | object\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n  const notify = (entity: EntityId, ...args: any[]) => {\n    return Array.from(observers).reduce((acc, listener) => {\n      const result = listener(entity, ...args)\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\n    }, {})\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "/**\n * @module Component\n */\n\nimport { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport { \n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World } from './World'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n\tgetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable(),\n\t\tgetObservable: createObservable(),\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to check for.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n/**\n * Retrieves the data associated with a component for a specific entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to retrieve data for.\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\n */\nexport const getComponentData = (world: World, eid: EntityId, component: ComponentRef): any => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\treturn undefined\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\treturn undefined\n\t}\n\n\t// Notify observers that this component is being accessed\n\treturn componentData.getObservable.notify(eid)\n}\n\n/**\n * Helper function to set component data.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\n */\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\n\tcomponent,\n\tdata\n})\n\n/**\n * Sets the data for a component on an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n */\nexport const setComponent = (world: World, eid: EntityId, component: ComponentRef, data: any): void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot set component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tif (!ctx.componentMap.has(component)) {\n\t\tregisterComponent(world, component)\n\t}\n\n\tconst componentData = ctx.componentMap.get(component)!\n\n\tif (!hasComponent(world, eid, component)) {\n\t\taddComponent(world, eid, component)\n\t}\n\n\tcomponentData.setObservable.notify(eid, data)\n}\n\n\n/**\n * Recursively inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n */\nconst recursivelyInherit = (world: World, baseEid: EntityId, inheritedEid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\taddComponent(world, baseEid, IsA(inheritedEid))\n\tconst components = getEntityComponents(world, inheritedEid)\n\tfor (const component of components) {\n\t\tif (component === Prefab) {\n\t\t\tcontinue\n\t\t}\n\t\taddComponent(world, baseEid, component)\n\t\t// Trigger onSet observer for this component\n\t\t// TODO: inherit reference vs copy\n\t\tconst componentData = ctx.componentMap.get(component)\n\t\tif (componentData && componentData.setObservable) {\n\t\t\tconst data = getComponentData(world, inheritedEid, component)\n\t\t\tcomponentData.setObservable.notify(baseEid, data)\n\t\t}\n\t}\n\n\tconst inheritedTargets = getRelationTargets(world, inheritedEid, IsA)\n\tfor (const inheritedEid2 of inheritedTargets) {\n\t\trecursivelyInherit(world, baseEid, inheritedEid2)\n\t}\n}\n\n/**\n * Represents a component with data to be set on an entity.\n */\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\n\n/**\n * Adds one or more components to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {...(ComponentRef | ComponentSetter)} components - Components to add or set.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(componentOrSet => {\n\t\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\n\t\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\n\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\t\tif (hasComponent(world, eid, component)) return\n\n\t\tconst componentData = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentData\n\n\t\tctx.entityMasks[generationId][eid] |= bitflag\n\n\t\tif (!hasComponent(world, eid, Prefab)) {\n\t\t\tqueries.forEach((queryData: Query) => {\n\t\t\t\tqueryData.toRemove.remove(eid)\n\t\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t\t})\n\t\t}\n\n\t\tctx.entityComponents.get(eid)!.add(component)\n\n\t\tif (data !== undefined) {\n\t\t\tcomponentData.setObservable.notify(eid, data)\n\t\t}\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst relation = component[$relation]\n\t\t\taddComponent(world, eid, Pair(relation, Wildcard))\n\t\t\tconst target = component[$pairTarget]\n\t\t\taddComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\tconst relationData = relation[$relationData]\n\t\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\n\t\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (relation === IsA) {\n\t\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\n\t\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\t\trecursivelyInherit(world, eid, inherited)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for addComponent.\n */\nexport const addComponents = addComponent\n\n/**\n * Removes one or more components from an entity.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(component => {\n\t\tif (!hasComponent(world, eid, component)) return\n\n\t\tconst componentNode = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentNode\n\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\n\t\tctx.entityComponents.get(eid)!.delete(component)\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst target = component[$pairTarget]\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\tconst relation = component[$relation]\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\n\t\t\tif (otherTargets.length === 0) {\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for removeComponent.\n */\nexport const removeComponents = removeComponent\n", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { EntityId, Prefab } from './Entity'\n\n/**\n * @typedef {Uint32Array | readonly number[]} QueryResult\n * @description The result of a query, either as a Uint32Array or a readonly array of numbers.\n */\nexport type QueryResult = Uint32Array | readonly EntityId[]\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS.\n * @property {ComponentRef[]} allComponents - All components in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Object.<number, number>} masks - Bitmasks for each component generation.\n * @property {Object.<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Object.<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Object.<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: Record<number, number>\n\torMasks: Record<number, number>\n\tnotMasks: Record<number, number>\n\thasMasks: Record<number, number>\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n\tqueues: Record<any, any>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n\n/**\n * Symbols for query operator types and components\n */\nexport const $opType = Symbol('opType');\nexport const $opTerms = Symbol('opTerms');\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opTerms] - The components involved in the operation.\n */\nexport type OpReturnType = {\n\t[$opType]: string\n\t[$opTerms]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator} QueryTerm\n * @description A term in a query, either a component reference or a query operator.\n */\nexport type QueryTerm = ComponentRef | QueryOperator\n\n\n// Aliases\nexport type OrOp = QueryOperator\nexport type AndOp = QueryOperator\nexport type NotOp = QueryOperator\nexport type AnyOp = OrOp\nexport type AllOp = AndOp\nexport type NoneOp = NotOp\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...QueryTerm} terms - The query terms to observe.\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\n */\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\n\t[$opTerms]: QueryTerm[]\n}\n\nexport type ObservableHook = ReturnType<ObservableHookDef>\n\n/**\n * @function onAdd\n * @description Creates an 'add' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for addition.\n * @returns {OpReturnType} The 'add' observable hook configuration.\n */\nexport const onAdd: ObservableHookDef = (...terms: QueryTerm[]) => ({\n\t[$opType]: 'add',\n\t[$opTerms]: terms\n})\n\n/**\n * @function onRemove\n * @description Creates a 'remove' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for removal.\n * @returns {OpReturnType} The 'remove' observable hook configuration.\n */\nexport const onRemove: ObservableHookDef = (...terms: QueryTerm[]) => ({\n\t[$opType]: 'remove',\n\t[$opTerms]: terms\n})\n\n/**\n * @function onSet\n * @description Creates a 'set' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for setting.\n * @returns {OpReturnType} The 'set' observable hook configuration.\n */\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({\n\t[$opType]: 'set',\n\t[$opTerms]: [component]\n})\n\n/**\n * @function onGet\n * @description Creates a 'get' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for getting.\n * @returns {OpReturnType} The 'get' observable hook configuration.\n */\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({\n\t[$opType]: 'get',\n\t[$opTerms]: [component]\n})\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ObservableHook} hook - The observable hook.\n * @param {function(number): any} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opTerms]: components } = hook\n\n\tif (type === 'add' || type === 'remove') {\n\t\tconst hash = queryHash(world, components)\n\t\tlet queryData = ctx.queriesHashMap.get(hash)!\n\n\t\tif (!queryData) {\n\t\t\tqueryData = registerQuery(world, components)\n\t\t}\n\n\t\tconst observableKey = type === 'add' ? 'addObservable' : 'removeObservable'\n\t\treturn queryData[observableKey].subscribe(callback)\n\t} else if (type === 'set' || type === 'get') {\n\t\tif (components.length !== 1) {\n\t\t\tthrow new Error('Set and Get hooks can only observe a single component')\n\t\t}\n\t\tconst component = components[0]\n\t\tlet componentData = ctx.componentMap.get(component)\n\t\tif (!componentData) {\n\t\t\tcomponentData = registerComponent(world, component)\n\t\t}\n\t\tconst observableKey = type === 'set' ? 'setObservable' : 'getObservable'\n\t\treturn componentData[observableKey].subscribe(callback)\n\t}\n\n\tthrow new Error(`Invalid hook type: ${type}`)\n}\n\n/**\n * @function Or\n * @description Creates an 'Or' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Or' operator to.\n * @returns {OpReturnType} The 'Or' operator configuration.\n */\nexport const Or: OrOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Or',\n\t[$opTerms]: components\n})\n\n/**\n * @function And\n * @description Creates an 'And' query operator.\n * @param {...ComponentRef} components - The components to apply the 'And' operator to.\n * @returns {OpReturnType} The 'And' operator configuration.\n */\nexport const And: AndOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'And',\n\t[$opTerms]: components\n})\n\n/**\n * @function Not\n * @description Creates a 'Not' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Not' operator to.\n * @returns {OpReturnType} The 'Not' operator configuration.\n */\nexport const Not: NotOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Not',\n\t[$opTerms]: components\n})\n\nexport const Any: AnyOp = Or\nexport const All: AllOp = And\nexport const None: NoneOp = Not\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\n\tconst getComponentId = (component: ComponentRef): number => {\n\t\tif (!ctx.componentMap.has(component)) {\n\t\t\tregisterComponent(world, component)\n\t\t}\n\t\treturn ctx.componentMap.get(component)!.id\n\t}\n\tconst termToString = (term: QueryTerm): string => {\n\t\tif ($opType in term) {\n\t\t\tconst componentIds = term[$opTerms].map(getComponentId)\n\t\t\tconst sortedComponentIds = componentIds.sort((a, b) => a - b)\n\t\t\tconst sortedType = term[$opType].toLowerCase()\n\t\t\treturn `${sortedType}(${sortedComponentIds.join(',')})`\n\t\t} else {\n\t\t\treturn getComponentId(term).toString()\n\t\t}\n\t}\n\n\treturn terms\n\t\t.map(termToString)\n\t\t.sort()\n\t\t.join('-')\n}\n\n/**\n * @function registerQuery\n * @description Registers a new query in the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\t// if (ctx.queriesHashMap.has(hash)) {\n\t// \treturn ctx.queriesHashMap.get(hash)!\n\t// }\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst processComponents = (comps: ComponentRef[], targetArray: ComponentRef[]) => {\n\t\tcomps.forEach((comp: ComponentRef) => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\ttargetArray.push(comp)\n\t\t})\n\t}\n\n\tterms.forEach((term: QueryTerm) => {\n\t\tif ($opType in term) {\n\t\t\tif (term[$opType] === 'Not') {\n\t\t\t\tprocessComponents(term[$opTerms], notComponents)\n\t\t\t} else if (term[$opType] === 'Or') {\n\t\t\t\tprocessComponents(term[$opTerms], orComponents)\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst mapComponents = (c: ComponentRef) => ctx.componentMap.get(c)!\n\tconst allComponents = components.concat(notComponents.flat()).concat(orComponents.flat()).map(mapComponents)\n\n\tconst sparseSet = options.buffered ? createUint32SparseSet() : createSparseSet()\n\n\tconst toRemove = createSparseSet()\n\n\tconst generations = allComponents\n\t\t.map((c) => c.generationId)\n\t\t.reduce((a, v) => {\n\t\t\tif (a.includes(v)) return a\n\t\t\ta.push(v)\n\t\t\treturn a\n\t\t}, [] as number[])\n\n\tconst reduceBitflags = (a: { [key: number]: number }, c: ComponentData) => {\n\t\tif (!a[c.generationId]) a[c.generationId] = 0\n\t\ta[c.generationId] |= c.bitflag\n\t\treturn a\n\t}\n\n\tconst masks = components.map(mapComponents).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponents.reduce(reduceBitflags, {})\n\n\tconst addObservable = createObservable()\n\tconst removeObservable = createObservable()\n\n\tconst query = Object.assign(sparseSet, {\n\t\tcomponents,\n\t\tnotComponents,\n\t\torComponents,\n\t\tallComponents,\n\t\tmasks,\n\t\tnotMasks,\n\t\torMasks,\n\t\thasMasks,\n\t\tgenerations,\n\t\ttoRemove,\n\t\taddObservable,\n\t\tremoveObservable,\n\t\tqueues: {},\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponents.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, eid, Prefab)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n/**\n * @function innerQuery\n * @description Performs an internal query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function innerQuery(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\treturn queryData.dense\n}\n\n/**\n * @function query\n * @description Performs a query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {readonly EntityId[]} The result of the query as a readonly array of entity IDs.\n */\nexport function query(world: World, terms: QueryTerm[]): readonly EntityId[] {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms) as EntityId[]\n}\n\n/**\n * @function bufferQuery\n * @description Performs a buffered query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {Uint32Array} The result of the query as a Uint32Array.\n */\nexport function bufferQuery(world: World, terms: QueryTerm[]): Uint32Array {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms, { buffered: true }) as Uint32Array\n}\n\n/**\n * @function queryCheckEntity\n * @description Checks if an entity matches a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) === 0) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n} from '../core'\nimport { EntityId } from '../core/Entity'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components to observe for changes.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the queued changes and returns a slice of the buffer.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], buffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n    const queue: [number, OperationType, number][] = []\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n    })\n\n    components.forEach((component, i) => {\n        observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n            queue.push([eid, OperationType.AddComponent, i])\n        })\n\n        observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n            queue.push([eid, OperationType.RemoveComponent, i])\n        })\n    })\n\n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            dataView.setUint8(offset, componentId)\n            offset += 1\n        }\n        queue.length = 0\n\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n * @param {World} world - The ECS world object.\n * @param {any} networkedTag - The component used to tag networked entities.\n * @param {any[]} components - An array of components that can be added or removed.\n * @returns {Function} A function that takes a serialized packet and an optional entity ID mapping, and applies the changes to the world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], entityIdMapping: Map<number, number> = new Map()) => {\n    return (packet: ArrayBuffer) => {\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            const componentId = dataView.getUint8(offset)\n            offset += 1\n\n            const component = components[componentId]\n\n            let worldEntityId = entityIdMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                entityIdMapping.set(packetEntityId, worldEntityId)\n            }\n            if (operationType === OperationType.AddEntity) {\n                addComponent(world, worldEntityId, networkedTag)\n            } else if (operationType === OperationType.RemoveEntity) {\n                removeEntity(world, worldEntityId)\n            } else if (operationType === OperationType.AddComponent) {\n                addComponent(world, worldEntityId, component)\n            } else if (operationType === OperationType.RemoveComponent) {\n                removeComponent(world, worldEntityId, component)\n            }\n        }\n\n        return entityIdMapping\n    }\n}\n", "import { ComponentRef } from \"../core\"\n\n/**\n * Symbols representing different data types for serialization.\n */\nconst $u8 = Symbol('u8'), $i8 = Symbol('i8'), $u16 = Symbol('u16'), $i16 = Symbol('i16'),\n    $u32 = Symbol('u32'), $i32 = Symbol('i32'), $f32 = Symbol('f32'), $f64 = Symbol('f64')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = (number[] & { [key: symbol]: true }) | TypedArray\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = (symbol: TypeSymbol) => (a: number[] = []): PrimitiveBrand => \n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as PrimitiveBrand\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = typeTagForSerialization($u8),     i8 = typeTagForSerialization($i8),\n            u16 = typeTagForSerialization($u16),    i16 = typeTagForSerialization($i16),\n            u32 = typeTagForSerialization($u32),    i32 = typeTagForSerialization($i32),\n            f32 = typeTagForSerialization($f32),    f64 = typeTagForSerialization($f64)\n\n/**\n * Object containing setter functions for each data type.\n */\nconst typeSetters = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; }\n}\n\n/**\n * Object containing getter functions for each data type.\n */\nconst typeGetters = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 })\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number) => {\n        let bytesWritten = 0\n        // Write index first\n        bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index)\n        for (let i = 0; i < props.length; i++) {\n            bytesWritten += setters[i](view, offset + bytesWritten, component[props[i]][index])\n        }\n        return bytesWritten\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef) => {\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64]) {\n            if (symbol in arr) return symbol\n        }\n        return $f64; // default to float64 if no type is specified\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        for (let i = 0; i < props.length; i++) {\n            const { value, size } = getters[i](view, offset + bytesRead)\n            component[props[i]][index] = value\n            bytesRead += size\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {ArrayBuffer} [buffer] - The buffer to use for serialization.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: ComponentRef[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const view = new DataView(buffer)\n    const componentSerializers = components.map(createComponentSerializer)\n    return (indices: number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index)\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: ComponentRef[]) => {\n    const componentDeserializers = components.map(createComponentDeserializer)\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            for (let i = 0; i < componentDeserializers.length; i++) {\n                offset += componentDeserializers[i](view, offset, entityIdMapping)\n            }\n        }\n    }\n}\n", "\nimport { createObserverSerializer, createObserverDeserializer } from '../serialization/ObserverSerializer'\nimport { createSoASerializer, createSoADeserializer } from '../serialization/SoASerializer'\nimport { IWorld, Component, IComponentProp } from './index'\n\nexport type Serializer<W extends IWorld = IWorld> = (world: W, ents: number[]) => ArrayBuffer\nexport type Deserializer<W extends IWorld = IWorld> = (world: W, packet: ArrayBuffer, mode?: DESERIALIZE_MODE) => number[]\n\nexport function defineSerializer<W extends IWorld = IWorld>(components: Component[] | IComponentProp[], maxBytes?: number): Serializer<W> {\n  const initSet = new WeakSet<W>();\n  let serializeObservations: () => ArrayBuffer, serializeData: (indices: number[]) => ArrayBuffer;\n  return (world: W, ents: number[]) => {\n    if (!initSet.has(world)) {\n      initSet.add(world);\n      serializeObservations = createObserverSerializer(world, components[0], components);\n      serializeData = createSoASerializer(components as Component[]);\n    }\n    const observerData = serializeObservations();\n    const soaData = serializeData(ents);\n    // Combine observer and soa data into a single ArrayBuffer\n    const combinedData = new ArrayBuffer(observerData.byteLength + soaData.byteLength);\n    const combinedView = new Uint8Array(combinedData);\n    combinedView.set(new Uint8Array(observerData), 0);\n    combinedView.set(new Uint8Array(soaData), observerData.byteLength);\n    return combinedData;\n  }\n}\n\nexport function defineDeserializer<W extends IWorld = IWorld>(components: Component[] | IComponentProp[]): Deserializer<W> {\n  const initSet = new WeakSet<W>();\n  let deserializeObservations: any, deserializeData: any\n  return (world: W, packet: ArrayBuffer, mode: any): number[] => {\n    if (!initSet.has(world)) {\n      initSet.add(world);\n      deserializeObservations = createObserverDeserializer(world, components[0], components);\n      deserializeData = createSoADeserializer(components);\n    }\n    const observerDataLength = deserializeObservations(packet, mode);\n    const soaData = packet.slice(observerDataLength);\n    return deserializeData(soaData, mode);\n  }\n}\n\nexport enum DESERIALIZE_MODE {\n    REPLACE,\n    APPEND,\n    MAP\n}", "import { ComponentRef } from '../core/Component'\nimport { observe, onAdd, onRemove, query } from '../core/Query'\nimport { EntityId } from '../core/Entity'\nimport {\n  addComponent as ecsAddComponent,\n  hasComponent as ecsHasComponent,\n  removeComponent as ecsRemoveComponent\n} from '../core/Component'\n\nexport interface IWorld { }\n\nexport type ComponentProp = TypedArray | Array<TypedArray>\n\nexport interface IComponentProp {\n}\n\nexport interface IComponent {\n}\n\nexport type Component = IComponent | ComponentType<ISchema>\n\nexport type QueryModifier = (c: IComponent[]) => IComponent | QueryModifier\n\nexport type Query<W extends IWorld = IWorld> = (world: W, clearDiff?: Boolean) => number[]\n\nexport const $modifier = Symbol(\"$modifier\")\n\nfunction modifier(c, mod) {\n  const inner = () => [c, mod]\n  inner[$modifier] = true\n  return inner\n}\n\nexport const Not = (c: Component | ISchema): QueryModifier => modifier(c, 'not')\nexport const Or = (c: Component | ISchema): QueryModifier => modifier(c, 'or')\nexport const Changed = (c: Component | ISchema): QueryModifier => modifier(c, 'changed')\n\nexport function defineQuery<W extends IWorld = IWorld>(components: (Component | QueryModifier)[]): Query<W> {\n  const queryFn = (world: IWorld) => query(world, components)\n  queryFn.components = components\n  return queryFn as unknown as Query<W>\n}\n\nexport function enterQuery<W extends IWorld = IWorld>(queryFn: Query<W>): Query<W> {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: W) => {\n    if (!initSet.has(world)) {\n      observe(world, onAdd(...(queryFn as any).components), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport function exitQuery<W extends IWorld = IWorld>(queryFn: Query<W>): Query<W> {\n  let queue: number[] = []\n  const initSet = new WeakSet<IWorld>()\n  return (world: W) => {\n    if (!initSet.has(world)) {\n      observe(world, onRemove(...(queryFn as any).components), (eid: EntityId) => queue.push(eid))\n      initSet.add(world)\n    }\n    const results = queue.slice()\n    queue.length = 0\n    return results\n  }\n}\n\nexport const addComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsAddComponent(world, eid, component)\n\nexport const hasComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsHasComponent(world, eid, component)\n\nexport const removeComponent = (world: IWorld, component: ComponentRef, eid: EntityId) =>\n  ecsRemoveComponent(world, eid, component)\n\nexport interface ISchema {\n  [key: string]: Type | ListType | ISchema\n}\n\nexport type Type =\n  | 'i8'\n  | 'ui8'\n  | 'ui8c'\n  | 'i16'\n  | 'ui16'\n  | 'i32'\n  | 'ui32'\n  | 'f32'\n  | 'f64'\n  | 'eid'\n\nexport type ListType = readonly [Type, number];\n\nexport const Types = {\n  i8: 'i8' as Type,\n  ui8: 'ui8' as Type,\n  ui8c: 'ui8c' as Type,\n  i16: 'i16' as Type,\n  ui16: 'ui16' as Type,\n  i32: 'i32' as Type,\n  ui32: 'ui32' as Type,\n  f32: 'f32' as Type,\n  f64: 'f64' as Type,\n  eid: 'eid' as Type\n};\n\nexport type TypedArray =\n  | Uint8Array\n  | Int8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n\nexport type ArrayByType = {\n  'i8': Int8Array;\n  'ui8': Uint8Array;\n  'ui8c': Uint8ClampedArray;\n  'i16': Int16Array;\n  'ui16': Uint16Array;\n  'i32': Int32Array;\n  'ui32': Uint32Array;\n  'f32': Float32Array;\n  'f64': Float64Array;\n  'eid': Uint32Array;\n}\n\n// ... existing code ...\n\nconst arrayByTypeMap: { [key in Type]: any } = {\n  'i8': Int8Array,\n  'ui8': Uint8Array,\n  'ui8c': Uint8ClampedArray,\n  'i16': Int16Array,\n  'ui16': Uint16Array,\n  'i32': Int32Array,\n  'ui32': Uint32Array,\n  'f32': Float32Array,\n  'f64': Float64Array,\n  'eid': Uint32Array,\n};\n\nexport type ComponentType<T extends ISchema> = {\n  [key in keyof T]:\n  T[key] extends Type\n  ? ArrayByType[T[key]]\n  : T[key] extends [infer RT, number]\n  ? RT extends Type\n  ? Array<ArrayByType[RT]>\n  : unknown\n  : T[key] extends ISchema\n  ? ComponentType<T[key]>\n  : unknown;\n};\n\nexport const defineComponent = <T extends ISchema>(schema: T, max: number = 1e5): ComponentType<T> => {\n  const createSoA = <U extends ISchema>(schema: U, max: number): ComponentType<U> => {\n    const component = {} as ComponentType<U>\n    for (const key in schema) {\n      if (Array.isArray(schema[key])) {\n        const [type, length] = schema[key] as [Type, number]\n        component[key] = Array.from({ length }, () => new arrayByTypeMap[type](max)) as any\n      } else if (typeof schema[key] === 'object') {\n        component[key] = createSoA(schema[key] as ISchema, max) as any\n      } else {\n        const type = schema[key] as Type;\n        const TypeConstructor = arrayByTypeMap[type];\n        if (TypeConstructor) {\n          component[key] = new TypeConstructor(max) as any;\n        } else {\n          throw new Error(`Unsupported type: ${schema[key]}`);\n        }\n      }\n    }\n    return component\n  }\n  return createSoA(schema, max)\n}\n\nexport * from './serialization'"],
  "mappings": "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",
  "names": ["onRemove", "modifier", "hasComponent", "addComponent", "hasComponent", "removeComponent", "removeComponent", "hasComponent", "query", "hasComponent", "query", "query", "addComponent", "removeComponent", "addEntity", "removeEntity", "observe", "onAdd", "onRemove", "observe", "onAdd", "onRemove", "addEntity", "addComponent", "removeEntity", "removeComponent", "DESERIALIZE_MODE", "addComponent", "hasComponent", "removeComponent", "schema", "max"]
}
